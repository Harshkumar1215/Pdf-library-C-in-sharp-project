<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="textBox1.Text" xml:space="preserve">
    <value>
 SYLLABUS
Module -I
C Language Fundamentals.
Character set, Identifiers, keyword, data types, Constants and variables, statements,
expression, operators, precedence of operators, Input-output, Assignments, control structures
decision making and branching.
Module -II
Arrays, Functions and Strings: Declaration, manipulation and String - handling
functions, monolithic vs. Modular programs, user defined vs. standard functions, formal vs. actual
arguments, function - category, function prototypes, parameter passing, recursion, and storage classes:
auto, extern, global, static.
Module -III
Pointers, Structures, Unions, File handling:
Pointer variable and its importance, pointer arithmetic, passing parameters, Declaration of structures,
pointer to pointer, pointer to structure, pointer to function, union, dynamic memory allocation, file
managements.
 2 *Under revision

·	CONTENTS
·	Module: 1
·	Lecture 1: Introduction to C
·	Lecture 2: Structure of C, compilation, execution
·	Lecture 3:character set, identifiers, keywords
·	Lecture 4: constants, variables
·	Lecture 5: expression, operators
·	Lecture 6: operators continue…
·	Lecture 7: loops: do while, while
·	Lecture 8: for loop, break, continue statement
·	Lecture 9: control Statements
·	Lecture 10: nesting of if else…, if else ladder
·	Lecture 11: arrays
·	Lecture 12: 2-diamensional array
Module: 2
 3 *Under revision

 Lecture 13: String library functions
 Lecture 14: functions, categories
 Lecture 15: functions categories cont..
Lecture 16: Actual arguments and Formal arguments, call by value call by
reference
 Lecture 17:local, global, static variable
 Lecture 18: monolithic vs modular programming, Storage classes
 Lecture 19:storage class cont.., pointer
 Lecture 20: pointer comparison, increment decrement
 Lecture 21: precedence level of pointer, pointer comparison
 Lecture 22: pointer to pointer, pointer to structure
 Lecture 23: pointer initialization, accessing elements
Module: 3
 Lecture 24: size of Structure in, array vs structure, array within structure
Lecture 25: passing structure to function, Nested Structure
 Lecture 26: Union
 Lecture 27: nesting of unions, dynamic memory allocation
Lecture 28: dynamic memory allocation conti…
Lecture 29: dynamic array, file
 Lecture 30: file operation
 Lecture 31: file operation on string
Lecture 32:
 Lecture 33:
 4 *Under revision

 Lecture Note: 1

 Introduction to C
 C is a programming language developed at AT &amp; T’s Bell Laboratories of USA
in 1972. It was designed and written by a man named Dennis Ritchie. In the late
seventies C began to replace the more familiar languages of that time like PL/I,
ALGOL, etc
 ANSI C standard emerged in the early 1980s, this book was split into two
titles: The original was still called Programming in C, and the title that covered
ANSI C was called Programming in ANSI C. This was done because it took
several years for the compiler vendors to release their ANSI C compilers and for
them to become ubiquitous. It was initially designed for programming UNIX
operating system. Now the software tool as well as the C compiler is written in C.
Major parts of popular operating systems like Windows, UNIX, Linux is still
written in C. This is because even today when it comes to performance (speed of
execution) nothing beats C. Moreover, if one is to extend the operating system to
work with new devices one needs to write device driver programs. These
programs are exclusively written in C. C seems so popular is because it is reliable,
simple and easy to use. often heard today is - “C has been already superceded
by languages like C++, C# and Java.
Program
 5 *Under revision

There is a close analogy between learning English language and learning C
language. The classical method of learning English is to first learn the alphabets
used in the language, then learn to combine these alphabets to form words, which
in turn are combined to form sentences and sentences are combined to form
paragraphs. Learning C is similar and easier. Instead of straight-away learning how
to write programs, we must first know what alphabets, numbers and special
symbols are used in C, then how using them constants, variables and keywords are
constructed, and finally how are these combined to form an instruction. A group
of instructions would be combined later on to form a program. So
 a computer program is just a collection of the instructions necessary to solve a
specific problem. The basic operations of a computer system form what is known
as the computer’s instruction set. And the approach or method that is used to solve
the problem is known as an algorithm.
So for as programming language concern these are of two types.
 1) Low level language
 2) High level language
Low level language:
 6 *Under revision

 Low level languages are machine level and assembly level language. In
machine level language computer only understand digital numbers i.e. in the form
of 0 and 1. So, instruction given to the computer is in the form binary digit, which
is difficult to implement instruction in binary code. This type of program is not
portable, difficult to maintain and also error prone. The assembly language is on
other hand modified version of machine level language. Where instructions are
given in English like word as ADD, SUM, MOV etc. It is easy to write and
understand but not understand by the machine. So the translator used here is
assembler to translate into machine level. Although language is bit easier,
programmer has to know low level details related to low level language. In the
assembly level language the data are stored in the computer register, which varies
for different computer. Hence it is not portable.
High level language:
 These languages are machine independent, means it is portable. The language in
this category is Pascal, Cobol, Fortran etc. High level languages are understood by
the machine. So it need to translate by the translator into machine level. A
translator is software which is used to translate high level language as well as low
level language in to machine level language.
 Three types of translator are there:
Compiler
Interpreter
Assembler
 Compiler and interpreter are used to convert the high level language into machine
level language. The program written in high level language is known as source
program and the corresponding machine level language program is called as object
program. Both compiler and interpreter perform the same task but there working is
different. Compiler read the program at-a-time and searches the error and lists
them. If the program is error free then it is converted into object program. When
program size is large then compiler is preferred. Whereas interpreter read only one
line of the source code and convert it to object code. If it check error, statement by
statement and hence of take more time.
 7 *Under revision

Integrated Development Environments (IDE)
The process of editing, compiling, running, and debugging programs is often
managed by a single integrated application known as an Integrated Development
Environment, or IDE for short. An IDE is a windows-based program that allows us
to easily manage large software programs, edit files in windows, and compile, link,
run, and debug programs.
On Mac OS X, CodeWarrior and Xcode are two IDEs that are used by many
programmers. Under Windows, Microsoft Visual Studio is a good example of a
popular IDE. Kylix is a popular IDE for developing applications under Linux.
Most IDEs also support program development in several different programming
languages in addition to C, such as C# and C++.
 8 *Under revision

 Lecture Note: 2
Structure of C Language program
1 ) Comment line
2) Preprocessor directive
3 ) Global variable declaration
4) main function( )
 {
 Local variables;
 Statements;
 }
 User defined function
 }
}
Comment line
It indicates the purpose of the program. It is represented as
/*……………………………..*/
Comment line is used for increasing the readability of the program. It is useful in
explaining the program and generally used for documentation. It is enclosed within
the decimeters. Comment line can be single or multiple line but should not be
nested. It can be anywhere in the program except inside string constant &amp; character
constant.
Preprocessor Directive:
 9 *Under revision

#include&lt;stdio.h&gt; tells the compiler to include information about the standard
input/output library. It is also used in symbolic constant such as #define PI
3.14(value). The stdio.h (standard input output header file) contains definition
&amp;declaration of system defined function such as printf( ), scanf( ), pow( ) etc.
Generally printf() function used to display and scanf() function used to read value
Global Declaration:
This is the section where variable are declared globally so that it can be access by
all the functions used in the program. And it is generally declared outside the
function :
main()
It is the user defined function and every function has one main() function from
where actually program is started and it is encloses within the pair of curly braces.
The main( ) function can be anywhere in the program but in general practice it is
placed in the first position.
Syntax :
 main()
{
……..
……..
……..
}
The main( ) function return value when it declared by data type as
 int main( )
{
return 0
 10 *Under revision

}
The main function does not return any value when void (means null/empty) as
void main(void ) or void main()
{
 printf (“C language”);
}
Output: C language
The program execution start with opening braces and end with closing brace.
And in between the two braces declaration part as well as executable part is
mentioned. And at the end of each line, the semi-colon is given which indicates
statement termination.
/*First c program with return statement*/
#include &lt;stdio.h&gt;
int main (void)
{
printf ("welcome to c Programming language.\n");
return 0;
}
Output: welcome to c programming language.
Steps for Compiling and executing the Programs
A compiler is a software program that analyzes a program developed in a particular
computer language and then translates it into a form that is suitable for execution
 11 *Under revision

on a particular computer system. Figure below shows the steps that are involved in
entering, compiling, and executing a
computer program developed in the C programming language and the typical Unix
commands that would be entered from the command line.
 Step 1: The program that is to be compiled is first typed into a file on the
computer system. There are various conventions that are used for naming files,
typically be any name provided the last two characters are “.c” or file with
extension .c. So, the file name prog1.c might be a valid filename for a C program.
A text editor is usually used to enter the C program into a file. For example, vi is a
popular text editor used on Unix systems. The program that is entered into the file
is known as the source program because it represents the original form of the
program expressed in the C language.
Step 2: After the source program has been entered into a file, then proceed to have
it compiled. The compilation process is initiated by typing a special command on
the system. When this command is entered, the name of the file that contains the
source program must also be specified. For example, under Unix, the command to
initiate program compilation is called cc. If we are using the popular GNU C
compiler, the command we use is gcc.
 Typing the line
 gcc prog1.c or cc prog1.c
In the first step of the compilation process, the compiler examines each program
statement contained in the source program and checks it to ensure that it conforms
to the syntax and semantics of the language. If any mistakes are discovered by the
compiler during this phase, they are reported to the user and the compilation
process ends right there. The errors then have to be corrected in the source program
(with the use of an editor), and the compilation process must be restarted. Typical
errors reported during this phase of compilation might be due to an expression that
has unbalanced parentheses (syntactic error), or due to the use of a variable that is
not “defined” (semantic error).
 12 *Under revision

Step 3: When all the syntactic and semantic errors have been removed from the
program, the compiler then proceeds to take each statement of the program and
translate it into a “lower” form that is equivalent to assembly language program
needed to perform the identical task.
Step 4: After the program has been translated the next step in the compilation
process is to translate the assembly language statements into actual machine
instructions. The assembler takes each assembly language statement and converts it
into a binary format known as object code, which is then written into another file
on the system. This file has the same name as the source file under Unix, with the
last letter an “o” (for object) instead of a “c”.
Step 5: After the program has been translated into object code, it is ready to be
linked. This process is once again performed automatically whenever the cc or gcc
command is issued under Unix. The purpose of the linking phase is to get the
program into a final form for execution on the computer.
 If the program uses other programs that were previously
processed by the compiler, then during this phase the programs are linked together.
Programs that are used from the system’s program library are also searched and
linked together with the object program during this phase.
The process of compiling and linking a program is often called building.
The final linked file, which is in an executable object code format, is stored in
another file on the system, ready to be run or executed. Under Unix, this file is
called a.out by default. Under Windows, the executable file usually has the same
name as the source file, with the c extension replaced by an exe extension.
 13 *Under revision

Step 6: To subsequently execute the program, the command a.out has the effect
of loading the program called a.out into the computer’s memory and initiating its
execution.
When the program is executed, each of the statements of the program is
sequentially executed in turn. If the program requests any data from the user,
known as input, the program temporarily suspends its execution so that the input
can be entered. Or, the program might simply wait for an event, such as a mouse
being clicked, to occur. Results that are displayed by the program, known as
output, appear in a window, sometimes called the console. If the program does not
produce the desired results, it is necessary to go back and reanalyze the program’s
logic. This is known as the debugging phase, during which an attempt is made to
remove all the known problems or bugs from the program. To do this, it will most
 14 *Under revision

likely be necessary to make changes to original source program.
 15 *Under revision

/* Simple program to add two numbers…………………….*/
 16 *Under revision

#include &lt;stdio.h&gt;
int main (void)
{
int v1, v2, sum; //v1,v2,sum are variables and int is data type declared
v1 = 150;
v2 = 25;
sum = v1 + v2;
printf ("The sum of %i and %i is= %i\n", v1, v2, sum);
return 0;
}
Output:
 The sum of 150 and 25 is=175
 Lectu
re Note: 3
 Character set
A character denotes any alphabet, digit or special symbol used to represent
information. Valid alphabets, numbers and special symbols allowed in C are
 17 *Under revision

The alphabets, numbers and special symbols when properly combined form
constants, variables and keywords.
 Identifiers
 Identifiers are user defined word used to name of entities like variables, arrays,
functions, structures etc. Rules for naming identifiers are:
1) name should only consists of alphabets (both upper and lower case), digits
and underscore (_) sign.
2) first characters should be alphabet or underscore
3) name should not be a keyword
4) since C is a case sensitive, the upper case and lower case considered
differently, for example code, Code, CODE etc. are different identifiers.
 5) identifiers are generally given in some meaningful name such as value,
net_salary, age, data etc. An identifier name may be long, some implementation
recognizes only first eight characters, most recognize 31 characters. ANSI
standard compiler recognize 31 characters. Some invalid identifiers are 5cb, int,
res#, avg no etc.

 Keyword
 18 *Under revision

 There are certain words reserved for doing specific task, these words
are known as reserved word or keywords. These words are predefined and always
written in lower case or small letter. These keywords cann’t be used as a variable
name as it assigned with fixed meaning. Some examples are int, short, signed,
unsigned, default, volatile, float, long, double, break, continue, typedef, static,
do, for, union, return, while, do, extern, register, enum, case, goto, struct,
char, auto, const etc.


 data types
Data types refer to an extensive system used for declaring variables or functions of
different types before its use. The type of a variable determines how much space it
occupies in storage and how the bit pattern stored is interpreted. The value of a
variable can be changed any time.
C has the following 4 types of data types
basic built-in data types: int, float, double, char
Enumeration data type: enum
Derived data type: pointer, array, structure, union
Void data type: void
 A variable declared to be of type int can be used to contain integral values
only-that is, values that do not contain decimal places. A variable declared to be
of type float can be used for storing floating- point numbers (values containing
decimal places). The double type is the same as type float, only with roughly twice
the precision. The char data type can be used to store a single character, such as the
letter a, the digit character 6, or a semicolon similarly A variable declared char can
only store character type value.
There are two types of type qualifier in c
 Size qualifier: short, long
Sign qualifier: signed, unsigned
 19 *Under revision

 When the qualifier unsigned is used the number is always positive, and when
signed is used number may be positive or negative. If the sign qualifier is not
mentioned, then by default sign qualifier is assumed. The range of values for
signed data types is less than that of unsigned data type. Because in signed type,
the left most bit is used to represent sign, while in unsigned type this bit is also
used to represent the value. The size and range of the different data types on a 16
bit machine is given below:
Basic data type Data type with type
qualifier
Size
(byte)
Range
char char or signed char
Unsigned char
1
1
-128 to 127
0 to 255
int int or signed int
unsigned int
short int or signed short int
unsigned short int
long int or signed long int
unsigned long int
2
2
1
1
4
4
-32768 to 32767
0 to 65535
-128 to 127
0 to 255
-2147483648 to 2147483647
0 to 4294967295
float float 4 -3.4E-38 to 3.4E+38
double double
Long double
8
10
1.7E-308 to 1.7E+308
3.4E-4932 to 1.1E+4932
 20 *Under revision

 Lecture Note: 4
Constants

Constant is a any value that cannot be changed during program execution. In C,
any number, single character, or character string is known as a constant. A constant
is an entity that doesn’t change whereas a variable is an entity that may change.
For example, the number 50 represents a constant integer value. The character
string "Programming in C is fun.\n" is an example of a constant character string. C
constants can be divided into two major categories:
Primary Constants
Secondary Constants
These constants are further categorized as
 Numeric constant
 Character constant
 String constant
 21 *Under revision

Numeric constant: Numeric constant consists of digits. It required minimum size
of 2 bytes and max 4 bytes. It may be positive or negative but by default sign is
always positive. No comma or space is allowed within the numeric constant and it
must have at least 1 digit. The allowable range for integer constants is -32768 to
32767. Truly speaking the range of an Integer constant depends upon the compiler.
For a 16-bit compiler like Turbo C or Turbo C++ the range is -32768 to 32767.
For a 32-bit compiler the range would be even greater. Mean by a 16-bit or a 32-
bit compiler, what range of an Integer constant has to do with the type of compiler.
It is categorized a integer constant and real constant. An integer constants are
whole number which have no decimal point. Types of integer constants are:
 Decimal constant: 0-------9(base 10)
 Octal constant: 0-------7(base 8)
 Hexa decimal constant: 0----9, A------F(base 16)
 In decimal constant first digit should not be zero unlike octal constant first digit
must be zero(as 076, 0127) and in hexadecimal constant first two digit should be
0x/ 0X (such as 0x24, 0x87A). By default type of integer constant is integer but if
the value of integer constant is exceeds range then value represented by integer
type is taken to be unsigned integer or long integer. It can also be explicitly
mention integer and unsigned integer type by suffix l/L and u/U.
Real constant is also called floating point constant. To construct real constant we
must follow the rule of ,
 -real constant must have at least one digit.
 -It must have a decimal point.
 -It could be either positive or negative.
 -Default sign is positive.
 -No commas or blanks are allowed within a real constant. Ex.: +325.34
426.0
-32.76
To express small/large real constant exponent(scientific) form is used where
number is written in mantissa and exponent form separated by e/E. Exponent can
be positive or negative integer but mantissa can be real/integer type, for example
3.6*105=3.6e+5. By default type of floating point constant is double, it can also be
explicitly defined it by suffix of f/F.
Character constant
 22 *Under revision

Character constant represented as a single character enclosed within a single
quote. These can be single digit, single special symbol or white spaces such as
‘9’,’c’,’$’, ‘ ’ etc. Every character constant has a unique integer like value in
machine’s character code as if machine using ASCII (American standard code for
information interchange). Some numeric value associated with each upper and
lower case alphabets and decimal integers are as:
 A------------ Z ASCII value (65-90)
 a-------------z ASCII value (97-122)
 0-------------9 ASCII value (48-59)
 ; ASCII value (59)
 String constant
 Set of characters are called string and when sequence of characters are
enclosed within a double quote (it may be combination of all kind of symbols) is a
string constant. String constant has zero, one or more than one character and at the
end of the string null character(\0) is automatically placed by compiler. Some
examples are “,sarathina” , “908”, “3”,” ”, “A” etc. In C although same characters
are enclosed within single and double quotes it represents different meaning such
as “A” and ‘A’ are different because first one is string attached with null character
at the end but second one is character constant with its corresponding ASCII value
is 65.
Symbolic constant
Symbolic constant is a name that substitute for a sequence of characters and,
characters may be numeric, character or string constant. These constant are
generally defined at the beginning of the program as
 #define name value , here name generally written in
upper case for example
 23 *Under revision

 #define MAX 10
 #define CH ‘b’
 #define NAME “sony”


 Variables
Variable is a data name which is used to store some data value or symbolic names
for storing program
computations and results. The value of the variable can be change during the
execution. The rule for naming the variables is same as the naming identifier.
Before used in the program it must be declared. Declaration of variables specify its
name, data types and range of the value that variables can store depends upon its
data types.
Syntax:
 int a;
char c;
float f;
Variable initialization
 When we assign any initial value to variable during the declaration, is called
initialization of variables. When variable is declared but contain undefined value
then it is called garbage value. The variable is initialized with the assignment
operator such as
 Data type variable name=constant;
 Example: int a=20;
 Or int a;
 a=20;
 24 *Under revision

statements
 Lecture Note: 5
Expressions
An expression is a combination of variables, constants, operators and function call.
It can be arithmetic, logical and relational for example:-
 int z= x+y // arithmatic expression
 a&gt;b //relational
 a==b // logical
 func(a, b) // function call
Expressions consisting entirely of constant values are called constant expressions.
So, the expression
121 + 17 - 110
is a constant expression because each of the terms of the expression is a constant
value. But if i were declared to be an integer variable, the expression
180 + 2 - j
would not represent a constant expression.

Operator
This is a symbol use to perform some operation on variables, operands or with the
constant. Some operator required 2 operand to perform operation or Some
required single operation.
Several operators are there those are, arithmetic operator, assignment, increment ,
decrement, logical, conditional, comma, size of , bitwise and others.
 1. Arithmatic Operator
This operator used for numeric calculation. These are of either Unary arithmetic
operator, Binary arithmetic operator. Where Unary arithmetic operator required
 25 *Under revision

only one operand such as +,-, ++, --,!, tiled. And these operators are addition,
subtraction, multiplication, division. Binary arithmetic operator on other hand
required two operand and its operators are +(addition), -(subtraction),
*(multiplication), /(division), %(modulus). But modulus cannot applied with
floating point operand as well as there are no exponent operator in c.
Unary (+) and Unary (-) is different from addition and subtraction.
When both the operand are integer then it is called integer arithmetic and the result
is always integer. When both the operand are floating point then it is called floating
arithmetic and when operand is of integer and floating point then it is called mix
type or mixed mode arithmetic . And the result is in float type.
 2.Assignment Operator
A value can be stored in a variable with the use of assignment operator. The
assignment operator(=) is used in assignment statement and assignment expression.
Operand on the left hand side should be variable and the operand on the right hand
side should be variable or constant or any expression. When variable on the left
hand side is occur on the right hand side then we can avoid by writing the
compound statement. For example,
 int x= y;
 int Sum=x+y+z;
 3.Increment and Decrement
The Unary operator ++, --, is used as increment and decrement which acts upon
single operand. Increment operator increases the value of variable by one
.Similarly decrement operator decrease the value of the variable by one. And these
operator can only used with the variable, but cann't use with expression and
constant as ++6 or ++(x+y+z).
 26 *Under revision

It again categories into prefix post fix . In the prefix the value of the variable is
incremented 1st, then the new value is used, where as in postfix the operator is
written after the operand(such as m++,m--).
EXAMPLE
let y=12;
z= ++y;
y= y+1;
z= y;
Similarly in the postfix increment and decrement operator is used in the operation .
And then increment and decrement is perform.
EXAMPLE
let x= 5;
y= x++;
y=x;
x= x+1;

4.Relational Operator
It is use to compared value of two expressions depending on their relation.
Expression that contain relational operator is called relational expression.
Here the value is assign according to true or false value.
a.(a&gt;=b) || (b&gt;20)
b.(b&gt;a) &amp;&amp; (e&gt;b)
c. 0(b!=7)
 5. Conditional Operator
 27 *Under revision

It sometimes called as ternary operator. Since it required three expressions as
operand and it is represented as (? , :).
SYNTAX
exp1 ? exp2 :exp3
Here exp1 is first evaluated. It is true then value return will be exp2 . If false then
exp3.
EXAMPLE
void main()
{
 int a=10, b=2
 int s= (a&gt;b) ? a:b;
 printf(“value is:%d”);
 }
Output:
 Value is:10
 6. Comma Operator
Comma operator is use to permit different expression to be appear in a situation
where only one expression would be used. All the expression are separator by
comma and are evaluated from left to right.
EXAMPLE
int i, j, k, l;
for(i=1,j=2;i&lt;=5;j&lt;=10;i++;j++)
 28 *Under revision

 7. Sizeof Operator
Size of operator is a Unary operator, which gives size of operand in terms of byte
that occupied in the memory. An operand may be variable, constant or data type
qualifier.
Generally it is used make portable program(program that can be run on different
machine) . It determines the length of entities, arrays and structures when their size
are not known to the programmer. It is also use to allocate size of memory
dynamically during execution of the program.
EXAMPLE
main( )
{
int sum;
float f;
printf( "%d%d" ,size of(f), size of (sum) );
printf("%d%d", size of(235 L), size of(A));
}
 29 *Under revision

 Lecture Note: 6
8. Bitwise Operator
Bitwise operator permit programmer to access and manipulate of data at bit level.
Various bitwise operator enlisted are
 one's complement (~)
bitwise AND (&amp;)
bitwise OR (|)
 bitwise XOR (^)
left shift (&lt;&lt;)
right shift (&gt;&gt;)
These operator can operate on integer and character value but not on float and
double. In bitwise operator the function showbits( ) function is used to display the
binary representation of any integer or character value.
In one's complement all 0 changes to 1 and all 1 changes to 0. In the bitwise OR its
value would obtaining by 0 to 2 bits.
As the bitwise OR operator is used to set on a particular bit in a number. Bitwise
AND the logical AND.
It operate on 2operands and operands are compared on bit by bit basic. And hence
both the operands are of same type.
Logical or Boolean Operator
Operator used with one or more operand and return either value zero (for false) or
one (for true). The operand may be constant, variables or expressions. And the
expression that combines two or more expressions is termed as logical expression.
C has three logical operators :
 30 *Under revision

 Operator Meaning
 &amp;&amp; AND
 || OR
 ! NOT
Where logical NOT is a unary operator and other two are binary operator. Logical
AND gives result true if both the conditions are true, otherwise result is false. And
logial OR gives result false if both the condition false, otherwise result is true.
Precedence and associativity of operators
Operators Description Precedence level Associativity
() function call 1 left to right
[] array subscript

 arrow operator
. dot operator
---------------------------------------------------------------------------------------------------
+ unary plus 2 right to left
 - unary minus
++ increment
 - - decrement
! logical not
~ 1’s complement
* indirection
&amp; address
(data type) type cast
sizeof size in byte
 * multiplication 3 left to right
/ division
% modulus
----------------------------------------------------------------------------------------------------
+ addition 4 left to right
 31 *Under revision

 - subtraction
----------------------------------------------------------------------------------------------------
&lt;&lt; left shift 5 left to right
&gt;&gt; right shift
----------------------------------------------------------------------------------------------------
&lt;= less than equal to 6 left to right
&gt;= greater than equal to
&lt; less than
 &gt; greater than
----------------------------------------------------------------------------------------------------
== equal to 7 left to right
!= not equal to
----------------------------------------------------------------------------------------------------
&amp; bitwise AND 8 left to right
----------------------------------------------------------------------------------------------------
^ bitwise XOR 9 left to right
---------------------------------------------------------------------------------------------------
| bitwise OR 10 left to right
&amp;&amp; logical AND 11
|| logical OR 12
?: conditional operator 13
----------------------------------------------------------------------------------------------------
=, *=, /=, %= assignment operator 14 right to left
&amp;=, ^=, &lt;&lt;=
&gt;&gt;=
---------------------------------------------------------------------------------------------------
, comma operator 15
----------------------------------------------------------------------------------------------------
 Lecture Note: 7
 Control Statement
 Generally C program statement is executed in a order in which they appear
in the program. But sometimes we use decision making condition for execution
only a part of program, that is called control statement. Control statement defined
 32 *Under revision

how the control is transferred from one part to the other part of the program. There
are several control statement like if...else, switch, while, do....while, for loop,
break, continue, goto etc.
Loops in C
Loop:-it is a block of statement that performs set of instructions. In loops
Repeating particular portion of the program either a specified number of time or
until a particular no of condition is being satisfied.
There are three types of loops in c
1.While loop
2.do while loop
3.for loop
While loop
Syntax:-
while(condition)
{
Statement 1;
Statement 2;
}
Or while(test condition)
Statement;
 33 *Under revision

The test condition may be any expression .when we want to do something a fixed
no of times but not known about the number of iteration, in a program then while
loop is used.
Here first condition is checked if, it is true body of the loop is executed else, If
condition is false control will be come out of loop.
Example:-
/* wap to print 5 times welcome to C” */
#include&lt;stdio.h&gt;
void main()
{
int p=1;
While(p&lt;=5)
{
printf(“Welcome to C\n”);
P=p+1;
}
}
Output: Welcome to C
 Welcome to C
 Welcome to C
 Welcome to C
 Welcome to C
 34 *Under revision

So as long as condition remains true statements within the body of while loop will
get executed repeatedly.
do while loop
This (do while loop) statement is also used for looping. The body of this loop may
contain single statement or block of statement. The syntax for writing this
statement is:
Syntax:-
Do
{
Statement;
}
while(condition);
Example:-
#include&lt;stdio.h&gt;
void main()
{
int X=4;
 do
{
 Printf(“%d”,X);
X=X+1;
 35 *Under revision

 }whie(X&lt;=10);
 Printf(“ ”);
}
Output: 4 5 6 7 8 9 10
 Here firstly statement inside body is executed then condition is checked. If the
condition is true again body of loop is executed and this process continue until the
condition becomes false. Unlike while loop semicolon is placed at the end of
while.
 There is minor difference between while and do while loop, while loop test the
condition before executing any of the statement of loop. Whereas do while loop
test condition after having executed the statement at least one within the loop.
If initial condition is false while loop would not executed it’s statement on other
hand do while loop executed it’s statement at least once even If condition fails for
first time. It means do while loop always executes at least once. Notes:
Do while loop used rarely when we want to execute a loop at least once.
 Lecture Note: 8
for loop
 In a program, for loop is generally used when number of iteration are known in
advance. The body of the loop can be single statement or multiple statements. Its
syntax for writing is:
Syntax:-
 36 *Under revision

for(exp1;exp2;exp3)
{
Statement;
}
Or
for(initialized counter; test counter; update counter)
{
Statement;
}
Here exp1 is an initialization expression, exp2 is test expression or condition and
exp3 is an update expression. Expression 1 is executed only once when loop
started and used to initialize the loop variables. Condition expression generally
uses relational and logical operators. And updation part executed only when after
body of the loop is executed.
Example:-
void main()
{
int i;
for(i=1;i&lt;10;i++)
{
 37 *Under revision

 Printf(“ %d ”, i);
 }
}
Output:-1 2 3 4 5 6 7 8 9
Nesting of loop
When a loop written inside the body of another loop then, it is known as nesting of
loop. Any type of loop can be nested in any type such as while, do while, for. For
example nesting of for loop can be represented as :
void main()
{
int i,j;
for(i=0;i&lt;2;i++)
 for(j=0;j&lt;5; j++)
printf(“%d %d”, i, j);
 }
Output: i=0
 j=0 1 2 3 4
 i=1
 j=0 1 2 3 4
 38 *Under revision

Break statement(break)
 Sometimes it becomes necessary to come out of the loop even before loop
condition becomes false then break statement is used. Break statement is used
inside loop and switch statements. It cause immediate exit from that loop in which
it appears and it is generally written with condition. It is written with the keyword
as break. When break statement is encountered loop is terminated and control is
transferred to the statement, immediately after loop or situation where we want to
jump out of the loop instantly without waiting to get back to conditional state.
When break is encountered inside any loop, control automatically passes to the
first statement after the loop. This break statement is usually associated with if
statement.
Example :
void main()
{
int j=0;
for(;j&lt;6;j++)
if(j==4)
break;
}
Output:
0 1 2 3

Continue statement (key word continue)
 39 *Under revision

Continue statement is used for continuing next iteration of loop after skipping
some statement of loop. When it encountered control automatically passes
through the beginning of the loop. It is usually associated with the if statement. It is
useful when we want to continue the program without executing any part of the
program.
The difference between break and continue is, when the break encountered loop is
terminated and it transfer to the next statement and when continue is encounter
control come back to the beginning position.
In while and do while loop after continue statement control transfer to the test
condition and then loop continue where as in, for loop after continue control
transferred to the updating expression and condition is tested.
Example:-
void main()
{
int n;
for(n=2; n&lt;=9; n++)
{
if(n==4)
continue;
printf(“%d”, n);
 }
}
Printf(“out of loop”);
}
Output: 2 3 5 6 7 8 9 out of loop
 40 *Under revision

 Lecture Note: 9
if statement
Statement execute set of command like when condition is true and its syntax is
 If (condition)
 Statement;
The statement is executed only when condition is true. If the if statement body is
consists of several statement then better to use pair of curly braces. Here in case
condition is false then compiler skip the line within the if block.
void main()
{
 int n;
 printf (“ enter a number:”);
 scanf(“%d”,&amp;n);
 If (n&gt;10)
 Printf(“ number is grater”);
 }
Output:
 Enter a number:12
 Number is greater
 41 *Under revision

if…..else ... Statement
it is bidirectional conditional control statement that contains one condition &amp; two
possible action. Condition may be true or false, where non-zero value regarded as
true &amp; zero value regarded as false. If condition are satisfy true, then a single or
block of statement executed otherwise another single or block of statement is
executed.
Its syntax is:-
 if (condition)
{
Statement1;
 Statement2;
}
 else
 {
 Statement1;
 Statement2;
 }
Else statement cannot be used without if or no multiple else statement are allowed
within one if statement. It means there must be a if statement with in an else
statement.
Example:-
/* To check a number is eve or odd */
 42 *Under revision

 void main()
{
 int n;
 printf (“enter a number:”);
 sacnf (“%d”, &amp;n);
 If (n%2==0)
 printf (“even number”);
else
 printf(“odd number”);
}
Output: enter a number:121
odd number
 Lecture Note: 10
Nesting of if …else
When there are another if else statement in if-block or else-block, then it is called
nesting of if-else statement.
Syntax is :-
 if (condition)
 {
 43 *Under revision

 If (condition)
 Statement1;
 else
 statement2;
 }
 Statement3;
If….else LADDER
In this type of nesting there is an if else statement in every else part except the last
part. If condition is false control pass to block where condition is again checked
with its if statement.
Syntax is :-
 if (condition)
 Statement1;
 else if (condition)
 statement2;
 else if (condition)
 statement3;
 else
 statement4;
This process continue until there is no if statement in the last block. if one of the
condition is satisfy the condition other nested “else if” would not executed.
 44 *Under revision

But it has disadvantage over if else statement that, in if else statement whenever
the condition is true, other condition are not checked. While in this case, all
condition are checked.
 Lecture Note: 11
 ARRAY
Array is the collection of similar data types or collection of similar entity stored in
contiguous memory location. Array of character is a string. Each data item of an
array is called an element. And each element is unique and located in separated
memory location. Each of elements of an array share a variable but each element
having different index no. known as subscript.
An array can be a single dimensional or multi-dimensional and number of
subscripts determines its dimension. And number of subscript is always starts with
zero. One dimensional array is known as vector and two dimensional arrays are
known as matrix.
ADVANTAGES: array variable can store more than one value at a time where
other variable can store one value at a time.
Example:
 int arr[100];
 45 *Under revision

 int mark[100];
 DECLARATION OF AN ARRAY :
 Its syntax is :
 Data type array name [size];
 int arr[100];
 int mark[100];
int a[5]={10,20,30,100,5}
The declaration of an array tells the compiler that, the data type, name of the array,
size of the array and for each element it occupies memory space. Like for int data
type, it occupies 2 bytes for each element and for float it occupies 4 byte for each
element etc. The size of the array operates the number of elements that can be
stored in an array and it may be a int constant or constant int expression.
We can represent individual array as :
 int ar[5];
 ar[0], ar[1], ar[2], ar[3], ar[4];
Symbolic constant can also be used to specify the size of the array as:
 #define SIZE 10;
INITIALIZATION OF AN ARRAY:
After declaration element of local array has garbage value. If it is global or static
array then it will be automatically initialize with zero. An explicitly it can be
initialize that
 Data type array name [size] = {value1, value2, value3…}
Example:
 in ar[5]={20,60,90, 100,120}
 46 *Under revision

Array subscript always start from zero which is known as lower bound and upper
value is known as upper bound and the last subscript value is one less than the size
of array. Subscript can be an expression i.e. integer value. It can be any integer,
integer constant, integer variable, integer expression or return value from
functional call that yield integer value.
So if i &amp; j are not variable then the valid subscript are
 ar [i*7],ar[i*i],ar[i++],ar[3];
 The array elements are standing in continuous memory locations and the
amount of storage required for hold the element depend in its size &amp; type.
Total size in byte for 1D array is:
 Total bytes=size of (data type) * size of array.
 Example : if an array declared is:
 int [20];
 Total byte= 2 * 20 =40 byte.
ACCESSING OF ARRAY ELEMENT:
/*Write a program to input values into an array and display them*/
#include&lt;stdio.h&gt;
int main()
{
int arr[5],i;
for(i=0;i&lt;5;i++)
{
printf(“enter a value for arr[%d] \n”,i);
scanf(“%d”,&amp;arr[i]);
}
 47 *Under revision

printf(“the array elements are: \n”);
for (i=0;i&lt;5;i++)
{
printf(“%d\t”,arr[i]);
}
return 0;
}
OUTPUT:
Enter a value for arr[0] = 12
Enter a value for arr[1] =45
Enter a value for arr[2] =59
Enter a value for arr[3] =98
Enter a value for arr[4] =21
The array elements are 12 45 59 98 21
Example: From the above example value stored in an array are and occupy its
memory addresses 2000, 2002, 2004, 2006, 2008 respectively.
 a[0]=12, a[1]=45, a[2]=59, a[3]=98, a[4]=21
 ar[0] ar[1] ar[2] ar[3] ar[4]
12 45 59 98 21
 2000 2002 2004 2006 2008
Example 2:
 48 *Under revision

 /* Write a program to add 10 array elements */
 #include&lt;stdio.h&gt;
 void main()
{
 int i ;
int arr [10];
int sum=o;
for (i=0; i&lt;=9; i++)
{
printf (“enter the %d element \n”, i+1);
scanf (“%d”, &amp;arr[i]);
}
for (i=0; i&lt;=9; i++)
{
sum = sum + a[i];
}
printf (“the sum of 10 array elements is %d”, sum);
}
OUTPUT:
Enter a value for arr[0] =5
Enter a value for arr[1] =10
Enter a value for arr[2] =15
Enter a value for arr[3] =20
 49 *Under revision

Enter a value for arr[4] =25
Enter a value for arr[5] =30
Enter a value for arr[6] =35
Enter a value for arr[7] =40
Enter a value for arr[8] =45
Enter a value for arr[9] =50
Sum = 275
 while initializing a single dimensional array, it is optional to specify the size of
array. If the size is omitted during initialization then the compiler assumes the size
of array equal to the number of initializers.
For example:-
 int marks[]={99,78,50,45,67,89};
If during the initialization of the number the initializers is less then size of array,
then all the remaining elements of array are assigned value zero .
For example:-
 int marks[5]={99,78};
Here the size of the array is 5 while there are only two initializers so After this
initialization, the value of the rest elements are automatically occupied by zeros
such as
Marks[0]=99 , Marks[1]=78 , Marks[2]=0, Marks[3]=0, Marks[4]=0
Again if we initialize an array like
int array[100]={0};
Then the all the element of the array will be initialized to zero. If the number of
initializers is more than the size given in brackets then the compiler will show an
error.
 50 *Under revision

For example:-
 int arr[5]={1,2,3,4,5,6,7,8};//error
we cannot copy all the elements of an array to another array by simply assigning it
to the other array like, by initializing or declaring as
 int a[5] ={1,2,3,4,5};
 int b[5];
 b=a;//not valid
(note:-here we will have to copy all the elements of array one by one, using for
loop.)
Single dimensional arrays and functions
/*program to pass array elements to a function*/
#include&lt;stdio.h&gt;
void main()
{
int arr[10],i;
printf(“enter the array elements\n”);
for(i=0;i&lt;10;i++)
{
scanf(“%d”,&amp;arr[i]);
check(arr[i]);
}
}
 51 *Under revision

void check(int num)
{
if(num%2=0)
{
printf(”%d is even \n”,num);
}
else
{
printf(”%d is odd \n”,num);
}
}
 Lecture Note: 12
Two dimensional arrays
Two dimensional array is known as matrix. The array declaration in both the array
i.e.in single dimensional array single subscript is used and in two dimensional
array two subscripts are is used.
Its syntax is
Data-type array name[row][column];
Or we can say 2-d array is a collection of 1-D array placed one below the other.
 52 *Under revision

Total no. of elements in 2-D array is calculated as row*column
Example:-
 int a[2][3];
 Total no of elements=row*column is 2*3 =6
It means the matrix consist of 2 rows and 3 columns
For example:-
 20 2 7
8 3 15
Positions of 2-D array elements in an array are as below
00 01 02
10 11 12
a [0][0] a [0][0] a [0][0] a [0][0] a [0][0] a [0][0]
20 2 7 8 3 15
 2000 2002 2004 2006 2008
Accessing 2-d array /processing 2-d arrays
For processing 2-d array, we use two nested for loops. The outer for loop
corresponds to the row and the inner for loop corresponds to the column.
For example
int a[4][5];
for reading value:-
 53 *Under revision

for(i=0;i&lt;4;i++)
{
for(j=0;j&lt;5;j++)
{
scanf(“%d”,&amp;a[i][j]);
}
}
For displaying value:-
for(i=0;i&lt;4;i++)
{
for(j=0;j&lt;5;j++)
{
printf(“%d”,a[i][j]);
}
}
Initialization of 2-d array:
2-D array can be initialized in a way similar to that of 1-D array. for example:-
int mat[4][3]={11,12,13,14,15,16,17,18,19,20,21,22};
These values are assigned to the elements row wise, so the values of
elements after this initialization are
Mat[0][0]=11, Mat[1][0]=14, Mat[2][0]=17 Mat[3][0]=20
Mat[0][1]=12, Mat[1][1]=15, Mat[2][1]=18 Mat[3][1]=21
Mat[0][2]=13, Mat[1][2]=16, Mat[2][2]=19 Mat[3][2]=22
 54 *Under revision

While initializing we can group the elements row wise using inner braces.
for example:-
 int mat[4][3]={{11,12,13},{14,15,16},{17,18,19},{20,21,22}};
And while initializing , it is necessary to mention the 2nd dimension where 1st
dimension is optional.
int mat[][3];
int mat[2][3];
int mat[][];
int mat[2][]; invalid
If we initialize an array as
 int mat[4][3]={{11},{12,13},{14,15,16},{17}};
Then the compiler will assume its all rest value as 0,which are not defined.
Mat[0][0]=11, Mat[1][0]=12, Mat[2][0]=14, Mat[3][0]=17
Mat[0][1]=0, Mat[1][1]=13, Mat[2][1]=15 Mat[3][1]=0
Mat[0][2]=0, Mat[1][2]=0, Mat[2][2]=16, Mat[3][2]=0
In memory map whether it is 1-D or 2-D, elements are stored in one
contiguous manner.
We can also give the size of the 2-D array by using symbolic constant
Such as
 #define ROW 2;
 55 *Under revision

 #define COLUMN 3;
 int mat[ROW][COLUMN];
String
Array of character is called a string. It is always terminated by the NULL
character. String is a one dimensional array of character.
We can initialize the string as
char name[]={‘j’,’o’,’h’,’n’,’\o’};
Here each character occupies 1 byte of memory and last character is always NULL
character. Where ’\o’ and 0 (zero) are not same, where ASCII value of ‘\o’ is 0
and ASCII value of 0 is 48. Array elements of character array are also stored in
contiguous memory allocation.
From the above we can represent as;
 J o h N ‘\o’
The terminating NULL is important because it is only the way that the
function that work with string can know, where string end.
String can also be initialized as;
char name[]=”John”;
Here the NULL character is not necessary and the compiler will assume it
automatically.
String constant (string literal)
 56 *Under revision

A string constant is a set of character that enclosed within the double quotes
and is also called a literal. Whenever a string constant is written anywhere in a
program it is stored somewhere in a memory as an array of characters terminated
by a NULL character (‘\o’).
Example - “m”
 “Tajmahal”
 “My age is %d and height is %f\n”
The string constant itself becomes a pointer to the first character in array.
Example-char crr[20]=”Taj mahal”;
 It is called base address.

 Lecture Note: 13
String library function
There are several string library functions used to manipulate string and the
prototypes for these functions are in header file “string.h”. Several string functions
are
strlen()
This function return the length of the string. i.e. the number of characters in the
string excluding the terminating NULL character.
It accepts a single argument which is pointer to the first character of the string.
 57 *Under revision

1000 1001 1002 1003 1004 1005 1006 1007 100 1009
 T a j M A H a l \o
For examplestrlen(“suresh”);
It return the value 6.
In array version to calculate legnth:-
int str(char str[])
{
int i=0;
while(str[i]!=’\o’)
{
i++;
}
return i;
}
Example:-
#include&lt;stdio.h&gt;
 #include&lt;string.h&gt;
void main()
{
char str[50];
print(”Enter a string:”);
 58 *Under revision

gets(str);
printf(“Length of the string is %d\n”,strlen(str));
}
Output:
Enter a string: C in Depth
Length of the string is 8
strcmp()
This function is used to compare two strings. If the two string match, strcmp()
return a value 0 otherwise it return a non-zero value. It compare the strings
character by character and the comparison stops when the end of the string is
reached or the corresponding characters in the two string are not same.
strcmp(s1,s2)
return a value:
&lt;0 when s1&lt;s2
=0 when s1=s2
&gt;0 when s1&gt;s2
The exact value returned in case of dissimilar strings is not defined. We only know
that if s1&lt;s2 then a negative value will be returned and if s1&gt;s2 then a positive
value will be returned.
For example:
 59 *Under revision

/*String comparison…………………….*/
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
void main()
{
char str1[10],str2[10];
printf(“Enter two strings:”);
gets(str1);
gets(str2);
if(strcmp(str1,str2)==0)
{
printf(“String are same\n”);
}
else
{
printf(“String are not same\n”);
}
}
strcpy()
 60 *Under revision

This function is used to copying one string to another string. The function
strcpy(str1,str2) copies str2 to str1 including the NULL character. Here str2 is the
source string and str1 is the destination string.
The old content of the destination string str1 are lost. The function returns a pointer
to destination string str1.
Example:-
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
void main()
{
char str1[10],str2[10];
printf(“Enter a string:”);
scanf(“%s”,str2);
strcpy(str1,str2);
printf(“First string:%s\t\tSecond string:%s\n”,str1,str2);
strcpy(str,”Delhi”);
strcpy(str2,”Bangalore”);
printf(“First string :%s\t\tSecond string:%s”,str1,str2);
strcat()
 61 *Under revision

This function is used to append a copy of a string at the end of the other string. If
the first string is “”Purva” and second string is “Belmont” then after using this
function the string becomes “PusvaBelmont”. The NULL character from str1 is
moved and str2 is added at the end of str1. The 2nd string str2 remains unaffected.
A pointer to the first string str1 is returned by the function.
Example:-
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
void main()
{
char str1[20],str[20];
printf(“Enter two strings:”);
gets(str1);
gets(str2);
strcat(str1,str2);
printf(“First string:%s\t second string:%s\n”,str1,str2);
strcat(str1,”-one”);
printf(“Now first string is %s\n”,str1);
}
Output
Enter two strings: data
Base
 62 *Under revision

First string: database second string: database
` Now first string is: database-one

 Lecture Note: 14
 FUNCTION
A function is a self contained block of codes or sub programs with a set of
statements that perform some specific task or coherent task when it is called.
It is something like to hiring a person to do some specific task like, every six
months servicing a bike and hand over to it.
Any ‘C’ program contain at least one function i.e main().
There are basically two types of function those are
 1. Library function
 2. User defined function
The user defined functions defined by the user according to its requirement
System defined function can’t be modified, it can only read and can be used.
These function are supplied with every C compiler
Source of these library function are pre complied and only object code get used by
the user by linking to the code by linker
Here in system defined function description:
 Function definition : predefined, precompiled, stored in the library
 63 *Under revision

 Function declaration : In header file with or function prototype.
 Function call : By the programmer
User defined function
Syntax:-
 Return type name of function (type 1 arg 1, type2 arg2, type3 arg3)
 Return type function name argument list of the above syntax
So when user gets his own function three thing he has to know, these are.
Function declaration
Function definition
Function call
These three things are represented like
 int function(int, int, int); /*function declaration*/
 main() /* calling function*/
 {
 function(arg1,arg2,arg3);
 }
 int function(type 1 arg 1,type2 arg2,type3, arg3) /*function definition/*
 {
 Local variable declaration;
 Statement;
 Return value;
 }
 64 *Under revision

Function declaration:-
 Function declaration is also known as function prototype. It inform the compiler
about three thing, those are name of the function, number and type of argument
received by the function and the type of value returned by the function.
While declaring the name of the argument is optional and the function prototype
always terminated by the semicolon.
Function definition:-
Function definition consists of the whole description and code of the function.
It tells about what function is doing what are its inputs and what are its out put
It consists of two parts function header and function body
Syntax:-
 return type function(type 1 arg1, type2 arg2, type3 arg3) /*function header*/
 {
 Local variable declaration;
 Statement 1;
 Statement 2;
 Return value
 }
The return type denotes the type of the value that function will return and it is
optional and if it is omitted, it is assumed to be int by default. The body of the
function is the compound statements or block which consists of local variable
declaration statement and optional return statement.
 65 *Under revision

The local variable declared inside a function is local to that function only. It can’t
be used anywhere in the program and its existence is only within this function.
The arguments of the function definition are known as formal arguments.
Function Call
When the function get called by the calling function then that is called, function
call. The compiler execute these functions when the semicolon is followed by the
function name.
Example:-
 function(arg1,arg2,arg3);
The argument that are used inside the function call are called actual argument
Ex:-
 int S=sum(a, b); //actual arguments
Actual argument
The arguments which are mentioned or used inside the function call is knows as
actual argument and these are the original values and copy of these are actually
sent to the called function
It can be written as constant, expression or any function call like
 Function (x);
 Function (20, 30);
 Function (a*b, c*d);
 Function(2,3,sum(a, b));
Formal Arguments
The arguments which are mentioned in function definition are called formal
arguments or dummy arguments.
 66 *Under revision

These arguments are used to just hold the copied of the values that are sent by the
calling function through the function call.
These arguments are like other local variables which are created when the function
call starts and destroyed when the function ends.
The basic difference between the formal argument and the actual argument are
 1) The formal argument are declared inside the parenthesis where as the
local variable declared at the beginning of the function block.
2). The formal argument are automatically initialized when the copy of actual
arguments are passed while other local variable are assigned values through the
statements.
Order number and type of actual arguments in the function call should be match
with the order number and type of the formal arguments.
Return type
It is used to return value to the calling function. It can be used in two way as
 return
 Or return(expression);
 Ex:- return (a);
 return (a*b);
 return (a*b+c);
Here the 1st return statement used to terminate the function without returning any
value
Ex:- /*summation of two values*/
 int sum (int a1, int a2);
 main()
 67 *Under revision

 {
 int a,b;
 printf(“enter two no”);
 scanf(“%d%d”,&amp;a,&amp;b);
 int S=sum(a,b);
 printf(“summation is = %d”,s);
 }
 int sum(intx1,int y1)
 {
 int z=x1+y1;
 Return z;
 }
Advantage of function
By using function large and difficult program can be divided in to sub programs
and solved. When we want to perform some task repeatedly or some code is to be
used more than once at different place in the program, then function avoids this
repeatition or rewritten over and over.
Due to reducing size, modular function it is easy to modify and test
Notes:-
C program is a collection of one or more function.
A function is get called when function is followed by the semicolon.
A function is defined when a function name followed by a pair of curly braces
 68 *Under revision

Any function can be called by another function even main() can be called by other
function.
main()
{
function1()
}
function1()
{
Statement;
function2;
}
function 2()
{
}
So every function in a program must be called directly or indirectly by the main()
function. A function can be called any number of times.
A function can call itself again and again and this process is called recursion.
A function can be called from other function but a function can’t be defined in
another function
 Lecture Note: 15
 Category of Function based on argument and return type
 i) Function with no argument &amp; no return value
 69 *Under revision

 Function that have no argument and no return value is written as:-
 void function(void);
 main()
 {
 void function()
 {
 Statement;
 }
 Example:-
 void me();
 main()
 {
 me();
 printf(“in main”);
 }
 void me()
 {
 printf(“come on”);
 }
Output: come on
 inn main
 70 *Under revision

ii) Function with no argument but return value
 Syntax:-
 int fun(void);
 main()
 {
 int r;
 r=fun();
 }
 int fun()
 {
 reurn(exp);
 }
 Example:-
 int sum();
 main()
 {
 int b=sum();
 printf(“entered %d\n, b”);
 }
 int sum()
 {
 int a,b,s;
 71 *Under revision

 s=a+b;
 return s;
 }
Here called function is independent and are initialized. The values aren’t passed by
the calling function .Here the calling function and called function are
communicated partly with each other.
 Lecture Note: 16
iii ) function with argument but no return value
Here the function have argument so the calling function send data to the called
function but called function dose n’t return value.
 Syntax:-
 void fun (int,int);
 main()
 {
 int (a,b);
 }
 void fun(int x, int y);
 {
 Statement;
 }
 72 *Under revision

Here the result obtained by the called function.
 iv) function with argument and return value
Here the calling function has the argument to pass to the called function and the
called function returned value to the calling function.
 Syntax:-
 fun(int,int);
 main()
 {
 int r=fun(a,b);
 }
 int fun(intx,inty)
 {
 return(exp);
 }
 Example:
 main()
 {
 int fun(int);
 int a,num;
 printf(“enter value:\n”);
 scanf(“%d”,&amp;a)
 73 *Under revision

 int num=fun(a);
 }
 int fun(int x)
 {
 ++x;
 return x;
 }

Call by value and call by reference
There are two way through which we can pass the arguments to the function such
as call by value and call by reference.
1. Call by value
In the call by value copy of the actual argument is passed to the formal argument
and the operation is done on formal argument.
When the function is called by ‘call by value’ method, it doesn’t affect content of
the actual argument.
Changes made to formal argument are local to block of called function so when the
control back to calling function the changes made is vanish.
 Example:-
 main()
 {
 int x,y;
 change(int,int);
 74 *Under revision

 printf(“enter two values:\n”);
 scanf(“%d%d”,&amp;x,&amp;y);
 change(x ,y);
printf(“value of x=%d and y=%d\n”,x ,y);
 }
change(int a,int b);
 {
int k;
k=a;
a=b;
b=k;
 }
Output: enter two values: 12
 23
Value of x=12 and y=23
2. Call by reference
Instead of passing the value of variable, address or reference is passed and the
function operate on address of the variable rather than value.
Here formal argument is alter to the actual argument, it means formal arguments
calls the actual arguments.
Example:-
void main()
 75 *Under revision

{
int a,b;
change(int *,int*);
printf(“enter two values:\n”);
scanf(“%d%d”,&amp;a,&amp;b);
change(&amp;a,&amp;b);
printf(“after changing two value of a=%d and b=%d\n:”a,b);
}
change(int *a, int *b)
 {
int k;
 k=*a;
*a=*b;
 *b= k;
printf(“value in this function a=%d and b=%d\n”,*a,*b);
}
Output: enter two values: 12
32
Value in this function a=32 and b=12
After changing two value of a=32 and b=12
So here instead of passing value of the variable, directly passing address of the
variables. Formal argument directly access the value and swapping is possible even
after calling a function.
 76 *Under revision

 Lecture Note: 17
Local, Global and Static variable
Local variable:-
 variables that are defined with in a body of function or block. The local
variables can be used only in that function or block in which they are declared.
Same variables may be used in different functions such as
function()
{
 int a,b;
function 1();
}
function2 ()
{
int a=0;
b=20;
}
Global variable:-
 77 *Under revision

the variables that are defined outside of the function is called global variable. All
functions in the program can access and modify global variables. Global variables
are automatically initialized at the time of initialization.
Example:
#include&lt;stdio.h&gt;
void function(void);
void function1(void);
void function2(void);
int a, b=20;
void main()
{
printf(“inside main a=%d,b=%d \n”,a,b);
function();
function1();
function2();
}
 function()
{
Prinf(“inside function a=%d,b=%d\n”,a,b);
}
function 1()
{
 78 *Under revision

prinf(“inside function a=%d,b=%d\n”,a,b);
}
function 2()
{
prinf(“inside function a=%d,b=%d\n”,a,);
}
Static variables: static variables are declared by writing the key word static.
-syntax:-
static data type variable name;
static int a;
-the static variables initialized only once and it retain between the function call. If
its variable is not initialized, then it is automatically initialized to zero.
Example:
void fun1(void);
void fun2(void);
void main()
{
fun1();
fun2();
}
void fun1()
{
 79 *Under revision

int a=10, static int b=2;
printf(“a=%d, b=%d”,a,b);
a++;
b++;
}
 Output:a= 10 b= 2
 a=10 b= 3
 Recursion
 When function calls itself (inside function body) again and again then it is
called as recursive function. In recursion calling function and called function are
same. It is powerful technique of writing complicated algorithm in easiest way.
According to recursion problem is defined in term of itself. Here statement with in
body of the function calls the same function and same times it is called as circular
definition. In other words recursion is the process of defining something in form of
itself.
 Syntax:
main ()
{
rec(); /*function call*/
rec();
rec();
Ex:- /*calculate factorial of a no.using recursion*/
int fact(int);
void main()
 80 *Under revision

{
int num;
printf(“enter a number”);
scanf(“%d”,&amp;num);
f=fact(num);
printf(“factorial is =%d\n”f);
}
fact (int num)
{
If (num==0||num==1)
return 1;
else
return(num*fact(num-1));
}
 Lecture Note: 18
Monolithic Programming
The program which contains a single function for the large program is called
monolithic program. In monolithic program not divided the program, it is huge
long pieces of code that jump back and forth doing all the tasks like single thread
of execution, the program requires. Problem arise in monolithic program is that,
when the program size increases it leads inconvenience and difficult to maintain
 81 *Under revision

such as testing, debugging etc. Many disadvantages of monolithic programming
are:
 1. Difficult to check error on large programs size.
 2. Difficult to maintain because of huge size.
 3. Code can be specific to a particular problem. i.e. it cannot be reused.
 Many early languages (FORTRAN, COBOL, BASIC, C) required one huge
workspace with labelled areas that may does specific tasks but are not isolated.
Modular Programming
The process of subdividing a computer program into separate sub-programs such
as functions and subroutines is called Modular programming. Modular
programming sometimes also called as structured programming. It
enables multiple programmers to divide up the large program and debug
pieces of program independently and tested.
. Then the linker will link all these modules to form the complete program. This
principle dividing software up into parts, or modules, where a module can be
changed, replaced, or removed, with minimal effect on the other software it works
with. Segmenting the program into modules clearly defined functions, it can
determine the source of program errors more easily. Breaking down program
functions into modules, where each of which accomplishes one function and
contains all the source code and variables needed to accomplish that function.
Modular program is the solution to the problem of very large program that are
difficult to debug, test and maintain. A program module may be rewritten while its
inputs and outputs remain the same. The person making a change may only
understand a small portion of the original program.
Object-oriented programming (OOP) is compatible with the modular programming
concept to a large extent.
. , Less code has to be written that makes shorter.
 82 *Under revision

• A single procedure can be developed for reuse, eliminating the need to
retype the code many times.
• Programs can be designed more easily because a small team deals with only
a small part of the entire code.
• Modular programming allows many programmers to collaborate on the same
application.
• The code is stored across multiple files.
• Code is short, simple and easy to understand and modify, make simple to
figure out how the program is operate and reduce likely hood of bugs.
• Errors can easily be identified, as they are localized to a subroutine or
function or isolated to specific module.
• The same code can be reused in many applications.
• The scoping of variables and functions can easily be controlled.
Disadvantages
However it may takes longer to develop the program using this technique.
Storage Classes
Storage class in c language is a specifier which tells the compiler where and how to
store variables, its initial value and scope of the variables in a program. Or
attributes of variable is known as storage class or in compiler point of view a
variable identify some physical location within a computer where its string of bits
value can be stored is known as storage class.
The kind of location in the computer, where value can be stored is either in the
memory or in the register. There are various storage class which determined, in
which of the two location value would be stored.
Syntax of declaring storage classes is:-
 storageclass datatype variable name;
There are four types of storage classes and all are keywords:-
1 ) Automatic (auto)
 83 *Under revision

2 ) Register (register)
3) Static (static)
4 ) External (extern)
 Examples:-
 auto float x; or float x;
 extern int x;
 register char c;
 static int y;
Compiler assume different storage class based on:-
1 ) Storage class:- tells us about storage place(where variable would be stored).
2) Intial value :-what would be the initial value of the variable.
If initial value not assigned, then what value taken by uninitialized variable.
 3) Scope of the variable:-what would be the value of the variable of the program.
 4) Life time :- It is the time between the creation and distribution of a variable
or how long would variable exists.
1. Automatic storage class
The keyword used to declare automatic storage class is auto.
Its features:-
Storage-memory location
Default initial value:-unpredictable value or garbage value.
 84 *Under revision

Scope:-local to the block or function in which variable is defined.
Life time:-Till the control remains within function or block in which it is defined.
It terminates when function is released.
The variable without any storage class specifier is called automatic variable.
Example:-
main( )
{
auto int i;
printf(“i=”,i);
}
 Lecture Note: 19
 2. Register storage class
The keyword used to declare this storage class is register.
The features are:-
Storage:-CPU register.
Default initial value :-garbage value
Scope :-local to the function or block in which it is defined.
Life time :-till controls remains within function or blocks in which it is defined.
Register variable don’t have memory address so we can’t apply address operator
on it. CPU register generally of 16 bits or 2 bytes. So we can apply storage classes
only for integers, characters, pointer type.
 85 *Under revision

Variable stored in register storage class always access faster than,which is always
stored in the memory. But to store all variable in the CPU register is not possible
because of limitation of the register pair.
And when variable is used at many places like loop counter, then it is better to
declare it as register class.
Example:-
main( )
{
register int i;
for(i=1;i&lt;=12;i++)
printf(“%d”,i);
}

 3 Static storage class
The keyword used to declare static storage class is static.
Its feature are:-
Storage:-memory location
Default initial value:- zero
Scope :- local to the block or function in which it is defined.
Life time:- value of the variable persist or remain between different function call.
Example:-
main( )
 86 *Under revision

{
reduce( );
reduce( );
reduce ( );
}
reduce( )
{
static int x=10;
printf(“%d”,x);
x++;
}
Output:-10,11,12
External storage classes
The keyword used for this class is extern.
Features are:-
Storage:- memory area
Default initial value:-zero
Scope :- global
Life time:-as long as program execution remains it retains.
 87 *Under revision

Declaration does not create variables, only it refer that already been created at
somewhere else. So, memory is not allocated at a time of declaration and the
external variables are declared at outside of all the function.
 Example:-
 int i,j;
 void main( )
 {
 printf( “i=%d”,i );
 receive( );
 receive ( );
 reduce( );
 reduce( );
 }
 receive( )
 {
 i=i+2;
 printf(“on increase i=%d”,i);
 }
 reduce( )
 {
 i=i-1;
 printf(“on reduce i=%d”,i);
 }
 88 *Under revision

 Output:-i=0,2,4,3,2.
When there is large program i.e divided into several files, then external variable
should be preferred. External variable extend the scope of variable.

 Lecture Note: 20

POINTER
A pointer is a variable that store memory address or that contains address of
another variable where addresses are the location number always contains whole
number. So, pointer contain always the whole number. It is called pointer because
it points to a particular location in memory by storing address of that location.
 Syntax-
 Data type *pointer name;
Here * before pointer indicate the compiler that variable declared as a pointer.
e.g.
 int *p1; //pointer to integer type
 float *p2; //pointer to float type
 char *p3; //pointer to character type
When pointer declared, it contains garbage value i.e. it may point any value in the
memory.
 89 *Under revision

Two operators are used in the pointer i.e. address operator(&amp;) and indirection
operator or dereference operator (*).
Indirection operator gives the values stored at a particular address.
Address operator cannot be used in any constant or any expression.
Example:
 void main()
 {
 int i=105;
 int *p;
 p=&amp;i;
t
printf(“value of i=%d”,*p);
printf(“value of i=%d”,*/&amp;i);
printf(“address of i=%d”,&amp;i);
printf(“address of i=%d”,p);
printf(“address of p=%u”,&amp;p);
}
Pointer Expression
Pointer assignment
int i=10;
int *p=&amp;i;//value assigning to the pointer
 90 *Under revision

Here declaration tells the compiler that P will be used to store the address of
integer value or in other word P is a pointer to an integer and *p reads the value at
the address contain in p.
P++;
printf(“value of p=%d”);
We can assign value of 1 pointer variable to other when their base type and data
type is same or both the pointer points to the same variable as in the array.
 Int *p1,*p2;
P1=&amp;a[1];
P2=&amp;a[3];
We can assign constant 0 to a pointer of any type for that symbolic constant
‘NULL’ is used such as
 *p=NULL;
It means pointer doesn’t point to any valid memory location.
Pointer Arithmetic
Pointer arithmetic is different from ordinary arithmetic and it is perform relative to
the data type(base type of a pointer).
Example:-
If integer pointer contain address of 2000 on incrementing we get address of 2002
instead of 2001, because, size of the integer is of 2 bytes.
Note:-
When we move a pointer, somewhere else in memory by incrementing or
decrement or adding or subtracting integer, it is not necessary that, pointer still
pointer to a variable of same data, because, memory allocation to the variable are
done by the compiler.
 91 *Under revision

But in case of array it is possible, since there data are stored in a consecutive
manner.
Ex:-
void main( )
{
static int a[ ]={20,30,105,82,97,72,66,102};
int *p,*p1;
P=&amp;a[1];
P1=&amp;a[6];
printf(“%d”,*p1-*p);
printf(“%d”,p1-p);
}
Arithmetic operation never perform on pointer are:
 addition, multiplication and division of two pointer.
 multiplication between the pointer by any number.
 division of pointer by any number
-add of float or double value to the pointer.
Operation performed in pointer are:-
/* Addition of a number through pointer */
Example
int i=100;
int *p;
 92 *Under revision

p=&amp;i;
p=p+2;
p=p+3;
p=p+9;
ii /* Subtraction of a number from a pointer’*/
Ex:-
int i=22;
*p1=&amp;a;
p1=p1-10;
p1=p1-2;
iii- Subtraction of one pointer to another is possible when pointer variable point to
an element of same type such as an array.
Ex:-
in tar[ ]={2,3,4,5,6,7};
int *ptr1,*ptr1;
ptr1=&amp;a[3]; //2000+4
ptr2=&amp;a[6]; //2000+6
 Lecture Note: 21
 93 *Under revision

Precedence of dereference (*) Operator and increment operator and
decrement operator
The precedence level of difference operator increment or decrement operator
is same and their associatively from right to left.
Example :-
int x=25;
int *p=&amp;x;
Let us calculate int y=*p++;
Equivalent to *(p++)
Since the operator associate from right to left, increment operator will applied to
the pointer p.
 i) int y=*p++; equivalent to *(p++)
 p =p++ or p=p+1
ii) *++p;→*(++p)→p=p+1
 y=*p
iii) int y=++*p
equivalent to ++(*p)
p=p+1 then *p
iv) y=(*p)++→equivalent to *p++
 y=*p then
 P=p+1 ;
 Since it is postfix increment the value of p.
Pointer Comparison
 94 *Under revision

Pointer variable can be compared when both variable, object of same data type
and it is useful when both pointers variable points to element of same array.
Moreover pointer variable are compared with zero which is usually expressed as
null, so several operators are used for comparison like the relational operator.
==,!=,&lt;=,&lt;,&gt;,&gt;=, can be used with pointer. Equal and not equal operators used to
compare two pointer should finding whether they contain same address or not and
they will equal only if are null or contains address of same variable.
Ex:-
 void main()
{
static int arr[]={20,25,15,27,105,96}
int *x,*y;
x=&amp;a[5];
y=&amp;(a+5);
if(x==y)
printf(“same”);
else
printf(“not”);
}
 Lecture Note: 22
 95 *Under revision

Pointer to pointer
Addition of pointer variable stored in some other variable is called pointer to
pointer variable.
Or
Pointer within another pointer is called pointer to pointer.
Syntax:-
 Data type **p;
 int x=22;
 int *p=&amp;x;
 int **p1=&amp;p;
printf(“value of x=%d”,x);
printf(“value of x=%d”,*p);
printf(“value of x=%d”,*&amp;x);
printf(“value of x=%d”,**p1);
printf(“value of p=%u”,&amp;p);
printf(“address of p=%u”,p1);
printf(“address of x=%u”,p);
printf(“address of p1=%u”,&amp;p1);
printf(“value of p=%u”,p);
printf(“value of p=%u”,&amp;x);

 p1
 96 *Under revision

P 2000
X 1000
22

 3000
Pointer vs array
Example :-
 void main()
{
static char arr[]=”Rama”;
char*p=”Rama”;
printf(“%s%s”, arr, p);
In the above example, at the first time printf( ), print the same value array and
pointer.
Here array arr, as pointer to character and p act as a pointer to array of
character . When we are trying to increase the value of arr it would give the error
because its known to compiler about an array and its base address which is always
printed to base address is known as constant pointer and the base address of array
which is not allowed by the compiler.
printf(“size of (p)”,size of (ar));
size of (p) 2/4 bytes
size of(ar) 5 byes
 97 *Under revision

Sructure
It is the collection of dissimilar data types or heterogenous data types grouped
together. It means the data types may or may not be of same type.
Structure declarationstruct tagname
{
Data type member1;
Data type member2;
Data type member3;
………
………
Data type member n;
};
OR
struct
{
Data type member1;
Data type member2;
 98 *Under revision

Data type member3;
………
………
Data type member n;
};
OR
struct tagname
{
struct element 1;
struct element 2;
struct element 3;
………
………
struct element n;
};
Structure variable declaration;
struct student
{
int age;
char name[20];
char branch[20];
 99 *Under revision

}; struct student s;
Initialization of structure variableLike primary variables structure variables can also be initialized when they are
declared. Structure templates can be defined locally or globally. If it is local it can
be used within that function. If it is global it can be used by all other functions of
the program.
We cant initialize structure members while defining the structure
struct student
{
int age=20;
char name[20]=”sona”;
}s1;
The above is invalid.
A structure can be initialized as
struct student
{
int age,roll;
char name[20];
} struct student s1={16,101,”sona”};
 struct student s2={17,102,”rupa”};
If initialiser is less than no.of structure variable, automatically rest values are taken
as zero.
 100 *Under revision

Accessing structure elementsDot operator is used to access the structure elements. Its associativety is from left
to right.
structure variable ;
s1.name[];
s1.roll;
s1.age;
Elements of structure are stored in contiguous memory locations. Value of
structure variable can be assigned to another structure variable of same type using
assignment operator.
Example:
#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
void main()
{
int roll, age;
char branch;
} s1,s2;
printf(“\n enter roll, age, branch=”);
scanf(“%d %d %c”, &amp;s1.roll, &amp;s1.age, &amp;s1.branch);
s2.roll=s1.roll;
printf(“ students details=\n”);
printf(“%d %d %c”, s1.roll, s1.age, s1.branch);
printf(“%d”, s2.roll);
 101 *Under revision

}
Unary, relational, arithmetic, bitwise operators are not allowed within structure
variables.
 Lecture Note:24
Size of structureSize of structure can be found out using sizeof() operator with structure variable
name or tag name with keyword.
sizeof(struct student); or
sizeof(s1);
sizeof(s2);
Size of structure is different in different machines. So size of whole structure may
not be equal to sum of size of its members.
Array of structures
When database of any element is used in huge amount, we prefer Array of
structures.
Example: suppose we want to maintain data base of 200 students, Array of
structures is used.
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
struct student
{
 102 *Under revision

char name[30];
char branch[25];
int roll;
};
void main()
{
struct student s[200];
int i;
s[i].roll=i+1;
printf("\nEnter information of students:");
for(i=0;i&lt;200;i++)
{
printf("\nEnter the roll no:%d\n",s[i].roll);
printf("\nEnter the name:");
scanf("%s",s[i].name);
printf("\nEnter the branch:");
scanf("%s",s[i].branch);
printf("\n");
}
printf("\nDisplaying information of students:\n\n");
for(i=0;i&lt;200;i++)
{
printf("\n\nInformation for roll no%d:\n",i+1);
 103 *Under revision

printf("\nName:");
puts(s[i].name);
printf("\nBranch:");
puts(s[i].branch);
}
}
In Array of structures each element of array is of structure type as in above
example.
Array within structures
struct student
{
char name[30];
int roll,age,marks[5];
}; struct student s[200];
We can also initialize using same syntax as in array.
Nested structure
When a structure is within another structure, it is called Nested structure. A
structure variable can be a member of another structure and it is represented as
struct student
 104 *Under revision

{
element 1;
element 2;
………
………
struct student1
{
member 1;
member 2;
}variable 1;
……….
……….
element n;
}variable 2;
It is possible to define structure outside &amp; declare its variable inside other
structure.
struct date
{
int date,month;
};
struct student
{
 105 *Under revision

 char nm[20];
int roll;
struct date d;
}; struct student s1;
 struct student s2,s3;
Nested structure may also be initialized at the time of declaration like in above
example.
struct student s={“name”,200, {date, month}};
 {“ram”,201, {12,11}};
Nesting of structure within itself is not valid. Nesting of structure can be
extended to any level.
struct time
{
int hr,min;
};
struct day
{
int date,month;
struct time t1;
};
struct student
 106 *Under revision

{
char nm[20];
struct day d;
}stud1, stud2, stud3;
 Lecture Note: 25
Passing structure elements to function
We can pass each element of the structure through function but passing individual
element is difficult when number of structure element increases. To overcome this,
we use to pass the whole structure through function instead of passing individual
element.
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
void main()
{
struct student
{
char name[30];
char branch[25];
int roll;
}struct student s;
printf(“\n enter name=”);
 107 *Under revision

gets(s.name);
printf("\nEnter roll:");
scanf("%d",&amp;s.roll);
printf("\nEnter branch:");
gets(s.branch);
display(name,roll,branch);
}
display(char name, int roll, char branch)
{
printf(“\n name=%s,\n roll=%d, \n branch=%s”, s.name, s.roll. s.branch);
}
Passing entire structure to function
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
struct student
{
char name[30];
int age,roll;
};
display(struct student); //passing entire structure
void main()
 108 *Under revision

{
 struct student s1={”sona”,16,101 };
 struct student s2={”rupa”,17,102 };
display(s1);
display(s2);
}
display(struct student s)
{
printf(“\n name=%s, \n age=%d ,\n roll=%d”, s.name, s.age, s.roll);
}
Output: name=sona
 roll=16
 Lecture Note: 26

 UNION
Union is derived data type contains collection of different data type or dissimilar
elements. All definition declaration of union variable and accessing member is
similar to structure, but instead of keyword struct the keyword union is used, the
main difference between union and structure is
 109 *Under revision

 Each member of structure occupy the memory location, but in the unions
members share memory. Union is used for saving memory and concept is useful
when it is not necessary to use all members of union at a time.
Where union offers a memory treated as variable of one type on one occasion
where (struct), it read number of different variables stored at different place of
memory.
Syntax of union:
union student
{
datatype member1;
datatype member2;
};
Like structure variable, union variable can be declared with definition or separately
such as
union union name
{
Datatype member1;
}var1;
Example:- union student s;
Union members can also be accessed by the dot operator with union variable and if
we have pointer to union then member can be accessed by using (arrow) operator
as with structure.
 110 *Under revision

Example:- struct student
struct student
{
int i;
char ch[10];
};struct student s;
Here datatype/member structure occupy 12 byte of location is memory, where as in
the union side it occupy only 10 byte.
Lecture Note:27
Nested of Union
When one union is inside the another union it is called nested of union.
Example:-
union a
{
int i;
int age;
};
union b
 111 *Under revision

{
char name[10];
union a aa;
}; union b bb;
There can also be union inside structure or structure in union.
Example:-
 void main()
 {
 struct a
 {
int i;
char ch[20];
};
struct b
{
int i;
char d[10];
};
union z
{
struct a a1;
struct b b1;
 112 *Under revision

}; union z z1;
z1.b1.j=20;
z1.a1.i=10;
z1.a1.ch[10]= “ i“;
z1.b1.d[0]=”j “;
printf(“ “);
Dynamic memory Allocation
The process of allocating memory at the time of execution or at the runtime, is
called dynamic memory location.
Two types of problem may occur in static memory allocation.
If number of values to be stored is less than the size of memory, there would be
wastage of memory.
If we would want to store more values by increase in size during the execution on
assigned size then it fails.
Allocation and release of memory space can be done with the help of some library
function called dynamic memory allocation function. These library function are
called as dynamic memory allocation function. These library function prototype
are found in the header file, “alloc.h” where it has defined.
Function take memory from memory area is called heap and release when not
required.
Pointer has important role in the dynamic memory allocation to allocate memory.
malloc():
 113 *Under revision

This function use to allocate memory during run time, its declaration is
void*malloc(size);
malloc ()
 returns the pointer to the 1st byte and allocate memory, and its return type is void,
which can be type cast such as:
int *p=(datatype*)malloc(size)
If memory location is successful, it returns the address of the memory chunk that
was allocated and it returns null on unsuccessful and from the above declaration a
pointer of type(datatype) and size in byte.
And datatype pointer used to typecast the pointer returned by malloc and this
typecasting is necessary since, malloc() by default returns a pointer to void.
Example int*p=(int*)malloc(10);
So, from the above pointer p, allocated IO contigious memory space address of 1st
byte and is stored in the variable.
We can also use, the size of operator to specify the the size, such as
*p=(int*)malloc(5*size of int) Here, 5 is the no. of data.
Moreover , it returns null, if no sufficient memory available , we should always
check the malloc return such as, if(p==null)
printf(“not sufficient memory”);
Example:
/*calculate the average of mark*/
void main()
{
int n , avg,i,*p,sum=0;
 114 *Under revision

printf("enter the no. of marks ”);
scanf(“%d”,&amp;n);
p=(int *)malloc(n*size(int));
if(p==null)
printf(“not sufficient”);
exit();
}
for(i=0;i&lt;n;i++)
scanf(“%d”,(p+i));
for(i=0;i&lt;n;i++)
Printf(“%d”,*(p+i));
sum=sum+*p;
avg=sum/n;
printf(“avg=%d”,avg);
 Lecture Note: 28
calloc()
Similar to malloc only difference is that calloc function use to allocate multiple
block of memory .
two arguments are there
1
st argument specify number of blocks
 115 *Under revision

2
nd argument specify size of each block.
Example:-
 int *p= (int*) calloc(5, 2);
int*p=(int *)calloc(5, size of (int));
Another difference between malloc and calloc is by default memory allocated by
malloc contains garbage value, where as memory allocated by calloc is initialised
by zero(but this initialisation) is not reliable.
realloc()
The function realloc use to change the size of the memory block and it alter the
size of the memory block without loosing the old data, it is called reallocation of
memory.
It takes two argument such as;
int *ptr=(int *)malloc(size);
int*p=(int *)realloc(ptr, new size);
The new size allocated may be larger or smaller.
If new size is larger than the old size, then old data is not lost and newly allocated
bytes are uninitialized. If old address is not sufficient then starting address
contained in pointer may be changed and this reallocation function moves content
of old block into the new block and data on the old block is not lost.
Example:
#include&lt;stdio.h&gt;
#include&lt;alloc.h&gt;
void main()
int i,*p;
 116 *Under revision

p=(int*)malloc(5*size of (int));
if(p==null)
{
printf(“space not available”);
exit();
printf(“enter 5 integer”);
for(i=0;i&lt;5;i++)
{
scanf(“%d”,(p+i));
int*ptr=(int*)realloc(9*size of (int) );
if(ptr==null)
{
printf(“not available”);
exit();
}
printf(“enter 4 more integer”);
for(i=5;i&lt;9;i++)
scanf(“%d”,(p+i));
for(i=0;i&lt;9;i++)
 printf(“%d”,*(p+i));
}
free()
 117 *Under revision

Function free() is used to release space allocated dynamically, the memory
released by free() is made available to heap again. It can be used for further
purpose.
Syntax for free declaration .
void(*ptr)
Or
free(p)
When program is terminated, memory released automatically by the operating
system. Even we don’t free the memory, it doesn’t give error, thus lead to memory
leak.
We can’t free the memory, those didn’t allocated.
 Lecture Note: 29
Dynamic array
Array is the example where memory is organized in contiguous way, in the
dynamic memory allocation function used such as malloc(), calloc(), realloc()
always made up of contiguous way and as usual we can access the element in two
ways as:
Subscript notation
Pointer notation
Example:
 118 *Under revision

#include&lt;stdio.h&gt;
#include&lt;alloc.h&gt;
void main()
{
printf(“enter the no.of values”);
scanf(“%d”,&amp;n);
p=(int*)malloc(n*size of int);
If(p==null)
printf(“not available memory”);
exit();
}
for(i=0;i&lt;n;i++)
{
printf(“enter an integer”);
scanf(“%d”,&amp;p[i]);
for(i=0;i&lt;n;i++)
{
printf(“%d”,p[i]);
}
}
File handling
 119 *Under revision

File: the file is a permanent storage medium in which we can store the data
permanently.
Types of file can be handled
we can handle three type of file as
(1) sequential file
(2) random access file
(3) binary file
File Operation
opening a file:
Before performing any type of operation, a file must be opened and for this
fopen() function is used.
syntax:
file-pointer=fopen(“FILE NAME ”,”Mode of open”);
example:
 FILE *fp=fopen(“ar.c”,”r”);
If fopen() unable to open a file than it will return NULL to the file pointer.
File-pointer: The file pointer is a pointer variable which can be store the address
of a special file that means it is based upon the file pointer a file gets opened.
Declaration of a file pointer:-
FILE* var;
Modes of open
The file can be open in three different ways as
 120 *Under revision

Read mode ’ r’/rt
Write mode ’w’/wt
Appened Mode ’a’/at
Reading a character from a file
getc() is used to read a character into a file
Syntax:
character_variable=getc(file_ptr);
Writing acharacter into a file
putc() is used to write a character into a file
puts(character-var,file-ptr);
 ClOSING A FILE
fclose() function close a file.
fclose(file-ptr);
fcloseall () is used to close all the opened file at a time
 File Operation
 The following file operation carried out the file
 (1)creation of a new file
 (3)writing a file
 (4)closing a file
 121 *Under revision

Before performing any type of operation we must have to open the file.c, language
communicate with file using A new type called file pointer.
Operation with fopen()
File pointer=fopen(“FILE NAME”,”mode of open”);
If fopen() unable to open a file then it will return NULL to the file-pointer.
 Lecture Note: 30
Reading and writing a characters from/to a file
fgetc() is used for reading a character from the file
 Syntax:
 character variable= fgetc(file pointer);
fputc() is used to writing a character to a file
Syntax:
 fputc(character,file_pointer);
 122 *Under revision

/*Program to copy a file to another*/
#include&lt;stdio.h&gt;
void main()
{
FILE *fs,*fd;
char ch;
If(fs=fopen(“scr.txt”,”r”)==0)
{
printf(“sorry….The source file cannot be opened”);
return;
}
If(fd=fopen(“dest.txt”,”w”)==0)
{
printf(“Sorry…..The destination file cannot be opened”);
fclose(fs);
return;
}
while(ch=fgets(fs)!=EOF)
fputc(ch,fd);
fcloseall();
}
 123 *Under revision

 Reading and writing a string from/to a file
 getw() is used for reading a string from the file
Syntax:
 gets(file pointer);
putw() is used to writing a character to a file
Syntax:
 fputs(integer,file_pointer);
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
void main()
{
FILE *fp;
int word;
/*place the word in a file*/
fp=fopen(“dgt.txt”,”wb”);
If(fp==NULL)
{
printf(“Error opening file”);
exit(1);
}
word=94;
putw(word,fp);
If(ferror(fp))
 124 *Under revision

printf(“Error writing to file\n”);
else
printf(“Successful write\n”);
fclose(fp);
/*reopen the file*/
fp=fopen(“dgt.txt”,”rb”);
If(fp==NULL)
{
printf(“Error opening file”);
exit(1);
}
/*extract the word*/
word=getw(fp);
If(ferror(fp))
printf(“Error reading file\n”);
else
printf(“Successful read:word=%d\n”,word);
/*clean up*/
fclose(fp);
}
 Lecture Note: 31
 125 *Under revision

Reading and writing a string from/to a file
fgets() is used for reading a string from the file
Syntax:
 fgets(string, length, file pointer);
fputs() is used to writing a character to a file
Syntax:
 fputs(string,file_pointer);
#include&lt;string.h&gt;
#include&lt;stdio.h&gt;
void main(void)
{
FILE*stream;
char string[]=”This is a test”;
char msg[20];
/*open a file for update*/
stream=fopen(“DUMMY.FIL”,”w+”);
/*write a string into the file*/
fwrite(string,strlen(string),1,stream);
/*seek to the start of the file*/
fseek(stream,0,SEEK_SET);
 126 *Under revision

/*read a string from the file*/
fgets(msg,strlen(string)+1,stream);
/*display the string*/
printf(“%s”,msg);
fclose(stream);
}


</value>
  </data>
  <data name="textBox2.Text" xml:space="preserve">
    <value>                                                       C++
Contents.....................................................................................................................................i 1. OVERVIEW ........................................................................................................................... 1 Object-Oriented Programming ................................................................................................................1 Standard Libraries...................................................................................................................................1 The ANSI Standard ..................................................................................................................................1 Learning C++............................................................................................................................................2 Use of C++ ...............................................................................................................................................2 2. ENVIORNMENT SETUP ......................................................................................................... 3 Try it Option Online.................................................................................................................................3 Local Environment Setup.........................................................................................................................3 Installing GNU C/C++ Compiler:...............................................................................................................4 3. BASIC SYNTAX ...................................................................................................................... 6 C++ Program Structure:...........................................................................................................................6 Compile &amp; Execute C++ Program: ............................................................................................................7 Semicolons &amp; Blocks in C++ .....................................................................................................................7 C++ Identifiers.........................................................................................................................................8 C++ Keywords..........................................................................................................................................8 Trigraphs.................................................................................................................................................9 Whitespace in C++.................................................................................................................................10 4. COMMENTS IN C++ ........................................................................................................... 11 5. DATA TYPES ....................................................................................................................... 13 Primitive Built-in Types.........................................................................................................................13 typedef Declarations.............................................................................................................................15 iii Enumerated Types ................................................................................................................................16 6. VARIABLE TYPES ................................................................................................................ 17 Variable Definition in C++......................................................................................................................17 Variable Declaration in C++ ...................................................................................................................18 Lvalues and Rvalues ..............................................................................................................................20 7. VARIABLE SCOPE ............................................................................................................... 21 Local Variables......................................................................................................................................21 Global Variables....................................................................................................................................22 Initializing Local and Global Variables ...................................................................................................23 8. CONSTANTS/LITERALS ....................................................................................................... 24 Integer Literals......................................................................................................................................24 Floating-point Literals ...........................................................................................................................24 Boolean Literals.....................................................................................................................................25 Character Literals..................................................................................................................................25 String Literals 
i
About the Tutorial
C++ is a middle-level programming language developed by Bjarne Stroustrup
starting in 1979 at Bell Labs. C++ runs on a variety of platforms, such as
Windows, Mac OS, and the various versions of UNIX.
This tutorial adopts a simple and practical approach to describe the concepts of
C++.
Audience
This tutorial has been prepared for the beginners to help them understand the
basic to advanced concepts related to C++.
Prerequisites
Before you start practicing with various types of examples given in this
tutorial,we are making an assumption that you are already aware of the basics
of computer program and computer programming language.
Copyright &amp; Disclaimer
 Copyright 2014 by Tutorials Point (I) Pvt. Ltd.
All the content and graphics published in this e-book are the property of
Tutorials Point (I) Pvt. Ltd. The user of this e-book is prohibited to reuse, retain,
copy, distribute or republish any contents or a part of contents of this e-book in
any manner without written consent of the publisher.
We strive to update the contents of our website and tutorials as timely and as
precisely as possible, however, the contents may contain inaccuracies or errors.
Tutorials Point (I) Pvt. Ltd. provides no guarantee regarding the accuracy,
timeliness or completeness of our website or its contents including this tutorial.
If you discover any errors on our website or in this tutorial, please notify us at
contact@tutorialspoint.com
Table of Contents
About the Tutorial....................................................................................................................................i
Audience ..................................................................................................................................................i
Prerequisites............................................................................................................................................i
ii
Copyright &amp; Disclaimer.............................................................................................................................i
Table of Contents.....................................................................................................................................i
1. OVERVIEW ........................................................................................................................... 1
Object-Oriented Programming ................................................................................................................1
Standard Libraries...................................................................................................................................1
The ANSI Standard ..................................................................................................................................1
Learning C++............................................................................................................................................2
Use of C++ ...............................................................................................................................................2
2. ENVIORNMENT SETUP ......................................................................................................... 3
Try it Option Online.................................................................................................................................3
Local Environment Setup.........................................................................................................................3
Installing GNU C/C++ Compiler:...............................................................................................................4
3. BASIC SYNTAX ...................................................................................................................... 6
C++ Program Structure:...........................................................................................................................6
Compile &amp; Execute C++ Program: ............................................................................................................7
Semicolons &amp; Blocks in C++ .....................................................................................................................7
C++ Identifiers.........................................................................................................................................8
C++ Keywords..........................................................................................................................................8
Trigraphs.................................................................................................................................................9
Whitespace in C++.................................................................................................................................10

4. COMMENTS IN C++ ........................................................................................................... 11
5. DATA TYPES ....................................................................................................................... 13
Primitive Built-in Types.........................................................................................................................13
typedef Declarations.............................................................................................................................15
iii
Enumerated Types ................................................................................................................................16
6. VARIABLE TYPES ................................................................................................................ 17
Variable Definition in C++......................................................................................................................17
Variable Declaration in C++ ...................................................................................................................18
Lvalues and Rvalues ..............................................................................................................................20
7. VARIABLE SCOPE ............................................................................................................... 21
Local Variables......................................................................................................................................21
Global Variables....................................................................................................................................22
Initializing Local and Global Variables ...................................................................................................23
8. CONSTANTS/LITERALS ....................................................................................................... 24
Integer Literals......................................................................................................................................24
Floating-point Literals ...........................................................................................................................24
Boolean Literals.....................................................................................................................................25
Character Literals..................................................................................................................................25
String Literals ........................................................................................................................................26
Defining Constants................................................................................................................................27
9. MODIFIER TYPES ................................................................................................................ 29
Type Qualifiers in C++............................................................................................................................30
10. STORAGE CLASSES ............................................................................................................. 31
The auto Storage Class..........................................................................................................................31
The register Storage Class .....................................................................................................................31
The static Storage Class.........................................................................................................................31
The extern Storage Class.......................................................................................................................33
The mutable Storage Class ....................................................................................................................34
11. OPERATORS ....................................................................................................................... 35
iv
Arithmetic Operators............................................................................................................................35
Relational Operators.............................................................................................................................37
Logical Operators..................................................................................................................................40
Bitwise Operators .................................................................................................................................41
Assignment Operators...........................................................................................................................44
Misc Operators......................................................................................................................................47
Operators Precedence in C++ ................................................................................................................48
12. LOOP TYPES ....................................................................................................................... 51
While Loop............................................................................................................................................52
for Loop.................................................................................................................................................54
do…while Loop......................................................................................................................................56
nested Loops.........................................................................................................................................58
Loop Control Statements.......................................................................................................................60
Break Statement ...................................................................................................................................61
continue Statement ..............................................................................................................................63
goto Statement.....................................................................................................................................65
The Infinite Loop ...................................................................................................................................67
13. DECISION-MAKING STATEMENTS ...................................................................................... 69
If Statement..........................................................................................................................................70
if…else Statement .................................................................................................................................72
if...else if...else Statement.....................................................................................................................73
Switch Statement..................................................................................................................................75
Nested if Statement ..............................................................................................................................78
The ? : Operator....................................................................................................................................81
14. FUNCTIONS ....................................................................................................................... 82
Defining a Function ...............................................................................................................................82
v
Function Declarations ...........................................................................................................................83
Calling a Function..................................................................................................................................84
Function Arguments..............................................................................................................................85
Call by Value .........................................................................................................................................86
Call by Pointer.......................................................................................................................................87
Call by Reference...................................................................................................................................89
Default Values for Parameters ..............................................................................................................90
15. NUMBERS .......................................................................................................................... 93
Defining Numbers in C++.......................................................................................................................93
Math Operations in C++ ........................................................................................................................94
Random Numbers in C++.......................................................................................................................96
16. ARRAYS .............................................................................................................................. 98
Declaring Arrays....................................................................................................................................98
Initializing Arrays ..................................................................................................................................98
Accessing Array Elements......................................................................................................................99
Arrays in C++ .......................................................................................................................................100
Pointer to an Array..............................................................................................................................103
Passing Arrays to Functions.................................................................................................................105
Return Array from Functions...............................................................................................................107
17. STRINGS........................................................................................................................... 111
The C-Style Character String................................................................................................................111
The String Class in C++.........................................................................................................................114
18. POINTERS ........................................................................................................................ 116
What are Pointers? .............................................................................................................................116
Using Pointers in C++...........................................................................................................................117
Pointers in C++ ....................................................................................................................................118
vi
Null Pointers .......................................................................................................................................119
Pointer Arithmetic...............................................................................................................................120
Pointers vs Arrays ...............................................................................................................................124
Array of Pointers.................................................................................................................................126
Pointer to a Pointer.............................................................................................................................128
Passing Pointers to Functions..............................................................................................................130
Return Pointer from Functions............................................................................................................132
19. REFERENCES .................................................................................................................... 135
References vs Pointers........................................................................................................................135
Creating References in C++..................................................................................................................135
References as Parameters...................................................................................................................137
Reference as Return Value ..................................................................................................................138
20. DATE AND TIME ............................................................................................................... 141
Current Date and Time........................................................................................................................142
Format Time using struct tm ...............................................................................................................143
21. BASIC INPUT/OUTPUT ..................................................................................................... 145
I/O Library Header Files.......................................................................................................................145
The Standard Output Stream (cout) ....................................................................................................145
The Standard Input Stream (cin)..........................................................................................................146
The Standard Error Stream (cerr) ........................................................................................................147
The Standard Log Stream (clog)...........................................................................................................148

22. DATA STRUCTURES .......................................................................................................... 149
Defining a Structure ............................................................................................................................149
Accessing Structure Members.............................................................................................................150
vii
Structures as Function Arguments.......................................................................................................151
Pointers to Structures .........................................................................................................................153
The typedef Keyword ..........................................................................................................................155
23. CLASSES AND OBJECTS .................................................................................................... 157
C++ Class Definitions...........................................................................................................................157
Define C++ Objects..............................................................................................................................157
Accessing the Data Members..............................................................................................................158
Classes &amp; Objects in Detail ..................................................................................................................159
Class Access Modifiers.........................................................................................................................163
The public Members............................................................................................................................164
The private Members..........................................................................................................................165
The protected Members......................................................................................................................167
Constructor &amp; Destructor....................................................................................................................169
Parameterized Constructor .................................................................................................................170
The Class Destructor............................................................................................................................173
Copy Constructor ................................................................................................................................174
Friend Functions..................................................................................................................................179
Inline Functions...................................................................................................................................181
this Pointer .........................................................................................................................................182
Pointer to C++ Classes.........................................................................................................................184
Static Members of a Class ...................................................................................................................185
Static Function Members ....................................................................................................................187

24. INHERITANCE................................................................................................................... 190
Base &amp; Derived Classes........................................................................................................................190
Access Control and Inheritance ...........................................................................................................192
viii
Type of Inheritance .............................................................................................................................192
Multiple Inheritance ...........................................................................................................................193
25. OVERLOADING (OPERATOR &amp; FUNCTION) ....................................................................... 196
Function Overloading in C++ ...............................................................................................................196
Operators Overloading in C++ .............................................................................................................197
Overloadable/Non-overloadable Operators........................................................................................200
Operator Overloading Examples .........................................................................................................201
Unary Operators Overloading .............................................................................................................201
Increment (++) and Decrement (- -) Operators....................................................................................203
Binary Operators Overloading.............................................................................................................205
Relational Operators Overloading.......................................................................................................208
Input/Output Operators Overloading..................................................................................................210
++ and - - Operators Overloading ........................................................................................................212
Assignment Operators Overloading ....................................................................................................214
Function Call () Operator Overloading.................................................................................................215
Subscripting [ ] Operator Overloading.................................................................................................217
Class Member Access Operator - &gt; Overloading ..................................................................................219
26. POLYMORPHISM.............................................................................................................. 223
Virtual Function ..................................................................................................................................226
Pure Virtual Functions.........................................................................................................................226
27. DATA ABSTRACTION ........................................................................................................ 227
Access Labels Enforce Abstraction.......................................................................................................228
Benefits of Data Abstraction ...............................................................................................................228
Data Abstraction Example...................................................................................................................228
Designing Strategy ..............................................................................................................................230
28. DATA ENCAPSULATION .................................................................................................... 231
ix
Data Encapsulation Example ...............................................................................................................232
Designing Strategy ..............................................................................................................................233
29. INTERFACES ..................................................................................................................... 234
Abstract Class Example .......................................................................................................................234
Designing Strategy ..............................................................................................................................236
30. FILES AND STREAMS ........................................................................................................ 238
Opening a File .....................................................................................................................................238
Closing a File .......................................................................................................................................239
Writing to a File...................................................................................................................................239
Reading from a File .............................................................................................................................239
Read &amp; Write Example ........................................................................................................................240
File Position Pointers...........................................................................................................................242
31. EXCEPTION HANDLING ...................................................................................................... 243
Throwing Exceptions...........................................................................................................................244
Catching Exceptions ............................................................................................................................244
C++ Standard Exceptions.....................................................................................................................246
Define New Exceptions .......................................................................................................................247
32. DYNAMIC MEMORY ......................................................................................................... 249
The new and delete Operators............................................................................................................249
Dynamic Memory Allocation for Arrays ..............................................................................................251
Dynamic Memory Allocation for Objects.............................................................................................251

33. NAMESPACES .................................................................................................................. 253
Defining a Namespace.........................................................................................................................253
The using directive ..............................................................................................................................254
x
Discontiguous Namespaces.................................................................................................................256
Nested Namespaces............................................................................................................................256
34. TEMPLATES ..................................................................................................................... 258
Function Template ..............................................................................................................................258
Class Template ....................................................................................................................................259
35. PREPROCESSOR ............................................................................................................... 263
The #define Preprocessor....................................................................................................................263
Function-Like Macros..........................................................................................................................264
Conditional Compilation .....................................................................................................................264
The # and # # Operators......................................................................................................................266
Predefined C++ Macros .......................................................................................................................268
36. SIGNAL HANDLING .......................................................................................................... 270
The signal() Function ...........................................................................................................................270
The raise() Function.............................................................................................................................272
37. MULTITHREADING ........................................................................................................... 274
Creating Threads.................................................................................................................................274
Terminating Threads...........................................................................................................................275
Passing Arguments to Threads............................................................................................................277
Joining and Detaching Threads............................................................................................................278
38. WEB PROGRAMMING ...................................................................................................... 282
What is CGI?........................................................................................................................................282
Web Browsing.....................................................................................................................................282
CGI Architecture Diagram....................................................................................................................282
Web Server Configuration ...................................................................................................................283
First CGI Program ................................................................................................................................284
xi
My First CGI program ..........................................................................................................................284
HTTP Header .......................................................................................................................................285
CGI Environment Variables..................................................................................................................285
C++ CGI Library....................................................................................................................................289
GET and POST Methods.......................................................................................................................289
Passing Information Using GET Method ..............................................................................................289
Simple URL Example: Get Method.......................................................................................................290
Simple FORM Example: GET Method...................................................................................................291
Passing Information Using POST Method ............................................................................................292
Passing Checkbox Data to CGI Program...............................................................................................292
Passing Radio Button Data to CGI Program .........................................................................................294
Passing Text Area Data to CGI Program...............................................................................................296
Passing Dropdown Box Data to CGI Program.......................................................................................298
Using Cookies in CGI............................................................................................................................299
How It Works ......................................................................................................................................299
Setting up Cookies...............................................................................................................................300
Retrieving Cookies...............................................................................................................................301
File Upload Example............................................................................................................................303
39. STL TUTORIAL .................................................................................................................. 306
40. STANDARD LIBRARY ......................................................................................................... 309
The Standard Function Library ............................................................................................................309
The Object Oriented Class Library .......................................................................................................309
C++
1
C++ is a statically typed, compiled, general-purpose, case-sensitive, free-form
programming language that supports procedural, object-oriented, and generic
programming.
C++ is regarded as a middle-level language, as it comprises a combination of
both high-level and low-level language features.
C++ was developed by Bjarne Stroustrup starting in 1979 at Bell Labs in Murray
Hill, New Jersey, as an enhancement to the C language and originally named C
with Classes but later it was renamed C++ in 1983.
C++ is a superset of C, and that virtually any legal C program is a legal C++
program.
Note: A programming language is said to use static typing when type checking
is performed during compile-time as opposed to run-time.
Object-Oriented Programming
C++ fully supports object-oriented programming, including the four pillars of
object-oriented development:
 Encapsulation
 Data hiding
 Inheritance
 Polymorphism
Standard Libraries
Standard C++ consists of three important parts:
 The core language giving all the building blocks including variables, data
types and literals, etc.
 The C++ Standard Library giving a rich set of functions manipulating files,
strings, etc.
 The Standard Template Library (STL) giving a rich set of methods
manipulating data structures, etc.
The ANSI Standard
The ANSI standard is an attempt to ensure that C++ is portable; that code you
write for Microsoft's compiler will compile without errors, using a compiler on a
Mac, UNIX, a Windows box, or an Alpha.
1. OVERVIEW
C++
2
The ANSI standard has been stable for a while, and all the major C++ compiler
manufacturers support the ANSI standard.
Learning C++
The most important thing while learning C++ is to focus on concepts.
The purpose of learning a programming language is to become a better
programmer; that is, to become more effective at designing and implementing
new systems and at maintaining old ones.
C++ supports a variety of programming styles. You can write in the style of
Fortran, C, Smalltalk, etc., in any language. Each style can achieve its aims
effectively while maintaining runtime and space efficiency.
Use of C++
C++ is used by hundreds of thousands of programmers in essentially every
application domain.
C++ is being highly used to write device drivers and other software that rely on
direct manipulation of hardware under real-time constraints.
C++ is widely used for teaching and research because it is clean enough for
successful teaching of basic concepts.
Anyone who has used either an Apple Macintosh or a PC running Windows has
indirectly used C++ because the primary user interfaces of these systems are
written in C++.
C++
3
Try it Option Online
You really do not need to set up your own environment to start learning C++
programming language. Reason is very simple, we have already set up C++
Programming environment online, so that you can compile and execute all the
available examples online at the same time when you are doing your theory
work. This gives you confidence in what you are reading and to check the result
with different options. Feel free to modify any example and execute it online.
Try the following example using our online compiler option available at
http://www.compileonline.com/
#include &lt;iostream&gt;
using namespace std;
int main()
{
 cout &lt;&lt; "Hello World";
 return 0;
}
For most of the examples given in this tutorial, you will find Try it option in our
website code sections at the top right corner that will take you to the online
compiler. So just make use of it and enjoy your learning.
Local Environment Setup
If you are still willing to set up your environment for C++, you need to have the
following two softwares on your computer.
Text Editor:
This will be used to type your program. Examples of few editors include Windows
Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.
Name and version of text editor can vary on different operating systems. For
example, Notepad will be used on Windows and vim or vi can be used on
windows as well as Linux, or UNIX.
The files you create with your editor are called source files and for C++ they
typically are named with the extension .cpp, .cp, or .c.
A text editor should be in place to start your C++ programming.
2. ENVIORNMENT SETUP
C++
4
C++ Compiler:
This is an actual C++ compiler, which will be used to compile your source code
into final executable program.
Most C++ compilers don't care what extension you give to your source code, but
if you don't specify otherwise, many will use .cpp by default.
Most frequently used and free available compiler is GNU C/C++ compiler,
otherwise you can have compilers either from HP or Solaris if you have the
respective Operating Systems.
Installing GNU C/C++ Compiler:
UNIX/Linux Installation:
If you are using Linux or UNIX then check whether GCC is installed on your
system by entering the following command from the command line:
$ g++ -v
If you have installed GCC, then it should print a message such as the following:
Using built-in specs.
Target: i386-redhat-linux
Configured with: ../configure --prefix=/usr .......
Thread model: posix
gcc version 4.1.2 20080704 (Red Hat 4.1.2-46)
If GCC is not installed, then you will have to install it yourself using the detailed
instructions available at http://gcc.gnu.org/install/ .
Mac OS X Installation:
If you use Mac OS X, the easiest way to obtain GCC is to download the Xcode
development environment from Apple's website and follow the simple installation
instructions.
Xcode is currently available at developer.apple.com/technologies/tools/.
Windows Installation:
To install GCC at Windows you need to install MinGW. To install MinGW, go to
the MinGW homepage, www.mingw.org, and follow the link to the MinGW
download page. Download the latest version of the MinGW installation program
which should be named MinGW-&lt;version&gt;.exe.
While installing MinGW, at a minimum, you must install gcc-core, gcc-g++,
binutils, and the MinGW runtime, but you may wish to install more.
C++
5
Add the bin subdirectory of your MinGW installation to your PATH environment
variable so that you can specify these tools on the command line by their simple
names.
When the installation is complete, you will be able to run gcc, g++, ar, ranlib,
dlltool, and several other GNU tools from the Windows command line.
C++
6
When we consider a C++ program, it can be defined as a collection of objects
that communicate via invoking each other's methods. Let us now briefly look
into what a class, object, methods, and instant variables mean.
 Object - Objects have states and behaviors. Example: A dog has states -
color, name, breed as well as behaviors - wagging, barking, and eating.
An object is an instance of a class.
 Class - A class can be defined as a template/blueprint that describes the
behaviors/states that object of its type support.
 Methods - A method is basically a behavior. A class can contain many
methods. It is in methods where the logics are written, data is
manipulated and all the actions are executed.
 Instant Variables - Each object has its unique set of instant variables.
An object's state is created by the values assigned to these instant
variables.
C++ Program Structure:
Let us look at a simple code that would print the words Hello World.
#include &lt;iostream&gt;
using namespace std;
// main() is where program execution begins.
int main()
{
 cout &lt;&lt; "Hello World"; // prints Hello World
 return 0;
}
Let us look at the various parts of the above program:
1. The C++ language defines several headers, which contain information
that is either necessary or useful to your program. For this program, the
header &lt;iostream&gt; is needed.
2. The line using namespace std; tells the compiler to use the std
namespace. Namespaces are a relatively recent addition to C++.
3. BASIC SYNTAX
C++
7
3. The next line ‘// main() is where program execution begins.’ is a
single-line comment available in C++. Single-line comments begin with //
and stop at the end of the line.
4. The line int main() is the main function where program execution begins.
5. The next line cout &lt;&lt; "This is my first C++ program."; causes the
message "This is my first C++ program" to be displayed on the screen.
6. The next line return 0; terminates main() function and causes it to return
the value 0 to the calling process.
Compile &amp; Execute C++ Program:
Let's look at how to save the file, compile and run the program. Please follow the
steps given below:
1. Open a text editor and add the code as above.
2. Save the file as: hello.cpp
3. Open a command prompt and go to the directory where you saved the
file.
4. Type 'g++ hello.cpp' and press enter to compile your code. If there are no
errors in your code the command prompt will take you to the next line
and would generate a.out executable file.
5. Now, type 'a.out' to run your program.
6. You will be able to see ' Hello World ' printed on the window.
$ g++ hello.cpp
$ ./a.out
Hello World
Make sure that g++ is in your path and that you are running it in the directory
containing file hello.cpp.
You can compile C/C++ programs using makefile. For more details, you can
check our ‘Makefile Tutorial’.
Semicolons &amp; Blocks in C++
In C++, the semicolon is a statement terminator. That is, each individual
statement must be ended with a semicolon. It indicates the end of one logical
entity.
For example, following are three different statements:
x = y;
y = y+1;
C++
8
add(x, y);
A block is a set of logically connected statements that are surrounded by
opening and closing braces. For example:
{
 cout &lt;&lt; "Hello World"; // prints Hello World
 return 0;
}
C++ does not recognize the end of the line as a terminator. For this reason, it
does not matter where you put a statement in a line. For example:
x = y;
y = y+1;
add(x, y);
is the same as
x = y; y = y+1; add(x, y);
C++ Identifiers
A C++ identifier is a name used to identify a variable, function, class, module, or
any other user-defined item. An identifier starts with a letter A to Z or a to z or
an underscore (_) followed by zero or more letters, underscores, and digits (0 to
9).
C++ does not allow punctuation characters such as @, $, and % within
identifiers. C++ is a case-sensitive programming language.
Thus, Manpower and manpower are two different identifiers in C++.
Here are some examples of acceptable identifiers:
mohd zara abc move_name a_123
myname50 _temp j a23b9 retVal
C++ Keywords
The following list shows the reserved words in C++. These reserved words may
not be used as constant or variable or any other identifier names.
asm else new this
auto enum operator throw
C++
9
bool explicit private true
break export protected try
case extern public typedef
catch false register typeid
char float reinterpret_cast typename
class for return union
const friend short unsigned
const_cast goto signed using
continue if sizeof virtual
default inline static void
delete int static_cast volatile
do long struct wchar_t
double mutable switch while
dynamic_cast namespace template
Trigraphs
A few characters have an alternative representation, called a trigraph sequence.
A trigraph is a three-character sequence that represents a single character and
the sequence always starts with two question marks.
Trigraphs are expanded anywhere they appear, including within string literals
and character literals, in comments, and in preprocessor directives.
Following are most frequently used trigraph sequences:
Trigraph Replacement
C++
10
??= #
??/ \
??' ^
??( [
??) ]
??! |
??&lt; {
??&gt; }
??- ~
All the compilers do not support trigraphs and they are not advised to be used
because of their confusing nature.
Whitespace in C++
A line containing only whitespace, possibly with a comment, is known as a blank
line, and C++ compiler totally ignores it.
Whitespace is the term used in C++ to describe blanks, tabs, newline characters
and comments. Whitespace separates one part of a statement from another and
enables the compiler to identify where one element in a statement, such as int,
ends and the next element begins. Statement 1:
int age;
In the above statement there must be at least one whitespace character (usually
a space) between int and age for the compiler to be able to distinguish them.
Statement 2:
fruit = apples + oranges; // Get the total fruit
In the above statement 2, no whitespace characters are necessary between fruit
and =, or between = and apples, although you are free to include some if you
wish for readability purpose.
C++
11
Program comments are explanatory statements that you can include in the C++
code. These comments help anyone reading the source code. All programming
languages allow for some form of comments.
C++ supports single-line and multi-line comments. All characters available
inside any comment are ignored by C++ compiler.
C++ comments start with /* and end with */. For example:
/* This is a comment */
/* C++ comments can also
* span multiple lines
*/
A comment can also start with //, extending to the end of the line. For example:
#include &lt;iostream&gt;
using namespace std;
main()
{
 cout &lt;&lt; "Hello World"; // prints Hello World
 return 0;
}
When the above code is compiled, it will ignore // prints Hello World and final
executable will produce the following result:
Hello World
Within a /* and */ comment, // characters have no special meaning. Within a //
comment, /* and */ have no special meaning. Thus, you can "nest" one kind of
comment within the other kind. For example:
/* Comment out printing of Hello World:
4. COMMENTS IN C++
C++
12
cout &lt;&lt; "Hello World"; // prints Hello World
*/
C++
13
While writing program in any language, you need to use various variables to
store various information. Variables are nothing but reserved memory locations
to store values. This means that when you create a variable you reserve some
space in memory.
You may like to store information of various data types like character, wide
character, integer, floating point, double floating point, boolean etc. Based on
the data type of a variable, the operating system allocates memory and decides
what can be stored in the reserved memory.
Primitive Built-in Types
C++ offers the programmer a rich assortment of built-in as well as user defined
data types. Following table lists down seven basic C++ data types:
Type Keyword
Boolean bool
Character char
Integer int
Floating point float
Double floating point double
Valueless void
Wide character wchar_t
Several of the basic types can be modified using one or more of these type
modifiers:
 signed
 unsigned
 short
 long
5. DATA TYPES
C++
14
The following table shows the variable type, how much memory it takes to store
the value in memory, and what is maximum and minimum value which can be
stored in such type of variables.
Type Typical Bit Width Typical Range
char 1byte -127 to 127 or 0 to 255
unsigned char 1byte 0 to 255
signed char 1byte -127 to 127
int 4bytes -2147483648 to 2147483647
unsigned int 4bytes 0 to 4294967295
signed int 4bytes -2147483648 to 2147483647
short int 2bytes -32768 to 32767
unsigned short int Range 0 to 65,535
signed short int Range -32768 to 32767
long int 4bytes -2,147,483,647 to 2,147,483,647
signed long int 4bytes same as long int
unsigned long int 4bytes 0 to 4,294,967,295
float 4bytes +/- 3.4e +/- 38 (~7 digits)
double 8bytes +/- 1.7e +/- 308 (~15 digits)
long double 8bytes +/- 1.7e +/- 308 (~15 digits)
wchar_t 2 or 4 bytes 1 wide character
The size of variables might be different from those shown in the above table,
depending on the compiler and the computer you are using.
C++
15
Following is the example, which will produce correct size of various data types
on your computer.
#include &lt;iostream&gt;
using namespace std;
int main()
{
 cout &lt;&lt; "Size of char : " &lt;&lt; sizeof(char) &lt;&lt; endl;
 cout &lt;&lt; "Size of int : " &lt;&lt; sizeof(int) &lt;&lt; endl;
 cout &lt;&lt; "Size of short int : " &lt;&lt; sizeof(short int) &lt;&lt; endl;
 cout &lt;&lt; "Size of long int : " &lt;&lt; sizeof(long int) &lt;&lt; endl;
 cout &lt;&lt; "Size of float : " &lt;&lt; sizeof(float) &lt;&lt; endl;
 cout &lt;&lt; "Size of double : " &lt;&lt; sizeof(double) &lt;&lt; endl;
 cout &lt;&lt; "Size of wchar_t : " &lt;&lt; sizeof(wchar_t) &lt;&lt; endl;
 return 0;
}
This example uses endl, which inserts a new-line character after every line and
&lt;&lt; operator is being used to pass multiple values out to the screen. We are also
using sizeof() function to get size of various data types.
When the above code is compiled and executed, it produces the following result
which can vary from machine to machine:
Size of char : 1
Size of int : 4
Size of short int : 2
Size of long int : 4
Size of float : 4
Size of double : 8
Size of wchar_t : 4
typedef Declarations
You can create a new name for an existing type using typedef. Following is the
simple syntax to define a new type using typedef:
typedef type newname;
For example, the following tells the compiler that feet is another name for int:
C++
16
typedef int feet;
Now, the following declaration is perfectly legal and creates an integer variable
called distance:
feet distance;
Enumerated Types
An enumerated type declares an optional type name and a set of zero or more
identifiers that can be used as values of the type. Each enumerator is a constant
whose type is the enumeration.
Creating an enumeration requires the use of the keyword enum. The general
form of an enumeration type is:
enum enum-name { list of names } var-list;
Here, the enum-name is the enumeration's type name. The list of names is
comma separated.
For example, the following code defines an enumeration of colors called colors
and the variable c of type color. Finally, c is assigned the value "blue".
enum color { red, green, blue } c;
c = blue;
By default, the value of the first name is 0, the second name has the value 1,
and the third has the value 2, and so on. But you can give a name, a specific
value by adding an initializer. For example, in the following
enumeration, green will have the value 5.
enum color { red, green=5, blue };
Here, blue will have a value of 6 because each name will be one greater than
the one that precedes it.
C++
17
A variable provides us with named storage that our programs can manipulate.
Each variable in C++ has a specific type, which determines the size and layout
of the variable's memory; the range of values that can be stored within that
memory; and the set of operations that can be applied to the variable.
The name of a variable can be composed of letters, digits, and the underscore
character. It must begin with either a letter or an underscore. Upper and
lowercase letters are distinct because C++ is case-sensitive:
There are following basic types of variable in C++ as explained in last chapter:
Type Description
bool Stores either value true or false.
char Typically a single octet (one byte). This is an integer
type.
int The most natural size of integer for the machine.
float A single-precision floating point value.
double A double-precision floating point value.
void Represents the absence of type.
wchar_t A wide character type.
C++ also allows to define various other types of variables, which we will cover in
subsequent chapters like Enumeration, Pointer, Array, Reference, Data
structures, and Classes.
Following section will cover how to define, declare and use various types of
variables.
Variable Definition in C++
A variable definition tells the compiler where and how much storage to create for
the variable. A variable definition specifies a data type, and contains a list of one
or more variables of that type as follows:
6. VARIABLE TYPES
C++
18
type variable_list;
Here, type must be a valid C++ data type including char, w_char, int, float,
double, bool or any user-defined object, etc., and variable_list may consist of
one or more identifier names separated by commas. Some valid declarations are
shown here:
int i, j, k;
char c, ch;
float f, salary;
double d;
The line int i, j, k; both declares and defines the variables i, j and k; which
instructs the compiler to create variables named i, j and k of type int.
Variables can be initialized (assigned an initial value) in their declaration. The
initializer consists of an equal sign followed by a constant expression as follows:
type variable_name = value;
Some examples are:
extern int d = 3, f = 5; // declaration of d and f.
int d = 3, f = 5; // definition and initializing d and f.
byte z = 22; // definition and initializes z.
char x = 'x'; // the variable x has the value 'x'.
For definition without an initializer: variables with static storage duration are
implicitly initialized with NULL (all bytes have the value 0); the initial value of all
other variables is undefined.
Variable Declaration in C++
A variable declaration provides assurance to the compiler that there is one
variable existing with the given type and name so that compiler proceed for
further compilation without needing complete detail about the variable. A
variable declaration has its meaning at the time of compilation only, compiler
needs actual variable declaration at the time of linking of the program.
A variable declaration is useful when you are using multiple files and you define
your variable in one of the files which will be available at the time of linking of
the program. You will use extern keyword to declare a variable at any place.
Though you can declare a variable multiple times in your C++ program, but it
can be defined only once in a file, a function or a block of code.
Example:
C++
19
Try the following example where a variable has been declared at the top, but it
has been defined inside the main function:
#include &lt;iostream&gt;
using namespace std;
// Variable declaration:
extern int a, b;
extern int c;
extern float f;

int main ()
{
 // Variable definition:
 int a, b;
 int c;
 float f;
 // actual initialization
 a = 10;
 b = 20;
 c = a + b;
 cout &lt;&lt; c &lt;&lt; endl ;
 f = 70.0/3.0;
 cout &lt;&lt; f &lt;&lt; endl ;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
30
23.3333
C++
20
Same concept applies on function declaration where you provide a function
name at the time of its declaration and its actual definition can be given
anywhere else. For example:
// function declaration
int func();
int main()
{
 // function call
 int i = func();
}
// function definition
int func()
{
 return 0;
}
Lvalues and Rvalues
There are two kinds of expressions in C++:
 lvalue : Expressions that refer to a memory location is called "lvalue"
expression. An lvalue may appear as either the left-hand or right-hand
side of an assignment.
 rvalue : The term rvalue refers to a data value that is stored at some
address in memory. An rvalue is an expression that cannot have a value
assigned to it which means an rvalue may appear on the right- but not
left-hand side of an assignment.
Variables are lvalues and so may appear on the left-hand side of an assignment.
Numeric literals are rvalues and so may not be assigned and cannot appear on
the left-hand side. Following is a valid statement:
int g = 20;
But the following is not a valid statement and would generate compile-time
error:
10 = 20;
C++
21
A scope is a region of the program and broadly speaking there are three places,
where variables can be declared:
 Inside a function or a block which is called local variables,
 In the definition of function parameters which is called formal parameters.
 Outside of all functions which is called global variables.
We will learn what a function is, and it's parameter in subsequent chapters. Here
let us explain what local and global variables are.
Local Variables
Variables that are declared inside a function or block are local variables. They
can be used only by statements that are inside that function or block of code.
Local variables are not known to functions outside their own. Following is the
example using local variables:
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 // Local variable declaration:
 int a, b;
 int c;
// actual initialization
 a = 10;
 b = 20;
 c = a + b;
 cout &lt;&lt; c;
 return 0;
}
7. VARIABLE SCOPE
C++
22
Global Variables
Global variables are defined outside of all the functions, usually on top of the
program. The global variables will hold their value throughout the life-time of
your program.
A global variable can be accessed by any function. That is, a global variable is
available for use throughout your entire program after its declaration. Following
is the example using global and local variables:
#include &lt;iostream&gt;
using namespace std;
// Global variable declaration:
int g;
int main ()
{
 // Local variable declaration:
 int a, b;
 // actual initialization
 a = 10;
 b = 20;
 g = a + b;
 cout &lt;&lt; g;
 return 0;
}
A program can have same name for local and global variables but value of local
variable inside a function will take preference. For example:
#include &lt;iostream&gt;
using namespace std;
// Global variable declaration:
int g = 20;
C++
23
int main ()
{
 // Local variable declaration:
 int g = 10;
 cout &lt;&lt; g;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
10
Initializing Local and Global Variables
When a local variable is defined, it is not initialized by the system, you must
initialize it yourself. Global variables are initialized automatically by the system
when you define them as follows:
Data Type Initializer
int 0
char '\0'
float 0
double 0
pointer NULL
It is a good programming practice to initialize variables properly, otherwise
sometimes program would produce unexpected result.
C++
24
Constants refer to fixed values that the program may not alter and they are
called literals.
Constants can be of any of the basic data types and can be divided into Integer
Numerals, Floating-Point Numerals, Characters, Strings and Boolean Values.
Again, constants are treated just like regular variables except that their values
cannot be modified after their definition.
Integer Literals
An integer literal can be a decimal, octal, or hexadecimal constant. A prefix
specifies the base or radix: 0x or 0X for hexadecimal, 0 for octal, and nothing for
decimal.
An integer literal can also have a suffix that is a combination of U and L, for
unsigned and long, respectively. The suffix can be uppercase or lowercase and
can be in any order.
Here are some examples of integer literals:
212 // Legal
215u // Legal
0xFeeL // Legal
078 // Illegal: 8 is not an octal digit
032UU // Illegal: cannot repeat a suffix
Following are other examples of various types of Integer literals:
85 // decimal
0213 // octal
0x4b // hexadecimal
30 // int
30u // unsigned int
30l // long
30ul // unsigned long
Floating-point Literals
A floating-point literal has an integer part, a decimal point, a fractional part, and
an exponent part. You can represent floating point literals either in decimal form
or exponential form.
8. CONSTANTS/LITERALS
C++
25
While representing using decimal form, you must include the decimal point, the
exponent, or both and while representing using exponential form, you must
include the integer part, the fractional part, or both. The signed exponent is
introduced by e or E.
Here are some examples of floating-point literals:
3.14159 // Legal
314159E-5L // Legal
510E // Illegal: incomplete exponent
210f // Illegal: no decimal or exponent
.e55 // Illegal: missing integer or fraction
Boolean Literals
There are two Boolean literals and they are part of standard C++ keywords:
 A value of true representing true.
 A value of false representing false.
You should not consider the value of true equal to 1 and value of false equal to
0.
Character Literals
Character literals are enclosed in single quotes. If the literal begins with L
(uppercase only), it is a wide character literal (e.g., L'x') and should be stored
in wchar_t type of variable. Otherwise, it is a narrow character literal (e.g., 'x')
and can be stored in a simple variable of char type.
A character literal can be a plain character (e.g., 'x'), an escape sequence (e.g.,
'\t'), or a universal character (e.g., '\u02C0').
There are certain characters in C++ when they are preceded by a backslash
they will have special meaning and they are used to represent like newline (\n)
or tab (\t). Here, you have a list of some of such escape sequence codes:
Escape sequence Meaning
\\ \ character
\' ' character
\" " character
\? ? character
C++
26
\a Alert or bell
\b Backspace
\f Form feed
\n Newline
\r Carriage return
\t Horizontal tab
\v Vertical tab
\ooo Octal number of one to three digits
\xhh . . . Hexadecimal number of one or more digits
Following is the example to show a few escape sequence characters:
#include &lt;iostream&gt;
using namespace std;
int main()
{
 cout &lt;&lt; "Hello\tWorld\n\n";
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Hello World
String Literals
String literals are enclosed in double quotes. A string contains characters that
are similar to character literals: plain characters, escape sequences, and
universal characters.
C++
27
You can break a long line into multiple lines using string literals and separate
them using whitespaces.
Here are some examples of string literals. All the three forms are identical
strings.
"hello, dear"
"hello, \
dear"
"hello, " "d" "ear"
Defining Constants
There are two simple ways in C++ to define constants:
 Using #define preprocessor.
 Using const keyword.
The #define Preprocessor
Following is the form to use #define preprocessor to define a constant:
#define identifier value
Following example explains it in detail:
#include &lt;iostream&gt;
using namespace std;
#define LENGTH 10
#define WIDTH 5
#define NEWLINE '\n'
int main()
{
 int area;

 area = LENGTH * WIDTH;
C++
28
 cout &lt;&lt; area;
 cout &lt;&lt; NEWLINE;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
50
The const Keyword
You can use const prefix to declare constants with a specific type as follows:
const type variable = value;
Following example explains it in detail:
#include &lt;iostream&gt;
using namespace std;
int main()
{
 const int LENGTH = 10;
 const int WIDTH = 5;
 const char NEWLINE = '\n';
 int area;

 area = LENGTH * WIDTH;
 cout &lt;&lt; area;
 cout &lt;&lt; NEWLINE;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
50
Note that it is a good programming practice to define constants in CAPITALS.
C++
29
C++ allows the char, int, and double data types to have modifiers preceding
them. A modifier is used to alter the meaning of the base type so that it more
precisely fits the needs of various situations.
The data type modifiers are listed here:
 signed
 unsigned
 long
 short
The modifiers signed, unsigned, long, and short can be applied to integer base
types. In addition, signed and unsigned can be applied to char, and long can
be applied to double.
The modifiers signed and unsigned can also be used as prefix
to long or short modifiers. For example, unsigned long int.
C++ allows a shorthand notation for declaring unsigned,
short, or long integers. You can simply use the word unsigned, short, or long,
without int. It automatically implies int. For example, the following two
statements both declare unsigned integer variables.
unsigned x;
unsigned int y;
To understand the difference between the way signed and unsigned integer
modifiers are interpreted by C++, you should run the following short program:
#include &lt;iostream&gt;
using namespace std;
/* This program shows the difference between
* signed and unsigned integers.
*/
int main()
{
 short int i; // a signed short integer
 short unsigned int j; // an unsigned short integer
9. MODIFIER TYPES
C++
30
 j = 50000;
 i = j;
 cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j;
 return 0;
}
When this program is run, following is the output:
-15536 50000
The above result is because the bit pattern that represents 50,000 as a short
unsigned integer is interpreted as -15,536 by a short.
Type Qualifiers in C++
The type qualifiers provide additional information about the variables they
precede.
Qualifier Meaning
const Objects of type const cannot be changed by your program during
execution
volatile The modifier volatile tells the compiler that a variable's value may
be changed in ways not explicitly specified by the program.
restrict A pointer qualified by restrict is initially the only means by which
the object it points to can be accessed. Only C99 adds a new type
qualifier called restrict.
C++
31
A storage class defines the scope (visibility) and life-time of variables and/or
functions within a C++ Program. These specifiers precede the type that they
modify. There are following storage classes, which can be used in a C++
Program
 auto
 register
 static
 extern
 mutable
The auto Storage Class
The auto storage class is the default storage class for all local variables.
{
 int mount;
 auto int month;
}
The example above defines two variables with the same storage class, auto can
only be used within functions, i.e., local variables.
The register Storage Class
The register storage class is used to define local variables that should be stored
in a register instead of RAM. This means that the variable has a maximum size
equal to the register size (usually one word) and can't have the unary '&amp;'
operator applied to it (as it does not have a memory location).
{
 register int miles;
}
The register should only be used for variables that require quick access such as
counters. It should also be noted that defining 'register' does not mean that the
variable will be stored in a register. It means that it MIGHT be stored in a
register depending on hardware and implementation restrictions.
The static Storage Class
10. STORAGE CLASSES
C++
32
The static storage class instructs the compiler to keep a local variable in
existence during the life-time of the program instead of creating and destroying
it each time it comes into and goes out of scope. Therefore, making local
variables static allows them to maintain their values between function calls.
The static modifier may also be applied to global variables. When this is done, it
causes that variable's scope to be restricted to the file in which it is declared.
In C++, when static is used on a class data member, it causes only one copy of
that member to be shared by all objects of its class.
#include &lt;iostream&gt;
// Function declaration
void func(void);
static int count = 10; /* Global variable */
main()
{
 while(count--)
 {
 func();
 }
 return 0;
}
// Function definition
void func( void )
{
 static int i = 5; // local static variable
 i++;
 std::cout &lt;&lt; "i is " &lt;&lt; i ;
 std::cout &lt;&lt; " and count is " &lt;&lt; count &lt;&lt; std::endl;
}
When the above code is compiled and executed, it produces the following result:
i is 6 and count is 9
i is 7 and count is 8
C++
33
i is 8 and count is 7
i is 9 and count is 6
i is 10 and count is 5
i is 11 and count is 4
i is 12 and count is 3
i is 13 and count is 2
i is 14 and count is 1
i is 15 and count is 0
The extern Storage Class
The extern storage class is used to give a reference of a global variable that is
visible to ALL the program files. When you use 'extern' the variable cannot be
initialized as all it does is point the variable name at a storage location that has
been previously defined.
When you have multiple files and you define a global variable or function, which
will be used in other files also, then extern will be used in another file to give
reference of defined variable or function. Just for understanding extern is used to
declare a global variable or function in another file.
The extern modifier is most commonly used when there are two or more files
sharing the same global variables or functions as explained below.
First File: main.cpp
#include &lt;iostream&gt;
int count ;
extern void write_extern();
main()
{
 count = 5;
 write_extern();
}
Second File: support.cpp
#include &lt;iostream&gt;
C++
34
extern int count;
void write_extern(void)
{
 std::cout &lt;&lt; "Count is " &lt;&lt; count &lt;&lt; std::endl;
}
Here, extern keyword is being used to declare count in another file. Now compile
these two files as follows:
$g++ main.cpp support.cpp -o write
This will produce write executable program, try to execute write and check the
result as follows:
$./write
5
The mutable Storage Class
The mutable specifier applies only to class objects, which are discussed later in
this tutorial. It allows a member of an object to override const member function.
That is, a mutable member can be modified by a const member function.
C++
35
An operator is a symbol that tells the compiler to perform specific mathematical
or logical manipulations. C++ is rich in built-in operators and provide the
following types of operators:
 Arithmetic Operators
 Relational Operators
 Logical Operators
 Bitwise Operators
 Assignment Operators
 Misc Operators
This chapter will examine the arithmetic, relational, logical, bitwise, assignment
and other operators one by one.
Arithmetic Operators
There are following arithmetic operators supported by C++ language:
Assume variable A holds 10 and variable B holds 20, then:
Operator Description Example
+ Adds two operands A + B will give 30
- Subtracts second operand from
the first
A - B will give -10
* Multiplies both operands A * B will give 200
/ Divides numerator by denumerator
B / A will give 2
% Modulus Operator and
remainder of after an integer
division
B % A will give 0
11. OPERATORS
C++
36
++ Increment operator, increases
integer value by one
A++ will give 11
-- Decrement operator, decreases
integer value by one
A-- will give 9
Try the following example to understand all the arithmetic operators available in
C++.
Copy and paste the following C++ program in test.cpp file and compile and run
this program.
#include &lt;iostream&gt;
using namespace std;
main()
{
 int a = 21;
 int b = 10;
 int c ;
 c = a + b;
 cout &lt;&lt; "Line 1 - Value of c is :" &lt;&lt; c &lt;&lt; endl ;
 c = a - b;
 cout &lt;&lt; "Line 2 - Value of c is :" &lt;&lt; c &lt;&lt; endl ;
 c = a * b;
 cout &lt;&lt; "Line 3 - Value of c is :" &lt;&lt; c &lt;&lt; endl ;
 c = a / b;
 cout &lt;&lt; "Line 4 - Value of c is :" &lt;&lt; c &lt;&lt; endl ;
 c = a % b;
 cout &lt;&lt; "Line 5 - Value of c is :" &lt;&lt; c &lt;&lt; endl ;
 c = a++;
 cout &lt;&lt; "Line 6 - Value of c is :" &lt;&lt; c &lt;&lt; endl ;
 c = a--;
 cout &lt;&lt; "Line 7 - Value of c is :" &lt;&lt; c &lt;&lt; endl ;
 return 0;
C++
37
}
When the above code is compiled and executed, it produces the following result:
Line 1 - Value of c is :31
Line 2 - Value of c is :11
Line 3 - Value of c is :210
Line 4 - Value of c is :2
Line 5 - Value of c is :1
Line 6 - Value of c is :21
Line 7 - Value of c is :22
Relational Operators
There are following relational operators supported by C++ language
Assume variable A holds 10 and variable B holds 20, then:
Operator Description Example
== Checks if the values of two
operands are equal or not, if
yes then condition becomes
true.
(A == B) is not true.
!= Checks if the values of two
operands are equal or not, if
values are not equal then
condition becomes true.
(A != B) is true.
&gt; Checks if the value of left
operand is greater than the
value of right operand, if yes
then condition becomes true.
(A &gt; B) is not true.
&lt; Checks if the value of left
operand is less than the value
of right operand, if yes then
condition becomes true.
(A &lt; B) is true.
&gt;= Checks if the value of left (A &gt;= B) is not true.
C++
38
operand is greater than or equal
to the value of right operand, if
yes then condition becomes
true.
&lt;= Checks if the value of left
operand is less than or equal to
the value of right operand, if
yes then condition becomes
true.
(A &lt;= B) is true.
Try the following example to understand all the relational operators available in
C++.
Copy and paste the following C++ program in test.cpp file and compile and run
this program.
#include &lt;iostream&gt;
using namespace std;
main()
{
 int a = 21;
 int b = 10;
 int c ;
 if( a == b )
 {
 cout &lt;&lt; "Line 1 - a is equal to b" &lt;&lt; endl ;
 }
 else
 {
 cout &lt;&lt; "Line 1 - a is not equal to b" &lt;&lt; endl ;
 }
 if ( a &lt; b )
 {
 cout &lt;&lt; "Line 2 - a is less than b" &lt;&lt; endl ;
C++
39
 }
 else
 {
 cout &lt;&lt; "Line 2 - a is not less than b" &lt;&lt; endl ;
 }
 if ( a &gt; b )
 {
 cout &lt;&lt; "Line 3 - a is greater than b" &lt;&lt; endl ;
 }
 else
 {
 cout &lt;&lt; "Line 3 - a is not greater than b" &lt;&lt; endl ;
 }
 /* Let's change the values of a and b */
 a = 5;
 b = 20;
 if ( a &lt;= b )
 {
 cout &lt;&lt; "Line 4 - a is either less than \
 or equal to b" &lt;&lt; endl ;
 }
 if ( b &gt;= a )
 {
 cout &lt;&lt; "Line 5 - b is either greater than \
 or equal to b" &lt;&lt; endl ;
 }
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Line 1 - a is not equal to b
Line 2 - a is not less than b
Line 3 - a is greater than b
Line 4 - a is either less than or equal to b
C++
40
Line 5 - b is either greater than or equal to b
Logical Operators
There are following logical operators supported by C++ language.
Assume variable A holds 1 and variable B holds 0, then:
Operator Description Example
&amp;&amp; Called Logical AND operator. If
both the operands are non-zero,
then condition becomes true.
(A &amp;&amp; B) is false.
|| Called Logical OR Operator. If
any of the two operands is nonzero, then condition becomes
true.
(A || B) is true.
! Called Logical NOT Operator.
Use to reverses the logical state
of its operand. If a condition is
true, then Logical NOT operator
will make false.
!(A &amp;&amp; B) is true.
Try the following example to understand all the logical operators available in
C++.
Copy and paste the following C++ program in test.cpp file and compile and run
this program.
#include &lt;iostream&gt;
using namespace std;
main()
{
 int a = 5;
 int b = 20;
 int c ;
C++
41
 if ( a &amp;&amp; b )
 {
 cout &lt;&lt; "Line 1 - Condition is true"&lt;&lt; endl ;
 }
 if ( a || b )
 {
 cout &lt;&lt; "Line 2 - Condition is true"&lt;&lt; endl ;
 }
 /* Let's change the values of a and b */
 a = 0;
 b = 10;
 if ( a &amp;&amp; b )
 {
 cout &lt;&lt; "Line 3 - Condition is true"&lt;&lt; endl ;
 }
 else
 {
 cout &lt;&lt; "Line 4 - Condition is not true"&lt;&lt; endl ;
 }
 if ( !(a &amp;&amp; b) )
 {
 cout &lt;&lt; "Line 5 - Condition is true"&lt;&lt; endl ;
 }
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Line 1 - Condition is true
Line 2 - Condition is true
Line 4 - Condition is not true
Line 5 - Condition is true
Bitwise Operators
C++
42
Bitwise operator works on bits and perform bit-by-bit operation. The truth tables
for &amp;, |, and ^ are as follows:
p q p &amp; q p | q p ^ q
0 0 0 0 0
0 1 0 1 1
1 1 1 1 0
1 0 0 1 1
Assume if A = 60; and B = 13; now in binary format they will be as follows:
A = 0011 1100
B = 0000 1101
-----------------
A&amp;B = 0000 1100
A|B = 0011 1101
A^B = 0011 0001
~A = 1100 0011
The Bitwise operators supported by C++ language are listed in the following
table. Assume variable A holds 60 and variable B holds 13, then:
Operator Description Example
&amp; Binary AND Operator copies a
bit to the result if it exists in
both operands.
(A &amp; B) will give 12 which is
0000 1100
| Binary OR Operator copies a bit
if it exists in either operand.
(A | B) will give 61 which is
0011 1101
^ Binary XOR Operator copies the
bit if it is set in one operand but
not both.
(A ^ B) will give 49 which is
0011 0001
C++
43
~ Binary Ones Complement
Operator is unary and has the
effect of 'flipping' bits.
(~A ) will give -61 which is
1100 0011 in 2's complement
form due to a signed binary
number.
&lt;&lt; Binary Left Shift Operator. The
left operands value is moved
left by the number of bits
specified by the right operand.
A &lt;&lt; 2 will give 240 which is
1111 0000
&gt;&gt; Binary Right Shift Operator. The
left operands value is moved
right by the number of bits
specified by the right operand.
A &gt;&gt; 2 will give 15 which is
0000 1111
Try the following example to understand all the bitwise operators available in
C++.
Copy and paste the following C++ program in test.cpp file and compile and run
this program.
#include &lt;iostream&gt;
using namespace std;
main()
{
 unsigned int a = 60; // 60 = 0011 1100
 unsigned int b = 13; // 13 = 0000 1101
 int c = 0;
 c = a &amp; b; // 12 = 0000 1100
 cout &lt;&lt; "Line 1 - Value of c is : " &lt;&lt; c &lt;&lt; endl ;
 c = a | b; // 61 = 0011 1101
 cout &lt;&lt; "Line 2 - Value of c is: " &lt;&lt; c &lt;&lt; endl ;
 c = a ^ b; // 49 = 0011 0001
 cout &lt;&lt; "Line 3 - Value of c is: " &lt;&lt; c &lt;&lt; endl ;
C++
44
 c = ~a; // -61 = 1100 0011
 cout &lt;&lt; "Line 4 - Value of c is: " &lt;&lt; c &lt;&lt; endl ;
 c = a &lt;&lt; 2; // 240 = 1111 0000
 cout &lt;&lt; "Line 5 - Value of c is: " &lt;&lt; c &lt;&lt; endl ;
 c = a &gt;&gt; 2; // 15 = 0000 1111
 cout &lt;&lt; "Line 6 - Value of c is: " &lt;&lt; c &lt;&lt; endl ;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Line 1 - Value of c is : 12
Line 2 - Value of c is: 61
Line 3 - Value of c is: 49
Line 4 - Value of c is: -61
Line 5 - Value of c is: 240
Line 6 - Value of c is: 15
Assignment Operators
There are following assignment operators supported by C++ language:
Operator Description Example
= Simple assignment operator,
Assigns values from right side
operands to left side operand.
C = A + B will assign value of A
+ B into C
+= Add AND assignment operator,
It adds right operand to the left
operand and assign the result to
left operand.
C += A is equivalent to C = C +
A
C++
45
-= Subtract AND assignment
operator, It subtracts right
operand from the left operand
and assign the result to left
operand.
C -= A is equivalent to C = C -
A
*= Multiply AND assignment
operator, It multiplies right
operand with the left operand
and assign the result to left
operand.
C *= A is equivalent to C = C *
A
/= Divide AND assignment
operator, It divides left operand
with the right operand and
assign the result to left
operand.
C /= A is equivalent to C = C /
A
%= Modulus AND assignment
operator, It takes modulus
using two operands and assign
the result to left operand.
C %= A is equivalent to C = C
% A
&lt;&lt;= Left shift AND assignment
operator.
C &lt;&lt;= 2 is same as C = C &lt;&lt; 2
&gt;&gt;= Right shift AND assignment
operator.
C &gt;&gt;= 2 is same as C = C &gt;&gt; 2
&amp;= Bitwise AND assignment
operator.
C &amp;= 2 is same as C = C &amp; 2
^= Bitwise exclusive OR and
assignment operator.
C ^= 2 is same as C = C ^ 2
|= Bitwise inclusive OR and
assignment operator.
C |= 2 is same as C = C | 2
Try the following example to understand all the assignment operators available
in C++.
C++
46
Copy and paste the following C++ program in test.cpp file and compile and run
this program.
#include &lt;iostream&gt;
using namespace std;
main()
{
 int a = 21;
 int c ;
 c = a;
 cout &lt;&lt; "Line 1 - = Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ;
 c += a;
 cout &lt;&lt; "Line 2 - += Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ;
 c -= a;
 cout &lt;&lt; "Line 3 - -= Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ;
 c *= a;
 cout &lt;&lt; "Line 4 - *= Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ;
 c /= a;
 cout &lt;&lt; "Line 5 - /= Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ;
 c = 200;
 c %= a;
 cout &lt;&lt; "Line 6 - %= Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ;
 c &lt;&lt;= 2;
 cout &lt;&lt; "Line 7 - &lt;&lt;= Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ;
 c &gt;&gt;= 2;
 cout &lt;&lt; "Line 8 - &gt;&gt;= Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ;
C++
47
 c &amp;= 2;
 cout &lt;&lt; "Line 9 - &amp;= Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ;
 c ^= 2;
 cout &lt;&lt; "Line 10 - ^= Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ;
 c |= 2;
 cout &lt;&lt; "Line 11 - |= Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Line 1 - = Operator, Value of c = : 21
Line 2 - += Operator, Value of c = : 42
Line 3 - -= Operator, Value of c = : 21
Line 4 - *= Operator, Value of c = : 441
Line 5 - /= Operator, Value of c = : 21
Line 6 - %= Operator, Value of c = : 11
Line 7 - &lt;&lt;= Operator, Value of c = : 44
Line 8 - &gt;&gt;= Operator, Value of c = : 11
Line 9 - &amp;= Operator, Value of c = : 2
Line 10 - ^= Operator, Value of c = : 0
Line 11 - |= Operator, Value of c = : 2
Misc Operators
The following table lists some other operators that C++ supports.
Operator Description
sizeof sizeof operator returns the size of a variable. For
example, sizeof(a), where ‘a’ is integer, and will return
4.
C++
48
Condition ? X : Y Conditional operator (?). If Condition is true then it
returns value of X otherwise returns value of Y.
, Comma operator causes a sequence of operations to
be performed. The value of the entire comma
expression is the value of the last expression of the
comma-separated list.
. (dot) and -&gt; (arrow) Member operators are used to reference individual
members of classes, structures, and unions.
Cast Casting operators convert one data type to another.
For example, int(2.2000) would return 2.
&amp; Pointer operator ‘&amp;’ returns the address of a variable.
For example &amp;a; will give actual address of the
variable.
* Pointer operator * is pointer to a variable. For example
*var; will pointer to a variable var.
Operators Precedence in C++
Operator precedence determines the grouping of terms in an expression. This
affects how an expression is evaluated. Certain operators have higher
precedence than others; for example, the multiplication operator has higher
precedence than the addition operator:
For example x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator *
has higher precedence than +, so it first gets multiplied with 3*2 and then adds
into 7.
Here, operators with the highest precedence appear at the top of the table,
those with the lowest appear at the bottom. Within an expression, higher
precedence operators will be evaluated first.
Category Operator Associativity
Postfix () [] -&gt; . ++ - - Left to right
Unary + - ! ~ ++ - - (type)* &amp; sizeof Right to left
Multiplicative * / % Left to right
C++
49
Additive + - Left to right
Shift &lt;&lt; &gt;&gt; Left to right
Relational &lt; &lt;= &gt; &gt;= Left to right
Equality == != Left to right
Bitwise AND &amp; Left to right
Bitwise XOR ^ Left to right
Bitwise OR | Left to right
Logical AND &amp;&amp; Left to right
Logical OR || Left to right
Conditional ?: Right to left
Assignment = += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |= Right to left
Comma , Left to right
Try the following example to understand operator’s precedence concept available
in C++. Copy and paste the following C++ program in test.cpp file and compile
and run this program.
Check the simple difference with and without parenthesis. This will produce
different results because (), /, * and + have different precedence. Higher
precedence operators will be evaluated first:
#include &lt;iostream&gt;
using namespace std;
main()
{
 int a = 20;
C++
50
 int b = 10;
 int c = 15;
 int d = 5;
 int e;
 e = (a + b) * c / d; // ( 30 * 15 ) / 5
 cout &lt;&lt; "Value of (a + b) * c / d is :" &lt;&lt; e &lt;&lt; endl ;
 e = ((a + b) * c) / d; // (30 * 15 ) / 5
 cout &lt;&lt; "Value of ((a + b) * c) / d is :" &lt;&lt; e &lt;&lt; endl ;
 e = (a + b) * (c / d); // (30) * (15/5)
 cout &lt;&lt; "Value of (a + b) * (c / d) is :" &lt;&lt; e &lt;&lt; endl ;
 e = a + (b * c) / d; // 20 + (150/5)
 cout &lt;&lt; "Value of a + (b * c) / d is :" &lt;&lt; e &lt;&lt; endl ;

 return 0;
}
When the above code is compiled and executed, it produces the following result:
Value of (a + b) * c / d is :90
Value of ((a + b) * c) / d is :90
Value of (a + b) * (c / d) is :90
Value of a + (b * c) / d is :50
C++
51
There may be a situation, when you need to execute a block of code several
number of times. In general, statements are executed sequentially: The first
statement in a function is executed first, followed by the second, and so on.
Programming languages provide various control structures that allow for more
complicated execution paths.
A loop statement allows us to execute a statement or group of statements
multiple times and following is the general from of a loop statement in most of
the programming languages:
C++ programming language provides the following type of loops to handle
looping requirements.
Loop Type Description
while loop Repeats a statement or group of statements while a
given condition is true. It tests the condition before
executing the loop body.
for loop Execute a sequence of statements multiple times and
abbreviates the code that manages the loop variable.
12. LOOP TYPES
C++
52
do...while loop Like a ‘while’ statement, except that it tests the
condition at the end of the loop body.
nested loops You can use one or more loop inside any another
‘while’, ‘for’ or ‘do..while’ loop.
While Loop
A while loop statement repeatedly executes a target statement as long as a
given condition is true.
Syntax
The syntax of a while loop in C++ is:
while(condition)
{
 statement(s);
}
Here, statement(s) may be a single statement or a block of statements.
The condition may be any expression, and true is any non-zero value. The loop
iterates while the condition is true.
When the condition becomes false, program control passes to the line
immediately following the loop.
Flow Diagram
C++
53
Here, key point of the while loop is that the loop might not ever run. When the
condition is tested and the result is false, the loop body will be skipped and the
first statement after the while loop will be executed.
Example
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 // Local variable declaration:
 int a = 10;
 // while loop execution
 while( a &lt; 20 )
 {
 cout &lt;&lt; "value of a: " &lt;&lt; a &lt;&lt; endl;
 a++;
 }
C++
54
 return 0;
}
When the above code is compiled and executed, it produces the following result:
value of a: 10
value of a: 11
value of a: 12
value of a: 13
value of a: 14
value of a: 15
value of a: 16
value of a: 17
value of a: 18
value of a: 19
for Loop
A for loop is a repetition control structure that allows you to efficiently write a
loop that needs to execute a specific number of times.
Syntax
The syntax of a for loop in C++ is:
for ( init; condition; increment )
{
 statement(s);
}
Here is the flow of control in a for loop:
1. The init step is executed first, and only once. This step allows you to
declare and initialize any loop control variables. You are not required to
put a statement here, as long as a semicolon appears.
2. Next, the condition is evaluated. If it is true, the body of the loop is
executed. If it is false, the body of the loop does not execute and flow of
control jumps to the next statement just after the for loop.
3. After the body of the for loop executes, the flow of control jumps back up
to the increment statement. This statement allows you to update any
C++
55
loop control variables. This statement can be left blank, as long as a
semicolon appears after the condition.
4. The condition is now evaluated again. If it is true, the loop executes and
the process repeats itself (body of loop, then increment step, and then
again condition). After the condition becomes false, the for loop
terminates.
Flow Diagram
Example
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 // for loop execution
 for( int a = 10; a &lt; 20; a = a + 1 )
C++
56
 {
 cout &lt;&lt; "value of a: " &lt;&lt; a &lt;&lt; endl;
 }
 return 0;
}
When the above code is compiled and executed, it produces the following result:
value of a: 10
value of a: 11
value of a: 12
value of a: 13
value of a: 14
value of a: 15
value of a: 16
value of a: 17
value of a: 18
value of a: 19
do…while Loop
Unlike for and while loops, which test the loop condition at the top of the loop,
the do...while loop checks its condition at the bottom of the loop.
A do...while loop is similar to a while loop, except that a do...while loop is
guaranteed to execute at least one time.
Syntax
The syntax of a do...while loop in C++ is:
do
{
 statement(s);
}while( condition );
Notice that the conditional expression appears at the end of the loop, so the
statement(s) in the loop execute once before the condition is tested.
C++
57
If the condition is true, the flow of control jumps back up to do, and the
statement(s) in the loop execute again. This process repeats until the given
condition becomes false.
Flow Diagram
Example
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 // Local variable declaration:
 int a = 10;
 // do loop execution
 do
 {
 cout &lt;&lt; "value of a: " &lt;&lt; a &lt;&lt; endl;
 a = a + 1;
 }while( a &lt; 20 );
 return 0;
C++
58
}
When the above code is compiled and executed, it produces the following result:
value of a: 10
value of a: 11
value of a: 12
value of a: 13
value of a: 14
value of a: 15
value of a: 16
value of a: 17
value of a: 18
value of a: 19
nested Loops
A loop can be nested inside of another loop. C++ allows at least 256 levels of
nesting.
Syntax
The syntax for a nested for loop statement in C++ is as follows:
for ( init; condition; increment )
{
 for ( init; condition; increment )
 {
 statement(s);
 }
 statement(s); // you can put more statements.
}
The syntax for a nested while loop statement in C++ is as follows:
while(condition)
{
 while(condition)
 {
 statement(s);
C++
59
 }
 statement(s); // you can put more statements.
}
The syntax for a nested do...while loop statement in C++ is as follows:
do
{
 statement(s); // you can put more statements.
 do
 {
 statement(s);
 }while( condition );
}while( condition );
Example
The following program uses a nested for loop to find the prime numbers from 2
to 100:
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 int i, j;

 for(i=2; i&lt;100; i++) {
 for(j=2; j &lt;= (i/j); j++)
 if(!(i%j)) break; // if factor found, not prime
 if(j &gt; (i/j)) cout &lt;&lt; i &lt;&lt; " is prime\n";
 }
 return 0;
}
This would produce the following result:
C++
60
2 is prime
3 is prime
5 is prime
7 is prime
11 is prime
13 is prime
17 is prime
19 is prime
23 is prime
29 is prime
31 is prime
37 is prime
41 is prime
43 is prime
47 is prime
53 is prime
59 is prime
61 is prime
67 is prime
71 is prime
73 is prime
79 is prime
83 is prime
89 is prime
97 is prime
Loop Control Statements
Loop control statements change execution from its normal sequence. When
execution leaves a scope, all automatic objects that were created in that scope
are destroyed.
C++ supports the following control statements.
Control Statement Description
break statement Terminates the loop or switch statement and
transfers execution to the statement immediately
C++
61
following the loop or switch.
continue statement Causes the loop to skip the remainder of its body and
immediately retest its condition prior to reiterating.
goto statement Transfers control to the labeled statement. Though it
is not advised to use goto statement in your program.
Break Statement
The break statement has the following two usages in C++:
 When the break statement is encountered inside a loop, the loop is
immediately terminated and program control resumes at the next
statement following the loop.
 It can be used to terminate a case in the switch statement (covered in
the next chapter).
If you are using nested loops (i.e., one loop inside another loop), the break
statement will stop the execution of the innermost loop and start executing the
next line of code after the block.
Syntax
The syntax of a break statement in C++ is:
break;
Flow Diagram
C++
62
Example
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 // Local variable declaration:
 int a = 10;
 // do loop execution
 do
 {
 cout &lt;&lt; "value of a: " &lt;&lt; a &lt;&lt; endl;
 a = a + 1;
 if( a &gt; 15)
 {
 // terminate the loop
 break;
 }
 }while( a &lt; 20 );
C++
63
 return 0;
}
When the above code is compiled and executed, it produces the following result:
value of a: prettyprint notranslate10
value of a: 11
value of a: 12
value of a: 13
value of a: 14
value of a: 15
continue Statement
The continue statement works somewhat like the break statement. Instead of
forcing termination, however, continue forces the next iteration of the loop to
take place, skipping any code in between.
For the for loop, continue causes the conditional test and increment portions of
the loop to execute. For the while and do...while loops, program control passes
to the conditional tests.
Syntax
The syntax of a continue statement in C++ is:
continue;
Flow Diagram
C++
64
Example
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 // Local variable declaration:
 int a = 10;
 // do loop execution
 do
 {
 if( a == 15)
 {
 // skip the iteration.
 a = a + 1;
 continue;
 }
 cout &lt;&lt; "value of a: " &lt;&lt; a &lt;&lt; endl;
 a = a + 1;
 }while( a &lt; 20 );
C++
65
 return 0;
}
When the above code is compiled and executed, it produces the following result:
value of a: 10
value of a: 11
value of a: 12
value of a: 13
value of a: 14
value of a: 16
value of a: 17
value of a: 18
value of a: 19
goto Statement
A goto statement provides an unconditional jump from the goto to a labeled
statement in the same function.
NOTE: Use of goto statement is highly discouraged because it makes difficult to
trace the control flow of a program, making the program hard to understand and
hard to modify. Any program that uses a goto can be rewritten so that it doesn't
need the goto.
Syntax
The syntax of a goto statement in C++ is:
goto label;
..
.
label: statement;
Where label is an identifier that identifies a labeled statement. A labeled
statement is any statement that is preceded by an identifier followed by a colon
(:).
Flow Diagram
C++
66
Example
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 // Local variable declaration:
 int a = 10;
 // do loop execution
 LOOP:do
 {
 if( a == 15)
 {
 // skip the iteration.
 a = a + 1;
 goto LOOP;
 }
 cout &lt;&lt; "value of a: " &lt;&lt; a &lt;&lt; endl;
 a = a + 1;
 }while( a &lt; 20 );
C++
67
 return 0;
}
When the above code is compiled and executed, it produces the following result:
value of a: 10
value of a: 11
value of a: 12
value of a: 13
value of a: 14
value of a: 16
value of a: 17
value of a: 18
value of a: 19
One good use of goto is to exit from a deeply nested routine. For example,
consider the following code fragment:
for(...) {
 for(...) {
 while(...) {
 if(...) goto stop;
 .
 .
 .
 }
 }
}
stop:
cout &lt;&lt; "Error in program.\n";
Eliminating the goto would force a number of additional tests to be performed. A
simplebreak statement would not work here, because it would only cause the
program to exit from the innermost loop.
The Infinite Loop
A loop becomes infinite loop if a condition never becomes false. The for loop is
traditionally used for this purpose. Since none of the three expressions that form
C++
68
the ‘for’ loop are required, you can make an endless loop by leaving the
conditional expression empty.
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 for( ; ; )
 {
 printf("This loop will run forever.\n");
 }
 return 0;
}
When the conditional expression is absent, it is assumed to be true. You may
have an initialization and increment expression, but C++ programmers more
commonly use the ‘for (;;)’ construct to signify an infinite loop.
NOTE: You can terminate an infinite loop by pressing Ctrl + C keys.
C++
69
Decision making structures require that the programmer specify one or more
conditions to be evaluated or tested by the program, along with a statement or
statements to be executed if the condition is determined to be true, and
optionally, other statements to be executed if the condition is determined to be
false.
Following is the general from of a typical decision making structure found in
most of the programming languages:
C++ programming language provides following types of decision making
statements.
Statement Description
if statement An ‘if’ statement consists of a boolean expression
followed by one or more statements.
if...else statement An ‘if’ statement can be followed by an optional
‘else’ statement, which executes when the boolean
expression is false.
switch statement A ‘switch’ statement allows a variable to be tested
13. DECISION-MAKING STATEMENTS
C++
70
for equality against a list of values.
nested if statements You can use one ‘if’ or ‘else if’ statement inside
another ‘if’ or ‘else if’ statement(s).
nested switch statements You can use one ‘switch’ statement inside another
‘switch’ statement(s).
If Statement
An if statement consists of a boolean expression followed by one or more
statements.
Syntax
The syntax of an if statement in C++ is:
if(boolean_expression)
{
 // statement(s) will execute if the boolean expression is true
}
If the boolean expression evaluates to true, then the block of code inside the if
statement will be executed. If boolean expression evaluates to false, then the
first set of code after the end of the if statement (after the closing curly brace)
will be executed.
Flow Diagram
C++
71
Example
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 // local variable declaration:
 int a = 10;
 // check the boolean condition
 if( a &lt; 20 )
 {
 // if condition is true then print the following
 cout &lt;&lt; "a is less than 20;" &lt;&lt; endl;
 }
 cout &lt;&lt; "value of a is : " &lt;&lt; a &lt;&lt; endl;
 return 0;
}
C++
72
When the above code is compiled and executed, it produces the following result:
a is less than 20;
value of a is : 10
if…else Statement
An if statement can be followed by an optional else statement, which executes
when the boolean expression is false.
Syntax
The syntax of an if...else statement in C++ is:
if(boolean_expression)
{
 // statement(s) will execute if the boolean expression is true
}
else
{
 // statement(s) will execute if the boolean expression is false
}
If the boolean expression evaluates to true, then the if block of code will be
executed, otherwise else block of code will be executed.
Flow Diagram
C++
73
Example
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 // local variable declaration:
 int a = 100;
 // check the boolean condition
 if( a &lt; 20 )
 {
 // if condition is true then print the following
 cout &lt;&lt; "a is less than 20;" &lt;&lt; endl;
 }
 else
 {
 // if condition is false then print the following
 cout &lt;&lt; "a is not less than 20;" &lt;&lt; endl;
 }
 cout &lt;&lt; "value of a is : " &lt;&lt; a &lt;&lt; endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
a is not less than 20;
value of a is : 100
if...else if...else Statement
An if statement can be followed by an optional else if...else statement, which is
very usefull to test various conditions using single if...else if statement.
When using if , else if , else statements there are few points to keep in mind.
 An if can have zero or one else's and it must come after any else if's.
C++
74
 An if can have zero to many else if's and they must come before the else.
 Once an else if succeeds, none of he remaining else if's or else's will be
tested.
Syntax
The syntax of an if...else if...else statement in C++ is:
if(boolean_expression 1)
{
 // Executes when the boolean expression 1 is true
}
else if( boolean_expression 2)
{
 // Executes when the boolean expression 2 is true
}
else if( boolean_expression 3)
{
 // Executes when the boolean expression 3 is true
}
else
{
 // executes when the none of the above condition is true.
}
Example
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 // local variable declaration:
 int a = 100;
 // check the boolean condition
 if( a == 10 )
C++
75
 {
 // if condition is true then print the following
 cout &lt;&lt; "Value of a is 10" &lt;&lt; endl;
 }
 else if( a == 20 )
 {
 // if else if condition is true
 cout &lt;&lt; "Value of a is 20" &lt;&lt; endl;
 }
 else if( a == 30 )
 {
 // if else if condition is true
 cout &lt;&lt; "Value of a is 30" &lt;&lt; endl;
 }
 else
 {
 // if none of the conditions is true
 cout &lt;&lt; "Value of a is not matching" &lt;&lt; endl;
 }
 cout &lt;&lt; "Exact value of a is : " &lt;&lt; a &lt;&lt; endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Value of a is not matching
Exact value of a is : 100
Switch Statement
A switch statement allows a variable to be tested for equality against a list of
values. Each value is called a case, and the variable being switched on is
checked for each case.
Syntax
The syntax for a switch statement in C++ is as follows:
C++
76
switch(expression){
 case constant-expression :
 statement(s);
 break; //optional
 case constant-expression :
 statement(s);
 break; //optional

 // you can have any number of case statements.
 default : //Optional
 statement(s);
}
The following rules apply to a switch statement:
 The expression used in a switch statement must have an integral or
enumerated type, or be of a class type in which the class has a single
conversion function to an integral or enumerated type.
 You can have any number of case statements within a switch. Each case is
followed by the value to be compared to and a colon.
 The constant-expression for a case must be the same data type as the
variable in the switch, and it must be a constant or a literal.
 When the variable being switched on is equal to a case, the statements
following that case will execute until a break statement is reached.
 When a break statement is reached, the switch terminates, and the flow
of control jumps to the next line following the switch statement.
 Not every case needs to contain a break. If no break appears, the flow of
control will fall through to subsequent cases until a break is reached.
 A switch statement can have an optional default case, which must
appear at the end of the switch. The default case can be used for
performing a task when none of the cases is true. No break is needed in
the default case.
Flow Diagram
C++
77
Example
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 // local variable declaration:
 char grade = 'D';
 switch(grade)
 {
 case 'A' :
 cout &lt;&lt; "Excellent!" &lt;&lt; endl;
 break;
 case 'B' :
 case 'C' :
 cout &lt;&lt; "Well done" &lt;&lt; endl;
 break;
C++
78
 case 'D' :
 cout &lt;&lt; "You passed" &lt;&lt; endl;
 break;
 case 'F' :
 cout &lt;&lt; "Better try again" &lt;&lt; endl;
 break;
 default :
 cout &lt;&lt; "Invalid grade" &lt;&lt; endl;
 }
 cout &lt;&lt; "Your grade is " &lt;&lt; grade &lt;&lt; endl;
 return 0;
}
This would produce the following result:
You passed
Your grade is D
Nested if Statement
It is always legal to nest if-else statements, which means you can use one if or
else if statement inside another if or else if statement(s).
Syntax
The syntax for a nested if statement is as follows:
if( boolean_expression 1)
{
 // Executes when the boolean expression 1 is true
 if(boolean_expression 2)
 {
 // Executes when the boolean expression 2 is true
 }
}
You can nest else if...else in the similar way as you have nested if statement.
C++
79
Example
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 // local variable declaration:
 int a = 100;
 int b = 200;
 // check the boolean condition
 if( a == 100 )
 {
 // if condition is true then check the following
 if( b == 200 )
 {
 // if condition is true then print the following
 cout &lt;&lt; "Value of a is 100 and b is 200" &lt;&lt; endl;
 }
 }
 cout &lt;&lt; "Exact value of a is : " &lt;&lt; a &lt;&lt; endl;
 cout &lt;&lt; "Exact value of b is : " &lt;&lt; b &lt;&lt; endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Value of a is 100 and b is 200
Exact value of a is : 100
Exact value of b is : 200
Nested switch Statements
It is possible to have a switch as part of the statement sequence of an outer
switch. Even if the case constants of the inner and outer switch contain common
values, no conflicts will arise.
C++
80
C++ specifies that at least 256 levels of nesting be allowed for switch
statements.
Syntax
The syntax for a nested switch statement is as follows:
switch(ch1) {
 case 'A':
 cout &lt;&lt; "This A is part of outer switch";
 switch(ch2) {
 case 'A':
 cout &lt;&lt; "This A is part of inner switch";
 break;
 case 'B': // ...
 }
 break;
 case 'B': // ...
}
Example
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 // local variable declaration:
 int a = 100;
 int b = 200;
 switch(a) {
 case 100:
 cout &lt;&lt; "This is part of outer switch" &lt;&lt; endl;
 switch(b) {
 case 200:
 cout &lt;&lt; "This is part of inner switch" &lt;&lt; endl;
C++
81
 }
 }
 cout &lt;&lt; "Exact value of a is : " &lt;&lt; a &lt;&lt; endl;
 cout &lt;&lt; "Exact value of b is : " &lt;&lt; b &lt;&lt; endl;
 return 0;
}
This would produce the following result:
This is part of outer switch
This is part of inner switch
Exact value of a is : 100
Exact value of b is : 200
The ? : Operator
We have covered conditional operator “? :” in previous chapter which can be
used to replace if...else statements. It has the following general form:
Exp1 ? Exp2 : Exp3;
Exp1, Exp2, and Exp3 are expressions. Notice the use and placement of the
colon.
The value of a ‘?’ expression is determined like this: Exp1 is evaluated. If it is
true, then Exp2 is evaluated and becomes the value of the entire ‘?’ expression.
If Exp1 is false, then Exp3 is evaluated and its value becomes the value of the
expression.
C++
82
A function is a group of statements that together perform a task. Every C++
program has at least one function, which is main(), and all the most trivial
programs can define additional functions.
You can divide up your code into separate functions. How you divide up your
code among different functions is up to you, but logically the division usually is
such that each function performs a specific task.
A function declaration tells the compiler about a function's name, return type,
and parameters. A function definition provides the actual body of the function.
The C++ standard library provides numerous built-in functions that your
program can call. For example, function strcat() to concatenate two strings,
function memcpy() to copy one memory location to another location, and many
more functions.
A function is known with various names like a method or a sub-routine or a
procedure etc.
Defining a Function
The general form of a C++ function definition is as follows:
return_type function_name( parameter list )
{
 body of the function
}
A C++ function definition consists of a function header and a function body.
Here are all the parts of a function:
 Return Type: A function may return a value. The return_type is the
data type of the value the function returns. Some functions perform the
desired operations without returning a value. In this case, the return_type
is the keyword void.
 Function Name: This is the actual name of the function. The function
name and the parameter list together constitute the function signature.
 Parameters: A parameter is like a placeholder. When a function is
invoked, you pass a value to the parameter. This value is referred to as
actual parameter or argument. The parameter list refers to the type,
order, and number of the parameters of a function. Parameters are
optional; that is, a function may contain no parameters.
14. FUNCTIONS
C++
83
 Function Body: The function body contains a collection of statements
that define what the function does.
Example:
Following is the source code for a function called max(). This function takes two
parameters num1 and num2 and returns the maximum between the two:
// function returning the max between two numbers
int max(int num1, int num2)
{
 // local variable declaration
 int result;
 if (num1 &gt; num2)
 result = num1;
 else
 result = num2;
 return result;
}
Function Declarations
A function declaration tells the compiler about a function name and how to call
the function. The actual body of the function can be defined separately.
A function declaration has the following parts:
return_type function_name( parameter list );
For the above defined function max(), following is the function declaration:
int max(int num1, int num2);
Parameter names are not important in function declaration only their type is
required, so following is also valid declaration:
int max(int, int);
Function declaration is required when you define a function in one source file
and you call that function in another file. In such case, you should declare the
function at the top of the file calling the function.
C++
84
Calling a Function
While creating a C++ function, you give a definition of what the function has to
do. To use a function, you will have to call or invoke that function.
When a program calls a function, program control is transferred to the called
function. A called function performs defined task and when it’s return statement
is executed or when its function-ending closing brace is reached, it returns
program control back to the main program.
To call a function, you simply need to pass the required parameters along with
function name, and if function returns a value, then you can store returned
value. For example:
#include &lt;iostream&gt;
using namespace std;
// function declaration
int max(int num1, int num2);
int main ()
{
 // local variable declaration:
 int a = 100;
 int b = 200;
 int ret;
 // calling a function to get max value.
 ret = max(a, b);
 cout &lt;&lt; "Max value is : " &lt;&lt; ret &lt;&lt; endl;
 return 0;
}
// function returning the max between two numbers
int max(int num1, int num2)
{
 // local variable declaration
C++
85
 int result;
 if (num1 &gt; num2)
 result = num1;
 else
 result = num2;
 return result;
}
I kept max() function along with main() function and compiled the source code.
While running final executable, it would produce the following result:
Max value is : 200
Function Arguments
If a function is to use arguments, it must declare variables that accept the
values of the arguments. These variables are called the formal parameters of
the function.
The formal parameters behave like other local variables inside the function and
are created upon entry into the function and destroyed upon exit.
While calling a function, there are two ways that arguments can be passed to a
function:
Call Type Description
Call by value This method copies the actual value of an argument
into the formal parameter of the function. In this case,
changes made to the parameter inside the function
have no effect on the argument.
Call by pointer This method copies the address of an argument into
the formal parameter. Inside the function, the address
is used to access the actual argument used in the call.
This means that changes made to the parameter
affect the argument.
Call by reference This method copies the reference of an argument into
the formal parameter. Inside the function, the
reference is used to access the actual argument used
C++
86
in the call. This means that changes made to the
parameter affect the argument.
Call by Value
The call by value method of passing arguments to a function copies the actual
value of an argument into the formal parameter of the function. In this case,
changes made to the parameter inside the function have no effect on the
argument.
By default, C++ uses call by value to pass arguments. In general, this means
that code within a function cannot alter the arguments used to call the function.
Consider the function swap() definition as follows.
// function definition to swap the values.
void swap(int x, int y)
{
 int temp;
 temp = x; /* save the value of x */
 x = y; /* put y into x */
 y = temp; /* put x into y */

 return;
}
Now, let us call the function swap() by passing actual values as in the following
example:
#include &lt;iostream&gt;
using namespace std;
// function declaration
void swap(int x, int y);
int main ()
{
 // local variable declaration:
 int a = 100;
C++
87
 int b = 200;
 cout &lt;&lt; "Before swap, value of a :" &lt;&lt; a &lt;&lt; endl;
 cout &lt;&lt; "Before swap, value of b :" &lt;&lt; b &lt;&lt; endl;
 // calling a function to swap the values.
 swap(a, b);
 cout &lt;&lt; "After swap, value of a :" &lt;&lt; a &lt;&lt; endl;
 cout &lt;&lt; "After swap, value of b :" &lt;&lt; b &lt;&lt; endl;
 return 0;
}
When the above code is put together in a file, compiled and executed, it
produces the following result:
Before swap, value of a :100
Before swap, value of b :200
After swap, value of a :100
After swap, value of b :200
Which shows that there is no change in the values though they had been
changed inside the function.
Call by Pointer
The call by pointer method of passing arguments to a function copies the
address of an argument into the formal parameter. Inside the function, the
address is used to access the actual argument used in the call. This means that
changes made to the parameter affect the passed argument.
To pass the value by pointer, argument pointers are passed to the functions just
like any other value. So accordingly you need to declare the function parameters
as pointer types as in the following function swap(), which exchanges the
values of the two integer variables pointed to by its arguments.
// function definition to swap the values.
void swap(int *x, int *y)
{
 int temp;
C++
88
 temp = *x; /* save the value at address x */
 *x = *y; /* put y into x */
 *y = temp; /* put x into y */

 return;
}
To check the more detail about C++ pointers, kindly check C++
Pointers chapter.
For now, let us call the function swap() by passing values by pointer as in the
following example:
#include &lt;iostream&gt;
using namespace std;
// function declaration
void swap(int *x, int *y);
int main ()
{
 // local variable declaration:
 int a = 100;
 int b = 200;
 cout &lt;&lt; "Before swap, value of a :" &lt;&lt; a &lt;&lt; endl;
 cout &lt;&lt; "Before swap, value of b :" &lt;&lt; b &lt;&lt; endl;
 /* calling a function to swap the values.
 * &amp;a indicates pointer to a ie. address of variable a and
 * &amp;b indicates pointer to b ie. address of variable b.
 */
 swap(&amp;a, &amp;b);
 cout &lt;&lt; "After swap, value of a :" &lt;&lt; a &lt;&lt; endl;
 cout &lt;&lt; "After swap, value of b :" &lt;&lt; b &lt;&lt; endl;
C++
89
 return 0;
}
When the above code is put together in a file, compiled and executed, it
produces the following result:
Before swap, value of a :100
Before swap, value of b :200
After swap, value of a :200
After swap, value of b :100
Call by Reference
The call by reference method of passing arguments to a function copies the
reference of an argument into the formal parameter. Inside the function, the
reference is used to access the actual argument used in the call. This means that
changes made to the parameter affect the passed argument.
To pass the value by reference, argument reference is passed to the functions
just like any other value. So accordingly you need to declare the function
parameters as reference types as in the following function swap(), which
exchanges the values of the two integer variables pointed to by its arguments.
// function definition to swap the values.
void swap(int &amp;x, int &amp;y)
{
 int temp;
 temp = x; /* save the value at address x */
 x = y; /* put y into x */
 y = temp; /* put x into y */

 return;
}
For now, let us call the function swap() by passing values by reference as in the
following example:
#include &lt;iostream&gt;
using namespace std;
// function declaration
void swap(int &amp;x, int &amp;y);
C++
90
int main ()
{
 // local variable declaration:
 int a = 100;
 int b = 200;
 cout &lt;&lt; "Before swap, value of a :" &lt;&lt; a &lt;&lt; endl;
 cout &lt;&lt; "Before swap, value of b :" &lt;&lt; b &lt;&lt; endl;
 /* calling a function to swap the values using variable reference.*/
 swap(a, b);
 cout &lt;&lt; "After swap, value of a :" &lt;&lt; a &lt;&lt; endl;
 cout &lt;&lt; "After swap, value of b :" &lt;&lt; b &lt;&lt; endl;
 return 0;
}
When the above code is put together in a file, compiled and executed, it
produces the following result:
Before swap, value of a :100
Before swap, value of b :200
After swap, value of a :200
After swap, value of b :100
By default, C++ uses call by value to pass arguments. In general, this means
that code within a function cannot alter the arguments used to call the function
and above mentioned example while calling max() function used the same
method.
Default Values for Parameters
When you define a function, you can specify a default value for each of the last
parameters. This value will be used if the corresponding argument is left blank
when calling to the function.
C++
91
This is done by using the assignment operator and assigning values for the
arguments in the function definition. If a value for that parameter is not passed
when the function is called, the default given value is used, but if a value is
specified, this default value is ignored and the passed value is used instead.
Consider the following example:
#include &lt;iostream&gt;
using namespace std;
int sum(int a, int b=20)
{
 int result;
 result = a + b;

 return (result);
}
int main ()
{
 // local variable declaration:
 int a = 100;
 int b = 200;
 int result;
 // calling a function to add the values.
 result = sum(a, b);
 cout &lt;&lt; "Total value is :" &lt;&lt; result &lt;&lt; endl;
 // calling a function again as follows.
 result = sum(a);
 cout &lt;&lt; "Total value is :" &lt;&lt; result &lt;&lt; endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
C++
92
Total value is :300
Total value is :120
C++
93
Normally, when we work with Numbers, we use primitive data types such as int,
short, long, float and double, etc. The number data types, their possible values
and number ranges have been explained while discussing C++ Data Types.
Defining Numbers in C++
You have already defined numbers in various examples given in previous
chapters. Here is another consolidated example to define various types of
numbers in C++:
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 // number definition:
 short s;
 int i;
 long l;
 float f;
 double d;

 // number assignments;
 s = 10;
 i = 1000;
 l = 1000000;
 f = 230.47;
 d = 30949.374;

 // number printing;
 cout &lt;&lt; "short s :" &lt;&lt; s &lt;&lt; endl;
 cout &lt;&lt; "int i :" &lt;&lt; i &lt;&lt; endl;
 cout &lt;&lt; "long l :" &lt;&lt; l &lt;&lt; endl;
 cout &lt;&lt; "float f :" &lt;&lt; f &lt;&lt; endl;
15. NUMBERS
C++
94
 cout &lt;&lt; "double d :" &lt;&lt; d &lt;&lt; endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
short s :10
int i :1000
long l :1000000
float f :230.47
double d :30949.4
Math Operations in C++
In addition to the various functions you can create, C++ also includes some
useful functions you can use. These functions are available in standard C and
C++ libraries and called built-in functions. These are functions that can be
included in your program and then use.
C++ has a rich set of mathematical operations, which can be performed on
various numbers. Following table lists down some useful built-in mathematical
functions available in C++.
To utilize these functions you need to include the math header file &lt;cmath&gt;.
S.N. Function &amp; Purpose
1 double cos(double);
This function takes an angle (as a double) and returns the cosine.
2 double sin(double);
This function takes an angle (as a double) and returns the sine.
3 double tan(double);
This function takes an angle (as a double) and returns the tangent.
4 double log(double);
This function takes a number and returns the natural log of that
number.
C++
95
5 double pow(double, double);
The first is a number you wish to raise and the second is the power you
wish to raise it t
6 double hypot(double, double);
If you pass this function the length of two sides of a right triangle, it will
return you the length of the hypotenuse.
7 double sqrt(double);
You pass this function a number and it gives you the square root.
8 int abs(int);
This function returns the absolute value of an integer that is passed to
it.
9 double fabs(double);
This function returns the absolute value of any decimal number passed
to it.
10 double floor(double);
Finds the integer which is less than or equal to the argument passed to
it.
Following is a simple example to show few of the mathematical operations:
#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;
int main ()
{
 // number definition:
 short s = 10;
 int i = -1000;
 long l = 100000;
 float f = 230.47;
C++
96
 double d = 200.374;
 // mathematical operations;
 cout &lt;&lt; "sin(d) :" &lt;&lt; sin(d) &lt;&lt; endl;
 cout &lt;&lt; "abs(i) :" &lt;&lt; abs(i) &lt;&lt; endl;
 cout &lt;&lt; "floor(d) :" &lt;&lt; floor(d) &lt;&lt; endl;
 cout &lt;&lt; "sqrt(f) :" &lt;&lt; sqrt(f) &lt;&lt; endl;
 cout &lt;&lt; "pow( d, 2) :" &lt;&lt; pow(d, 2) &lt;&lt; endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
sign(d) :-0.634939
abs(i) :1000
floor(d) :200
sqrt(f) :15.1812
pow( d, 2 ) :40149.7
Random Numbers in C++
There are many cases where you will wish to generate a random number. There
are actually two functions you will need to know about random number
generation. The first is rand(), this function will only return a pseudo random
number. The way to fix this is to first call the srand() function.
Following is a simple example to generate few random numbers. This example
makes use of time() function to get the number of seconds on your system
time, to randomly seed the rand() function:
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;
using namespace std;
int main ()
{
 int i,j;
C++
97
 // set the seed
 srand( (unsigned)time( NULL ) );
 /* generate 10 random numbers. */
 for( i = 0; i &lt; 10; i++ )
 {
 // generate actual random number
 j= rand();
 cout &lt;&lt;" Random Number : " &lt;&lt; j &lt;&lt; endl;
 }
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Random Number : 1748144778
Random Number : 630873888
Random Number : 2134540646
Random Number : 219404170
Random Number : 902129458
Random Number : 920445370
Random Number : 1319072661
Random Number : 257938873
Random Number : 1256201101
Random Number : 580322989
C++
98
C++ provides a data structure, the array, which stores a fixed-size sequential
collection of elements of the same type. An array is used to store a collection of
data, but it is often more useful to think of an array as a collection of variables
of the same type.
Instead of declaring individual variables, such as number0, number1, ..., and
number99, you declare one array variable such as numbers and use
numbers[0], numbers[1], and ..., numbers[99] to represent individual variables.
A specific element in an array is accessed by an index.
All arrays consist of contiguous memory locations. The lowest address
corresponds to the first element and the highest address to the last element.
Declaring Arrays
To declare an array in C++, the programmer specifies the type of the elements
and the number of elements required by an array as follows:
type arrayName [ arraySize ];
This is called a single-dimension array. The arraySize must be an integer
constant greater than zero and type can be any valid C++ data type. For
example, to declare a 10-element array called balance of type double, use this
statement:
double balance[10];
Initializing Arrays
You can initialize C++ array elements either one by one or using a single
statement as follows:
double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};
The number of values between braces { } cannot be larger than the number of
elements that we declare for the array between square brackets [ ]. Following is
an example to assign a single element of the array:
If you omit the size of the array, an array just big enough to hold the
initialization is created. Therefore, if you write:
double balance[] = {1000.0, 2.0, 3.4, 17.0, 50.0};
You will create exactly the same array as you did in the previous example.
16. ARRAYS
C++
99
balance[4] = 50.0;
The above statement assigns element number 5th in the array a value of 50.0.
Array with 4th index will be 5th, i.e., last element because all arrays have 0 as
the index of their first element which is also called base index. Following is the
pictorial representation of the same array we discussed above:
Accessing Array Elements
An element is accessed by indexing the array name. This is done by placing the
index of the element within square brackets after the name of the array. For
example:
double salary = balance[9];
The above statement will take 10th element from the array and assign the value
to salary variable. Following is an example, which will use all the abovementioned three concepts viz. declaration, assignment and accessing arrays:
#include &lt;iostream&gt;
using namespace std;
#include &lt;iomanip&gt;
using std::setw;
int main ()
{
 int n[ 10 ]; // n is an array of 10 integers
 // initialize elements of array n to 0
 for ( int i = 0; i &lt; 10; i++ )
 {
 n[ i ] = i + 100; // set element at location i to i + 100
 }
 cout &lt;&lt; "Element" &lt;&lt; setw( 13 ) &lt;&lt; "Value" &lt;&lt; endl;
 // output each array element's value
C++
100
 for ( int j = 0; j &lt; 10; j++ )
 {
 cout &lt;&lt; setw( 7 )&lt;&lt; j &lt;&lt; setw( 13 ) &lt;&lt; n[ j ] &lt;&lt; endl;
 }
 return 0;
}
This program makes use of setw() function to format the output. When the
above code is compiled and executed, it produces the following result:
Element Value
 0 100
 1 101
 2 102
 3 103
 4 104
 5 105
 6 106
 7 107
 8 108
 9 109
Arrays in C++
Arrays are important to C++ and should need lots of more detail. There are
following few important concepts, which should be clear to a C++ programmer:
Concept Description
Multi-dimensional arrays C++ supports multidimensional arrays. The
simplest form of the multidimensional array is
the two-dimensional array.
Pointer to an array You can generate a pointer to the first
element of an array by simply specifying the
array name, without any index.
Passing arrays to functions You can pass to the function a pointer to an
C++
101
array by specifying the array's name without
an index.
Return array from functions C++ allows a function to return an array.
Multi-dimensional Arrays
C++ allows multidimensional arrays. Here is the general form of a
multidimensional array declaration:
type name[size1][size2]...[sizeN];
For example, the following declaration creates a three dimensional 5 . 10 . 4
integer array:
int threedim[5][10][4];
Two-Dimensional Arrays
The simplest form of the multidimensional array is the two-dimensional array. A
two-dimensional array is, in essence, a list of one-dimensional arrays. To declare
a two-dimensional integer array of size x,y, you would write something as
follows:
type arrayName [ x ][ y ];
Where type can be any valid C++ data type and arrayName will be a valid C++
identifier.
A two-dimensional array can be think as a table, which will have x number of
rows and y number of columns. A 2-dimensional array a, which contains three
rows and four columns can be shown as below:
Thus, every element in array a is identified by an element name of the form a[ i
][ j ], where a is the name of the array, and i and j are the subscripts that
uniquely identify each element in a.
Initializing Two-Dimensional Arrays
C++
102
Multidimensioned arrays may be initialized by specifying bracketed values for
each row. Following is an array with 3 rows and each row have 4 columns.
int a[3][4] = {
{0, 1, 2, 3} , /* initializers for row indexed by 0 */
{4, 5, 6, 7} , /* initializers for row indexed by 1 */
{8, 9, 10, 11} /* initializers for row indexed by 2 */
};
The nested braces, which indicate the intended row, are optional. The following
initialization is equivalent to previous example:
int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
Accessing Two-Dimensional Array Elements
An element in 2-dimensional array is accessed by using the subscripts, i.e., row
index and column index of the array. For example:
int val = a[2][3];
The above statement will take 4th element from the 3rd row of the array. You
can verify it in the above digram.
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 // an array with 5 rows and 2 columns.
 int a[5][2] = { {0,0}, {1,2}, {2,4}, {3,6},{4,8}};
 // output each array element's value
 for ( int i = 0; i &lt; 5; i++ )
 for ( int j = 0; j &lt; 2; j++ )
 {
 cout &lt;&lt; "a[" &lt;&lt; i &lt;&lt; "][" &lt;&lt; j &lt;&lt; "]: ";
 cout &lt;&lt; a[i][j]&lt;&lt; endl;
 }
C++
103
 return 0;
}
When the above code is compiled and executed, it produces the following result:
a[0][0]: 0
a[0][1]: 0
a[1][0]: 1
a[1][1]: 2
a[2][0]: 2
a[2][1]: 4
a[3][0]: 3
a[3][1]: 6
a[4][0]: 4
a[4][1]: 8
As explained above, you can have arrays with any number of dimensions,
although it is likely that most of the arrays you create will be of one or two
dimensions.
Pointer to an Array
It is most likely that you would not understand this chapter until you go through
the chapter related C++ Pointers.
So assuming you have bit understanding on pointers in C++, let us start: An
array name is a constant pointer to the first element of the array. Therefore, in
the declaration:
double balance[50];
balance is a pointer to &amp;balance[0], which is the address of the first element of
the array balance. Thus, the following program fragment assigns p the address
of the first element ofbalance:
double *p;
double balance[10];
p = balance;
It is legal to use array names as constant pointers, and vice versa. Therefore,
*(balance + 4) is a legitimate way of accessing the data at balance[4].
C++
104
Once you store the address of first element in p, you can access array elements
using *p, *(p+1), *(p+2) and so on. Below is the example to show all the
concepts discussed above:
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 // an array with 5 elements.
 double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};
 double *p;
 p = balance;
 // output each array element's value
 cout &lt;&lt; "Array values using pointer " &lt;&lt; endl;
 for ( int i = 0; i &lt; 5; i++ )
 {
 cout &lt;&lt; "*(p + " &lt;&lt; i &lt;&lt; ") : ";
 cout &lt;&lt; *(p + i) &lt;&lt; endl;
 }
 cout &lt;&lt; "Array values using balance as address " &lt;&lt; endl;
 for ( int i = 0; i &lt; 5; i++ )
 {
 cout &lt;&lt; "*(balance + " &lt;&lt; i &lt;&lt; ") : ";
 cout &lt;&lt; *(balance + i) &lt;&lt; endl;
 }
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Array values using pointer
*(p + 0) : 1000
C++
105
*(p + 1) : 2
*(p + 2) : 3.4
*(p + 3) : 17
*(p + 4) : 50
Array values using balance as address
*(balance + 0) : 1000
*(balance + 1) : 2
*(balance + 2) : 3.4
*(balance + 3) : 17
*(balance + 4) : 50
In the above example, p is a pointer to double which means it can store address
of a variable of double type. Once we have address in p, then *p will give us
value available at the address stored in p, as we have shown in the above
example.
Passing Arrays to Functions
C++ does not allow to pass an entire array as an argument to a function.
However, You can pass a pointer to an array by specifying the array's name
without an index.
If you want to pass a single-dimension array as an argument in a function, you
would have to declare function formal parameter in one of following three ways
and all three declaration methods produce similar results because each tells the
compiler that an integer pointer is going to be received.
Way-1
Formal parameters as a pointer as follows:
void myFunction(int *param)
{
.
.
.
}
Way-2
Formal parameters as a sized array as follows:
void myFunction(int param[10])
C++
106
{
.
.
.
}
Way-3
Formal parameters as an unsized array as follows:
void myFunction(int param[])
{
.
.
.
}
Now, consider the following function, which will take an array as an argument
along with another argument and based on the passed arguments, it will return
average of the numbers passed through the array as follows:
double getAverage(int arr[], int size)
{
 int i, sum = 0;
 double avg;
 for (i = 0; i &lt; size; ++i)
 {
 sum += arr[i];
 }
 avg = double(sum) / size;
 return avg;
}
Now, let us call the above function as follows:
#include &lt;iostream&gt;
C++
107
using namespace std;
// function declaration:
double getAverage(int arr[], int size);
int main ()
{
 // an int array with 5 elements.
 int balance[5] = {1000, 2, 3, 17, 50};
 double avg;
 // pass pointer to the array as an argument.
 avg = getAverage( balance, 5 ) ;
 // output the returned value
 cout &lt;&lt; "Average value is: " &lt;&lt; avg &lt;&lt; endl;

 return 0;
}
When the above code is compiled together and executed, it produces the
following result:
Average value is: 214.4
As you can see, the length of the array doesn't matter as far as the function is
concerned because C++ performs no bounds checking for the formal
parameters.
Return Array from Functions
C++ does not allow to return an entire array as an argument to a function.
However, you can return a pointer to an array by specifying the array's name
without an index.
If you want to return a single-dimension array from a function, you would have
to declare a function returning a pointer as in the following example:
int * myFunction()
{
.
C++
108
.
.
}
Second point to remember is that C++ does not advocate to return the address
of a local variable to outside of the function so you would have to define the
local variable as staticvariable.
Now, consider the following function, which will generate 10 random numbers
and return them using an array and call this function as follows:
#include &lt;iostream&gt;
#include &lt;ctime&gt;
using namespace std;
// function to generate and retrun random numbers.
int * getRandom( )
{
 static int r[10];
 // set the seed
 srand( (unsigned)time( NULL ) );
 for (int i = 0; i &lt; 10; ++i)
 {
 r[i] = rand();
 cout &lt;&lt; r[i] &lt;&lt; endl;
 }
 return r;
}
// main function to call above defined function.
int main ()
{
 // a pointer to an int.
 int *p;
C++
109
 p = getRandom();
 for ( int i = 0; i &lt; 10; i++ )
 {
 cout &lt;&lt; "*(p + " &lt;&lt; i &lt;&lt; ") : ";
 cout &lt;&lt; *(p + i) &lt;&lt; endl;
 }
 return 0;
}
When the above code is compiled together and executed, it produces result
something as follows:
624723190
1468735695
807113585
976495677
613357504
1377296355
1530315259
1778906708
1820354158
667126415
*(p + 0) : 624723190
*(p + 1) : 1468735695
*(p + 2) : 807113585
*(p + 3) : 976495677
*(p + 4) : 613357504
*(p + 5) : 1377296355
*(p + 6) : 1530315259
*(p + 7) : 1778906708
*(p + 8) : 1820354158
*(p + 9) : 667126415
C++
110
C++
111
C++ provides following two types of string representations:
 The C-style character string.
 The string class type introduced with Standard C++.
The C-Style Character String
The C-style character string originated within the C language and continues to
be supported within C++. This string is actually a one-dimensional array of
characters which is terminated by a null character '\0'. Thus a null-terminated
string contains the characters that comprise the string followed by a null.
The following declaration and initialization create a string consisting of the word
"Hello". To hold the null character at the end of the array, the size of the
character array containing the string is one more than the number of characters
in the word "Hello."
char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
If you follow the rule of array initialization, then you can write the above
statement as follows:
char greeting[] = "Hello";
Following is the memory presentation of above defined string in C/C++:
Actually, you do not place the null character at the end of a string constant. The
C++ compiler automatically places the '\0' at the end of the string when it
initializes the array. Let us try to print above-mentioned string:
#include &lt;iostream&gt;
using namespace std;
17. STRINGS
C++
112
int main ()
{
 char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
 cout &lt;&lt; "Greeting message: ";
 cout &lt;&lt; greeting &lt;&lt; endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Greeting message: Hello
C++ supports a wide range of functions that manipulate null-terminated strings:
S.N. Function &amp; Purpose
1 strcpy(s1, s2);
Copies string s2 into string s1.
2 strcat(s1, s2);
Concatenates string s2 onto the end of string s1.
3 strlen(s1);
Returns the length of string s1.
4 strcmp(s1, s2);
Returns 0 if s1 and s2 are the same; less than 0 if s1&lt;s2; greater than
0 if s1&gt;s2.
5 strchr(s1, ch);
Returns a pointer to the first occurrence of character ch in string s1.
6 strstr(s1, s2);
C++
113
Returns a pointer to the first occurrence of string s2 in string s1.
Following example makes use of few of the above-mentioned functions:
#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;
int main ()
{
 char str1[10] = "Hello";
 char str2[10] = "World";
 char str3[10];
 int len ;
 // copy str1 into str3
 strcpy( str3, str1);
 cout &lt;&lt; "strcpy( str3, str1) : " &lt;&lt; str3 &lt;&lt; endl;
 // concatenates str1 and str2
 strcat( str1, str2);
 cout &lt;&lt; "strcat( str1, str2): " &lt;&lt; str1 &lt;&lt; endl;
 // total lenghth of str1 after concatenation
 len = strlen(str1);
 cout &lt;&lt; "strlen(str1) : " &lt;&lt; len &lt;&lt; endl;
 return 0;
}
When the above code is compiled and executed, it produces result something as
follows:
strcpy( str3, str1) : Hello
C++
114
strcat( str1, str2): HelloWorld
strlen(str1) : 10
The String Class in C++
The standard C++ library provides a string class type that supports all the
operations mentioned above, additionally much more functionality. Let us check
the following example:
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main ()
{
 string str1 = "Hello";
 string str2 = "World";
 string str3;
 int len ;
 // copy str1 into str3
 str3 = str1;
 cout &lt;&lt; "str3 : " &lt;&lt; str3 &lt;&lt; endl;
 // concatenates str1 and str2
 str3 = str1 + str2;
 cout &lt;&lt; "str1 + str2 : " &lt;&lt; str3 &lt;&lt; endl;
 // total length of str3 after concatenation
 len = str3.size();
 cout &lt;&lt; "str3.size() : " &lt;&lt; len &lt;&lt; endl;
 return 0;
}
When the above code is compiled and executed, it produces result something as
follows:
C++
115
str3 : Hello
str1 + str2 : HelloWorld
str3.size() : 10
C++
116
C++ pointers are easy and fun to learn. Some C++ tasks are performed more
easily with pointers, and other C++ tasks, such as dynamic memory allocation,
cannot be performed without them.
As you know every variable is a memory location and every memory location
has its address defined which can be accessed using ampersand (&amp;) operator
which denotes an address in memory. Consider the following which will print the
address of the variables defined:
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 int var1;
 char var2[10];
 cout &lt;&lt; "Address of var1 variable: ";
 cout &lt;&lt; &amp;var1 &lt;&lt; endl;
 cout &lt;&lt; "Address of var2 variable: ";
 cout &lt;&lt; &amp;var2 &lt;&lt; endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Address of var1 variable: 0xbfebd5c0
Address of var2 variable: 0xbfebd5b6
What are Pointers?
A pointer is a variable whose value is the address of another variable. Like any
variable or constant, you must declare a pointer before you can work with it. The
general form of a pointer variable declaration is:
18. POINTERS
C++
117
type *var-name;
Here, type is the pointer's base type; it must be a valid C++ type and varname is the name of the pointer variable. The asterisk you used to declare a
pointer is the same asterisk that you use for multiplication. However, in this
statement the asterisk is being used to designate a variable as a pointer.
Following are the valid pointer declaration:
int *ip; // pointer to an integer
double *dp; // pointer to a double
float *fp; // pointer to a float
char *ch // pointer to character
The actual data type of the value of all pointers, whether integer, float,
character, or otherwise, is the same, a long hexadecimal number that represents
a memory address. The only difference between pointers of different data types
is the data type of the variable or constant that the pointer points to.
Using Pointers in C++
There are few important operations, which we will do with the pointers very
frequently. (a) We define a pointer variable. (b) Assign the address of a variable
to a pointer. (c) Finally access the value at the address available in the pointer
variable. This is done by using unary operator * that returns the value of the
variable located at the address specified by its operand. Following example
makes use of these operations:
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 int var = 20; // actual variable declaration.
 int *ip; // pointer variable
 ip = &amp;var; // store address of var in pointer variable
 cout &lt;&lt; "Value of var variable: ";
 cout &lt;&lt; var &lt;&lt; endl;
C++
118
 // print the address stored in ip pointer variable
 cout &lt;&lt; "Address stored in ip variable: ";
 cout &lt;&lt; ip &lt;&lt; endl;
 // access the value at the address available in pointer
 cout &lt;&lt; "Value of *ip variable: ";
 cout &lt;&lt; *ip &lt;&lt; endl;
 return 0;
}
When the above code is compiled and executed, it produces result something as
follows:
Value of var variable: 20
Address stored in ip variable: 0xbfc601ac
Value of *ip variable: 20
Pointers in C++
Pointers have many but easy concepts and they are very important to C++
programming. There are following few important pointer concepts which should
be clear to a C++ programmer:
Concept Description
C++ Null Pointers C++ supports null pointer, which is a constant
with a value of zero defined in several
standard libraries.
C++ pointer arithmetic There are four arithmetic operators that can
be used on pointers: ++, --, +, -
C++ pointers vs arrays There is a close relationship between pointers
and arrays.
C++ array of pointers You can define arrays to hold a number of
pointers.
C++ pointer to pointer C++ allows you to have pointer on a pointer
C++
119
and so on.
Passing pointers to functions Passing an argument by reference or by
address both enable the passed argument to
be changed in the calling function by the
called function.
Return pointer from functions C++ allows a function to return a pointer to
local variable, static variable and dynamically
allocated memory as well.
Null Pointers
It is always a good practice to assign the pointer NULL to a pointer variable in
case you do not have exact address to be assigned. This is done at the time of
variable declaration. A pointer that is assigned NULL is called a null pointer.
The NULL pointer is a constant with a value of zero defined in several standard
libraries, including iostream. Consider the following program:
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 int *ptr = NULL;
 cout &lt;&lt; "The value of ptr is " &lt;&lt; ptr ;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
The value of ptr is 0
On most of the operating systems, programs are not permitted to access
memory at address 0 because that memory is reserved by the operating system.
However, the memory address 0 has special significance; it signals that the
pointer is not intended to point to an accessible memory location. But by
C++
120
convention, if a pointer contains the null (zero) value, it is assumed to point to
nothing.
To check for a null pointer you can use an if statement as follows:
if(ptr) // succeeds if p is not null
if(!ptr) // succeeds if p is null
Thus, if all unused pointers are given the null value and you avoid the use of a
null pointer, you can avoid the accidental misuse of an uninitialized pointer.
Many times, uninitialized variables hold some junk values and it becomes
difficult to debug the program.
Pointer Arithmetic
As you understood pointer is an address which is a numeric value; therefore,
you can perform arithmetic operations on a pointer just as you can a numeric
value. There are four arithmetic operators that can be used on pointers: ++, --,
+, and -
To understand pointer arithmetic, let us consider that ptr is an integer pointer
which points to the address 1000. Assuming 32-bit integers, let us perform the
following arithmatic operation on the pointer:
ptr++
the ptr will point to the location 1004 because each time ptr is incremented, it
will point to the next integer. This operation will move the pointer to next
memory location without impacting actual value at the memory location. If ptr
points to a character whose address is 1000, then above operation will point to
the location 1001 because next character will be available at 1001.
Incrementing a Pointer
We prefer using a pointer in our program instead of an array because the
variable pointer can be incremented, unlike the array name which cannot be
incremented because it is a constant pointer. The following program increments
the variable pointer to access each succeeding element of the array:
#include &lt;iostream&gt;
using namespace std;
const int MAX = 3;
int main ()
{
 int var[MAX] = {10, 100, 200};
C++
121
 int *ptr;
 // let us have array address in pointer.
 ptr = var;
 for (int i = 0; i &lt; MAX; i++)
 {
 cout &lt;&lt; "Address of var[" &lt;&lt; i &lt;&lt; "] = ";
 cout &lt;&lt; ptr &lt;&lt; endl;
 cout &lt;&lt; "Value of var[" &lt;&lt; i &lt;&lt; "] = ";
 cout &lt;&lt; *ptr &lt;&lt; endl;
 // point to the next location
 ptr++;
 }
 return 0;
}
When the above code is compiled and executed, it produces result something as
follows:
Address of var[0] = 0xbfa088b0
Value of var[0] = 10
Address of var[1] = 0xbfa088b4
Value of var[1] = 100
Address of var[2] = 0xbfa088b8
Value of var[2] = 200
Decrementing a Pointer
The same considerations apply to decrementing a pointer, which decreases its
value by the number of bytes of its data type as shown below:
#include &lt;iostream&gt;
using namespace std;
const int MAX = 3;
C++
122
int main ()
{
 int var[MAX] = {10, 100, 200};
 int *ptr;
 // let us have address of the last element in pointer.
 ptr = &amp;var[MAX-1];
 for (int i = MAX; i &gt; 0; i--)
 {
 cout &lt;&lt; "Address of var[" &lt;&lt; i &lt;&lt; "] = ";
 cout &lt;&lt; ptr &lt;&lt; endl;
 cout &lt;&lt; "Value of var[" &lt;&lt; i &lt;&lt; "] = ";
 cout &lt;&lt; *ptr &lt;&lt; endl;
 // point to the previous location
 ptr--;
 }
 return 0;
}
When the above code is compiled and executed, it produces result something as
follows:
Address of var[3] = 0xbfdb70f8
Value of var[3] = 200
Address of var[2] = 0xbfdb70f4
Value of var[2] = 100
Address of var[1] = 0xbfdb70f0
Value of var[1] = 10
Pointer Comparisons
Pointers may be compared by using relational operators, such as ==, &lt;, and &gt;.
If p1 and p2 point to variables that are related to each other, such as elements
of the same array, then p1 and p2 can be meaningfully compared.
C++
123
The following program modifies the previous example one by incrementing the
variable pointer so long as the address to which it points is either less than or
equal to the address of the last element of the array, which is &amp;var[MAX - 1]:
#include &lt;iostream&gt;
using namespace std;
const int MAX = 3;
int main ()
{
 int var[MAX] = {10, 100, 200};
 int *ptr;
 // let us have address of the first element in pointer.
 ptr = var;
 int i = 0;
 while ( ptr &lt;= &amp;var[MAX - 1] )
 {
 cout &lt;&lt; "Address of var[" &lt;&lt; i &lt;&lt; "] = ";
 cout &lt;&lt; ptr &lt;&lt; endl;
 cout &lt;&lt; "Value of var[" &lt;&lt; i &lt;&lt; "] = ";
 cout &lt;&lt; *ptr &lt;&lt; endl;
 // point to the previous location
 ptr++;
 i++;
 }
 return 0;
}
When the above code is compiled and executed, it produces result something as
follows:
Address of var[0] = 0xbfce42d0
Value of var[0] = 10
C++
124
Address of var[1] = 0xbfce42d4
Value of var[1] = 100
Address of var[2] = 0xbfce42d8
Value of var[2] = 200
Pointers vs Arrays
Pointers and arrays are strongly related. In fact, pointers and arrays are
interchangeable in many cases. For example, a pointer that points to the
beginning of an array can access that array by using either pointer arithmetic or
array-style indexing. Consider the following program:
#include &lt;iostream&gt;
using namespace std;
const int MAX = 3;
int main ()
{
 int var[MAX] = {10, 100, 200};
 int *ptr;
 // let us have array address in pointer.
 ptr = var;
 for (int i = 0; i &lt; MAX; i++)
 {
 cout &lt;&lt; "Address of var[" &lt;&lt; i &lt;&lt; "] = ";
 cout &lt;&lt; ptr &lt;&lt; endl;
 cout &lt;&lt; "Value of var[" &lt;&lt; i &lt;&lt; "] = ";
 cout &lt;&lt; *ptr &lt;&lt; endl;
 // point to the next location
 ptr++;
 }
 return 0;
}
C++
125
When the above code is compiled and executed, it produces result something as
follows:
Address of var[0] = 0xbfa088b0
Value of var[0] = 10
Address of var[1] = 0xbfa088b4
Value of var[1] = 100
Address of var[2] = 0xbfa088b8
Value of var[2] = 200
However, pointers and arrays are not completely interchangeable. For example,
consider the following program:
#include &lt;iostream&gt;
using namespace std;
const int MAX = 3;
int main ()
{
 int var[MAX] = {10, 100, 200};
 for (int i = 0; i &lt; MAX; i++)
 {
 *var = i; // This is a correct syntax
 var++; // This is incorrect.
 }
 return 0;
}
It is perfectly acceptable to apply the pointer operator * to var but it is illegal to
modify var value. The reason for this is that var is a constant that points to the
beginning of an array and can not be used as l-value.
Because an array name generates a pointer constant, it can still be used in
pointer-style expressions, as long as it is not modified. For example, the
following is a valid statement that assigns var[2] the value 500:
*(var + 2) = 500;
C++
126
Above statement is valid and will compile successfully because var is not
changed.
Array of Pointers
Before we understand the concept of array of pointers, let us consider the
following example, which makes use of an array of 3 integers:
#include &lt;iostream&gt;
using namespace std;
const int MAX = 3;
int main ()
{
 int var[MAX] = {10, 100, 200};
 for (int i = 0; i &lt; MAX; i++)
 {
 cout &lt;&lt; "Value of var[" &lt;&lt; i &lt;&lt; "] = ";
 cout &lt;&lt; var[i] &lt;&lt; endl;
 }
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Value of var[0] = 10
Value of var[1] = 100
Value of var[2] = 200
There may be a situation, when we want to maintain an array, which can store
pointers to an int or char or any other data type available. Following is the
declaration of an array of pointers to an integer:
int *ptr[MAX];
This declares ptr as an array of MAX integer pointers. Thus, each element in ptr,
now holds a pointer to an int value. Following example makes use of three
integers which will be stored in an array of pointers as follows:
#include &lt;iostream&gt;
C++
127
using namespace std;
const int MAX = 3;
int main ()
{
 int var[MAX] = {10, 100, 200};
 int *ptr[MAX];
 for (int i = 0; i &lt; MAX; i++)
 {
 ptr[i] = &amp;var[i]; // assign the address of integer.
 }
 for (int i = 0; i &lt; MAX; i++)
 {
 cout &lt;&lt; "Value of var[" &lt;&lt; i &lt;&lt; "] = ";
 cout &lt;&lt; *ptr[i] &lt;&lt; endl;
 }
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Value of var[0] = 10
Value of var[1] = 100
Value of var[2] = 200
You can also use an array of pointers to character to store a list of strings as
follows:
#include &lt;iostream&gt;
using namespace std;
const int MAX = 4;
int main ()
{
C++
128
 char *names[MAX] = {
 "Zara Ali",
 "Hina Ali",
 "Nuha Ali",
 "Sara Ali",
 };
 for (int i = 0; i &lt; MAX; i++)
 {
 cout &lt;&lt; "Value of names[" &lt;&lt; i &lt;&lt; "] = ";
 cout &lt;&lt; names[i] &lt;&lt; endl;
 }
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Value of names[0] = Zara Ali
Value of names[1] = Hina Ali
Value of names[2] = Nuha Ali
Value of names[3] = Sara Ali
Pointer to a Pointer
A pointer to a pointer is a form of multiple indirection or a chain of pointers.
Normally, a pointer contains the address of a variable. When we define a pointer
to a pointer, the first pointer contains the address of the second pointer, which
points to the location that contains the actual value as shown below.
A variable that is a pointer to a pointer must be declared as such. This is done
by placing an additional asterisk in front of its name. For example, following is
the declaration to declare a pointer to a pointer of type int:
int **var;
C++
129
When a target value is indirectly pointed to by a pointer to a pointer, accessing
that value requires that the asterisk operator be applied twice, as is shown
below in the example:
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 int var;
 int *ptr;
 int **pptr;
 var = 3000;
 // take the address of var
 ptr = &amp;var;
 // take the address of ptr using address of operator &amp;
 pptr = &amp;ptr;
 // take the value using pptr
 cout &lt;&lt; "Value of var :" &lt;&lt; var &lt;&lt; endl;
 cout &lt;&lt; "Value available at *ptr :" &lt;&lt; *ptr &lt;&lt; endl;
 cout &lt;&lt; "Value available at **pptr :" &lt;&lt; **pptr &lt;&lt; endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Value of var :3000
Value available at *ptr :3000
Value available at **pptr :3000
C++
130
Passing Pointers to Functions
C++ allows you to pass a pointer to a function. To do so, simply declare the
function parameter as a pointer type.
Following a simple example where we pass an unsigned long pointer to a
function and change the value inside the function which reflects back in the
calling function:
#include &lt;iostream&gt;
#include &lt;ctime&gt;
using namespace std;
void getSeconds(unsigned long *par);
int main ()
{
 unsigned long sec;
 getSeconds( &amp;sec );
 // print the actual value
 cout &lt;&lt; "Number of seconds :" &lt;&lt; sec &lt;&lt; endl;
 return 0;
}
void getSeconds(unsigned long *par)
{
 // get the current number of seconds
 *par = time( NULL );
 return;
}
When the above code is compiled and executed, it produces the following result:
Number of seconds :1294450468
C++
131
The function which can accept a pointer, can also accept an array as shown in
the following example:
#include &lt;iostream&gt;
using namespace std;
// function declaration:
double getAverage(int *arr, int size);
int main ()
{
 // an int array with 5 elements.
 int balance[5] = {1000, 2, 3, 17, 50};
 double avg;
 // pass pointer to the array as an argument.
 avg = getAverage( balance, 5 ) ;
 // output the returned value
 cout &lt;&lt; "Average value is: " &lt;&lt; avg &lt;&lt; endl;

 return 0;
}
double getAverage(int *arr, int size)
{
 int i, sum = 0;
 double avg;
 for (i = 0; i &lt; size; ++i)
 {
 sum += arr[i];
 }
 avg = double(sum) / size;
C++
132
 return avg;
}
When the above code is compiled together and executed, it produces the
following result:
Average value is: 214.4
Return Pointer from Functions
As we have seen in last chapter how C++ allows to return an array from a
function, similar way C++ allows you to return a pointer from a function. To do
so, you would have to declare a function returning a pointer as in the following
example:
int * myFunction()
{
.
.
.
}
Second point to remember is that, it is not good idea to return the address of a
local variable to outside of the function, so you would have to define the local
variable as staticvariable.
Now, consider the following function, which will generate 10 random numbers
and return them using an array name which represents a pointer i.e., address of
first array element.
#include &lt;iostream&gt;
#include &lt;ctime&gt;
using namespace std;
// function to generate and retrun random numbers.
int * getRandom( )
{
 static int r[10];
C++
133
 // set the seed
 srand( (unsigned)time( NULL ) );
 for (int i = 0; i &lt; 10; ++i)
 {
 r[i] = rand();
 cout &lt;&lt; r[i] &lt;&lt; endl;
 }
 return r;
}
// main function to call above defined function.
int main ()
{
 // a pointer to an int.
 int *p;
 p = getRandom();
 for ( int i = 0; i &lt; 10; i++ )
 {
 cout &lt;&lt; "*(p + " &lt;&lt; i &lt;&lt; ") : ";
 cout &lt;&lt; *(p + i) &lt;&lt; endl;
 }
 return 0;
}
When the above code is compiled together and executed, it produces result
something as follows:
624723190
1468735695
807113585
976495677
C++
134
613357504
1377296355
1530315259
1778906708
1820354158
667126415
*(p + 0) : 624723190
*(p + 1) : 1468735695
*(p + 2) : 807113585
*(p + 3) : 976495677
*(p + 4) : 613357504
*(p + 5) : 1377296355
*(p + 6) : 1530315259
*(p + 7) : 1778906708
*(p + 8) : 1820354158
*(p + 9) : 667126415
C++
135
A reference variable is an alias, that is, another name for an already existing
variable. Once a reference is initialized with a variable, either the variable name
or the reference name may be used to refer to the variable.
References vs Pointers
References are often confused with pointers but three major differences between
references and pointers are:
 You cannot have NULL references. You must always be able to assume
that a reference is connected to a legitimate piece of storage.
 Once a reference is initialized to an object, it cannot be changed to refer
to another object. Pointers can be pointed to another object at any time.
 A reference must be initialized when it is created. Pointers can be
initialized at any time.
Creating References in C++
Think of a variable name as a label attached to the variable's location in
memory. You can then think of a reference as a second label attached to that
memory location. Therefore, you can access the contents of the variable through
either the original variable name or the reference. For example, suppose we
have the following example:
int i = 17;
We can declare reference variables for i as follows.
int&amp; r = i;
Read the &amp; in these declarations as reference. Thus, read the first declaration
as "r is an integer reference initialized to i" and read the second declaration as "s
is a double reference initialized to d." Following example makes use of
references on int and double:
#include &lt;iostream&gt;
using namespace std;
int main ()
{
19. REFERENCES
C++
136
 // declare simple variables
 int i;
 double d;
 // declare reference variables
 int&amp; r = i;
 double&amp; s = d;

 i = 5;
 cout &lt;&lt; "Value of i : " &lt;&lt; i &lt;&lt; endl;
 cout &lt;&lt; "Value of i reference : " &lt;&lt; r &lt;&lt; endl;
 d = 11.7;
 cout &lt;&lt; "Value of d : " &lt;&lt; d &lt;&lt; endl;
 cout &lt;&lt; "Value of d reference : " &lt;&lt; s &lt;&lt; endl;

 return 0;
}
When the above code is compiled together and executed, it produces the
following result:
Value of i : 5
Value of i reference : 5
Value of d : 11.7
Value of d reference : 11.7
References are usually used for function argument lists and function return
values. So following are two important subjects related to C++ references which
should be clear to a C++ programmer:
Concept Description
References as parameters C++ supports passing references as function
parameter more safely than parameters.
Reference as return value You can return reference from a C++ function
C++
137
like any other data type.
References as Parameters
We have discussed how we implement call by reference concept using
pointers. Here is another example of call by reference which makes use of C++
reference:
#include &lt;iostream&gt;
using namespace std;
// function declaration
void swap(int&amp; x, int&amp; y);
int main ()
{
 // local variable declaration:
 int a = 100;
 int b = 200;
 cout &lt;&lt; "Before swap, value of a :" &lt;&lt; a &lt;&lt; endl;
 cout &lt;&lt; "Before swap, value of b :" &lt;&lt; b &lt;&lt; endl;
 /* calling a function to swap the values.*/
 swap(a, b);
 cout &lt;&lt; "After swap, value of a :" &lt;&lt; a &lt;&lt; endl;
 cout &lt;&lt; "After swap, value of b :" &lt;&lt; b &lt;&lt; endl;
 return 0;
}
// function definition to swap the values.
void swap(int&amp; x, int&amp; y)
{
C++
138
 int temp;
 temp = x; /* save the value at address x */
 x = y; /* put y into x */
 y = temp; /* put x into y */

 return;
}
When the above code is compiled and executed, it produces the following result:
Before swap, value of a :100
Before swap, value of b :200
After swap, value of a :200
After swap, value of b :100
Reference as Return Value
A C++ program can be made easier to read and maintain by using references
rather than pointers. A C++ function can return a reference in a similar way as it
returns a pointer.
When a function returns a reference, it returns an implicit pointer to its return
value. This way, a function can be used on the left side of an assignment
statement. For example, consider this simple program:
#include &lt;iostream&gt;
#include &lt;ctime&gt;
using namespace std;
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
double&amp; setValues( int i )
{
 return vals[i]; // return a reference to the ith element
}
// main function to call above defined function.
int main ()
C++
139
{
 cout &lt;&lt; "Value before change" &lt;&lt; endl;
 for ( int i = 0; i &lt; 5; i++ )
 {
 cout &lt;&lt; "vals[" &lt;&lt; i &lt;&lt; "] = ";
 cout &lt;&lt; vals[i] &lt;&lt; endl;
 }
 setValues(1) = 20.23; // change 2nd element
 setValues(3) = 70.8; // change 4th element
 cout &lt;&lt; "Value after change" &lt;&lt; endl;
 for ( int i = 0; i &lt; 5; i++ )
 {
 cout &lt;&lt; "vals[" &lt;&lt; i &lt;&lt; "] = ";
 cout &lt;&lt; vals[i] &lt;&lt; endl;
 }
 return 0;
}
When the above code is compiled together and executed, it produces the
following result:
Value before change
vals[0] = 10.1
vals[1] = 12.6
vals[2] = 33.1
vals[3] = 24.1
vals[4] = 50
Value after change
vals[0] = 10.1
vals[1] = 20.23
vals[2] = 33.1
vals[3] = 70.8
C++
140
vals[4] = 50
When returning a reference, be careful that the object being referred to does not
go out of scope. So it is not legal to return a reference to local var. But you can
always return a reference on a static variable.
int&amp; func() {
 int q;
 //! return q; // Compile time error
 static int x;
 return x; // Safe, x lives outside this scope
}
C++
141
The C++ standard library does not provide a proper date type. C++ inherits the
structs and functions for date and time manipulation from C. To access date and
time related functions and structures, you would need to include &lt;ctime&gt;
header file in your C++ program.
There are four time-related types: clock_t, time_t, size_t, and tm. The types -
clock_t, size_t and time_t are capable of representing the system time and date
as some sort of integer.
The structure type tm holds the date and time in the form of a C structure
having the following elements:
struct tm {
 int tm_sec; // seconds of minutes from 0 to 61
 int tm_min; // minutes of hour from 0 to 59
 int tm_hour; // hours of day from 0 to 24
 int tm_mday; // day of month from 1 to 31
 int tm_mon; // month of year from 0 to 11
 int tm_year; // year since 1900
 int tm_wday; // days since sunday
 int tm_yday; // days since January 1st
 int tm_isdst; // hours of daylight savings time
}
Following are the important functions, which we use while working with date and
time in C or C++. All these functions are part of standard C and C++ library and
you can check their detail using reference to C++ standard library given below.
SN Function &amp; Purpose
1 time_t time(time_t *time);
This returns the current calendar time of the system in number of
seconds elapsed since January 1, 1970. If the system has no time, .1 is
returned.
2 char *ctime(const time_t *time);
This returns a pointer to a string of the form day month year
20. DATE AND TIME
C++
142
hours:minutes:seconds year\n\0.
3 struct tm *localtime(const time_t *time);
This returns a pointer to the tm structure representing local time.
4 clock_t clock(void);
This returns a value that approximates the amount of time the calling
program has been running. A value of .1 is returned if the time is not
available.
5 char * asctime ( const struct tm * time );
This returns a pointer to a string that contains the information stored in
the structure pointed to by time converted into the form: day month date
hours:minutes:seconds year\n\0
6 struct tm *gmtime(const time_t *time);
This returns a pointer to the time in the form of a tm structure. The time
is represented in Coordinated Universal Time (UTC), which is essentially
Greenwich Mean Time (GMT).
7 time_t mktime(struct tm *time);
This returns the calendar-time equivalent of the time found in the
structure pointed to by time.
8 double difftime ( time_t time2, time_t time1 );
This function calculates the difference in seconds between time1 and
time2.
9 size_t strftime();
This function can be used to format date and time in a specific format.
Current Date and Time
Suppose you want to retrieve the current system date and time, either as a local
time or as a Coordinated Universal Time (UTC). Following is the example to
achieve the same:
#include &lt;iostream&gt;
#include &lt;ctime&gt;
C++
143
using namespace std;
int main( )
{
 // current date/time based on current system
 time_t now = time(0);

 // convert now to string form
 char* dt = ctime(&amp;now);
 cout &lt;&lt; "The local date and time is: " &lt;&lt; dt &lt;&lt; endl;
 // convert now to tm struct for UTC
 tm *gmtm = gmtime(&amp;now);
 dt = asctime(gmtm);
 cout &lt;&lt; "The UTC date and time is:"&lt;&lt; dt &lt;&lt; endl;
}
When the above code is compiled and executed, it produces the following result:
The local date and time is: Sat Jan 8 20:07:41 2011
The UTC date and time is:Sun Jan 9 03:07:41 2011
Format Time using struct tm
The tm structure is very important while working with date and time in either C
or C++. This structure holds the date and time in the form of a C structure as
mentioned above. Most of the time related functions makes use of tm structure.
Following is an example which makes use of various date and time related
functions and tm structure:
While using structure in this chapter, I'm making an assumption that you have
basic understanding on C structure and how to access structure members using
arrow -&gt; operator.
#include &lt;iostream&gt;
#include &lt;ctime&gt;
C++
144
using namespace std;
int main( )
{
 // current date/time based on current system
 time_t now = time(0);
 cout &lt;&lt; "Number of sec since January 1,1970:" &lt;&lt; now &lt;&lt; endl;
 tm *ltm = localtime(&amp;now);
 // print various components of tm structure.
 cout &lt;&lt; "Year: "&lt;&lt; 1900 + ltm-&gt;tm_year &lt;&lt; endl;
 cout &lt;&lt; "Month: "&lt;&lt; 1 + ltm-&gt;tm_mon&lt;&lt; endl;
 cout &lt;&lt; "Day: "&lt;&lt; ltm-&gt;tm_mday &lt;&lt; endl;
 cout &lt;&lt; "Time: "&lt;&lt; 1 + ltm-&gt;tm_hour &lt;&lt; ":";
 cout &lt;&lt; 1 + ltm-&gt;tm_min &lt;&lt; ":";
 cout &lt;&lt; 1 + ltm-&gt;tm_sec &lt;&lt; endl;
}
When the above code is compiled and executed, it produces the following result:
Number of sec since January 1, 1970:1294548238
Year: 2011
Month: 1
Day: 8
Time: 22: 44:59
C++
145
The C++ standard libraries provide an extensive set of input/output capabilities
which we will see in subsequent chapters. This chapter will discuss very basic
and most common I/O operations required for C++ programming.
C++ I/O occurs in streams, which are sequences of bytes. If bytes flow from a
device like a keyboard, a disk drive, or a network connection etc. to main
memory, this is called input operation and if bytes flow from main memory to a
device like a display screen, a printer, a disk drive, or a network connection,
etc., this is called output operation.
I/O Library Header Files
There are following header files important to C++ programs:
Header File Function and Description
&lt;iostream&gt; This file defines the cin, cout, cerr and clog objects, which
correspond to the standard input stream, the standard output
stream, the un-buffered standard error stream and the
buffered standard error stream, respectively.
&lt;iomanip&gt; This file declares services useful for performing formatted I/O
with so-called parameterized stream manipulators, such
as setw and setprecision.
&lt;fstream&gt; This file declares services for user-controlled file processing.
We will discuss about it in detail in File and Stream related
chapter.
The Standard Output Stream (cout)
The predefined object cout is an instance of ostream class. The cout object is
said to be "connected to" the standard output device, which usually is the
display screen. The cout is used in conjunction with the stream insertion
operator, which is written as &lt;&lt; which are two less than signs as shown in the
following example.
#include &lt;iostream&gt;
21. BASIC INPUT/OUTPUT
C++
146
using namespace std;
int main( )
{
 char str[] = "Hello C++";
 cout &lt;&lt; "Value of str is : " &lt;&lt; str &lt;&lt; endl;
}
When the above code is compiled and executed, it produces the following result:
Value of str is : Hello C++
The C++ compiler also determines the data type of variable to be output and
selects the appropriate stream insertion operator to display the value. The &lt;&lt;
operator is overloaded to output data items of built-in types integer, float,
double, strings and pointer values.
The insertion operator &lt;&lt; may be used more than once in a single statement as
shown above and endl is used to add a new-line at the end of the line.
The Standard Input Stream (cin)
The predefined object cin is an instance of istream class. The cin object is said
to be attached to the standard input device, which usually is the keyboard.
The cin is used in conjunction with the stream extraction operator, which is
written as &gt;&gt; which are two greater than signs as shown in the following
example.
#include &lt;iostream&gt;
using namespace std;
int main( )
{
 char name[50];
 cout &lt;&lt; "Please enter your name: ";
 cin &gt;&gt; name;
 cout &lt;&lt; "Your name is: " &lt;&lt; name &lt;&lt; endl;
C++
147
}
When the above code is compiled and executed, it will prompt you to enter a
name. You enter a value and then hit enter to see the following result:
Please enter your name: cplusplus
Your name is: cplusplus
The C++ compiler also determines the data type of the entered value and
selects the appropriate stream extraction operator to extract the value and store
it in the given variables.
The stream extraction operator &gt;&gt; may be used more than once in a single
statement. To request more than one datum you can use the following:
cin &gt;&gt; name &gt;&gt; age;
This will be equivalent to the following two statements:
cin &gt;&gt; name;
cin &gt;&gt; age;
The Standard Error Stream (cerr)
The predefined object cerr is an instance of ostream class. The cerr object is
said to be attached to the standard error device, which is also a display screen
but the object cerr is un-buffered and each stream insertion to cerr causes its
output to appear immediately.
The cerr is also used in conjunction with the stream insertion operator as shown
in the following example.
#include &lt;iostream&gt;
using namespace std;
int main( )
{
 char str[] = "Unable to read....";
 cerr &lt;&lt; "Error message : " &lt;&lt; str &lt;&lt; endl;
}
When the above code is compiled and executed, it produces the following result:
C++
148
Error message : Unable to read....
The Standard Log Stream (clog)
The predefined object clog is an instance of ostream class. The clog object is
said to be attached to the standard error device, which is also a display screen
but the object clog is buffered. This means that each insertion to clog could
cause its output to be held in a buffer until the buffer is filled or until the buffer
is flushed.
The clog is also used in conjunction with the stream insertion operator as shown
in the following example.
#include &lt;iostream&gt;
using namespace std;
int main( )
{
 char str[] = "Unable to read....";
 clog &lt;&lt; "Error message : " &lt;&lt; str &lt;&lt; endl;
}
When the above code is compiled and executed, it produces the following result:
Error message : Unable to read....
You would not be able to see any difference in cout, cerr and clog with these
small examples, but while writing and executing big programs the difference
becomes obvious. So it is good practice to display error messages using cerr
stream and while displaying other log messages then clog should be used.
C++
149
C/C++ arrays allow you to define variables that combine several data items of
the same kind, but structure is another user defined data type which allows you
to combine data items of different kinds.
Structures are used to represent a record, suppose you want to keep track of
your books in a library. You might want to track the following attributes about
each book:
 Title
 Author
 Subject
 Book ID
Defining a Structure
To define a structure, you must use the struct statement. The struct statement
defines a new data type, with more than one member, for your program. The
format of the struct statement is this:
struct [structure tag]
{
 member definition;
 member definition;
 ...
 member definition;
} [one or more structure variables];
The structure tag is optional and each member definition is a normal variable
definition, such as int i; or float f; or any other valid variable definition. At the
end of the structure's definition, before the final semicolon, you can specify one
or more structure variables but it is optional. Here is the way you would declare
the Book structure:
struct Books
{
 char title[50];
 char author[50];
 char subject[100];
22. DATA STRUCTURES
C++
150
 int book_id;
}book;
Accessing Structure Members
To access any member of a structure, we use the member access operator
(.). The member access operator is coded as a period between the structure
variable name and the structure member that we wish to access. You would
use struct keyword to define variables of structure type. Following is the
example to explain usage of structure:
#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;
struct Books
{
 char title[50];
 char author[50];
 char subject[100];
 int book_id;
};
int main( )
{
 struct Books Book1; // Declare Book1 of type Book
 struct Books Book2; // Declare Book2 of type Book
 // book 1 specification
 strcpy( Book1.title, "Learn C++ Programming");
 strcpy( Book1.author, "Chand Miyan");
 strcpy( Book1.subject, "C++ Programming");
 Book1.book_id = 6495407;
 // book 2 specification
 strcpy( Book2.title, "Telecom Billing");
C++
151
 strcpy( Book2.author, "Yakit Singha");
 strcpy( Book2.subject, "Telecom");
 Book2.book_id = 6495700;
 // Print Book1 info
 cout &lt;&lt; "Book 1 title : " &lt;&lt; Book1.title &lt;&lt;endl;
 cout &lt;&lt; "Book 1 author : " &lt;&lt; Book1.author &lt;&lt;endl;
 cout &lt;&lt; "Book 1 subject : " &lt;&lt; Book1.subject &lt;&lt;endl;
 cout &lt;&lt; "Book 1 id : " &lt;&lt; Book1.book_id &lt;&lt;endl;
 // Print Book2 info
 cout &lt;&lt; "Book 2 title : " &lt;&lt; Book2.title &lt;&lt;endl;
 cout &lt;&lt; "Book 2 author : " &lt;&lt; Book2.author &lt;&lt;endl;
 cout &lt;&lt; "Book 2 subject : " &lt;&lt; Book2.subject &lt;&lt;endl;
 cout &lt;&lt; "Book 2 id : " &lt;&lt; Book2.book_id &lt;&lt;endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Book 1 title : Learn C++ Programming
Book 1 author : Chand Miyan
Book 1 subject : C++ Programming
Book 1 id : 6495407
Book 2 title : Telecom Billing
Book 2 author : Yakit Singha
Book 2 subject : Telecom
Book 2 id : 6495700
Structures as Function Arguments
You can pass a structure as a function argument in very similar way as you pass
any other variable or pointer. You would access structure variables in the similar
way as you have accessed in the above example:
#include &lt;iostream&gt;
#include &lt;cstring&gt;
C++
152
using namespace std;
void printBook( struct Books book );
struct Books
{
 char title[50];
 char author[50];
 char subject[100];
 int book_id;
};
int main( )
{
 struct Books Book1; // Declare Book1 of type Book
 struct Books Book2; // Declare Book2 of type Book
 // book 1 specification
 strcpy( Book1.title, "Learn C++ Programming");
 strcpy( Book1.author, "Chand Miyan");
 strcpy( Book1.subject, "C++ Programming");
 Book1.book_id = 6495407;
 // book 2 specification
 strcpy( Book2.title, "Telecom Billing");
 strcpy( Book2.author, "Yakit Singha");
 strcpy( Book2.subject, "Telecom");
 Book2.book_id = 6495700;
 // Print Book1 info
 printBook( Book1 );
 // Print Book2 info
 printBook( Book2 );
C++
153
 return 0;
}
void printBook( struct Books book )
{
 cout &lt;&lt; "Book title : " &lt;&lt; book.title &lt;&lt;endl;
 cout &lt;&lt; "Book author : " &lt;&lt; book.author &lt;&lt;endl;
 cout &lt;&lt; "Book subject : " &lt;&lt; book.subject &lt;&lt;endl;
 cout &lt;&lt; "Book id : " &lt;&lt; book.book_id &lt;&lt;endl;
}
When the above code is compiled and executed, it produces the following result:
Book title : Learn C++ Programming
Book author : Chand Miyan
Book subject : C++ Programming
Book id : 6495407
Book title : Telecom Billing
Book author : Yakit Singha
Book subject : Telecom
Book id : 6495700
Pointers to Structures
You can define pointers to structures in very similar way as you define pointer to
any other variable as follows:
struct Books *struct_pointer;
Now, you can store the address of a structure variable in the above defined
pointer variable. To find the address of a structure variable, place the ‘&amp;’
operator before the structure's name as follows:
struct_pointer = &amp;Book1;
To access the members of a structure using a pointer to that structure, you must
use the -&gt; operator as follows:
struct_pointer-&gt;title;
Let us re-write above example using structure pointer, hope this will be easy for
you to understand the concept:
C++
154
#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;
void printBook( struct Books *book );
struct Books
{
 char title[50];
 char author[50];
 char subject[100];
 int book_id;
};
int main( )
{
 struct Books Book1; // Declare Book1 of type Book
 struct Books Book2; // Declare Book2 of type Book
 // Book 1 specification
 strcpy( Book1.title, "Learn C++ Programming");
 strcpy( Book1.author, "Chand Miyan");
 strcpy( Book1.subject, "C++ Programming");
 Book1.book_id = 6495407;
 // Book 2 specification
 strcpy( Book2.title, "Telecom Billing");
 strcpy( Book2.author, "Yakit Singha");
 strcpy( Book2.subject, "Telecom");
 Book2.book_id = 6495700;
 // Print Book1 info, passing address of structure
 printBook( &amp;Book1 );
C++
155
 // Print Book1 info, passing address of structure
 printBook( &amp;Book2 );
 return 0;
}
// This function accept pointer to structure as parameter.
void printBook( struct Books *book )
{
 cout &lt;&lt; "Book title : " &lt;&lt; book-&gt;title &lt;&lt;endl;
 cout &lt;&lt; "Book author : " &lt;&lt; book-&gt;author &lt;&lt;endl;
 cout &lt;&lt; "Book subject : " &lt;&lt; book-&gt;subject &lt;&lt;endl;
 cout &lt;&lt; "Book id : " &lt;&lt; book-&gt;book_id &lt;&lt;endl;
}
When the above code is compiled and executed, it produces the following result:
Book title : Learn C++ Programming
Book author : Chand Miyan
Book subject : C++ Programming
Book id : 6495407
Book title : Telecom Billing
Book author : Yakit Singha
Book subject : Telecom
Book id : 6495700
The typedef Keyword
There is an easier way to define structs or you could "alias" types you create.
For example:
typedef struct
{
 char title[50];
 char author[50];
 char subject[100];
 int book_id;
}Books;
C++
156
Now, you can use Books directly to define variables of Books type without using
struct keyword. Following is the example:
Books Book1, Book2;
You can use typedef keyword for non-structs as well as follows:
typedef long int *pint32;
pint32 x, y, z;
x, y and z are all pointers to long ints.
C++
157
The main purpose of C++ programming is to add object orientation to the C
programming language and classes are the central feature of C++ that supports
object-oriented programming and are often called user-defined types.
A class is used to specify the form of an object and it combines data
representation and methods for manipulating that data into one neat package.
The data and functions within a class are called members of the class.
C++ Class Definitions
When you define a class, you define a blueprint for a data type. This doesn't
actually define any data, but it does define what the class name means, that is,
what an object of the class will consist of and what operations can be performed
on such an object.
A class definition starts with the keyword class followed by the class name; and
the class body, enclosed by a pair of curly braces. A class definition must be
followed either by a semicolon or a list of declarations. For example, we define
the Box data type using the keyword class as follows:
class Box
{
 public:
 double length; // Length of a box
 double breadth; // Breadth of a box
 double height; // Height of a box
};
The keyword public determines the access attributes of the members of the
class that follows it. A public member can be accessed from outside the class
anywhere within the scope of the class object. You can also specify the members
of a class as private or protected which we will discuss in a sub-section.
Define C++ Objects
A class provides the blueprints for objects, so basically an object is created from
a class. We declare objects of a class with exactly the same sort of declaration
that we declare variables of basic types. Following statements declare two
objects of class Box:
Box Box1; // Declare Box1 of type Box
Box Box2; // Declare Box2 of type Box
23. CLASSES AND OBJECTS
C++
158
Both of the objects Box1 and Box2 will have their own copy of data members.
Accessing the Data Members
The public data members of objects of a class can be accessed using the direct
member access operator (.). Let us try the following example to make the things
clear:
#include &lt;iostream&gt;
using namespace std;
class Box
{
 public:
 double length; // Length of a box
 double breadth; // Breadth of a box
 double height; // Height of a box
};
int main( )
{
 Box Box1; // Declare Box1 of type Box
 Box Box2; // Declare Box2 of type Box
 double volume = 0.0; // Store the volume of a box here
 // box 1 specification
 Box1.height = 5.0;
 Box1.length = 6.0;
 Box1.breadth = 7.0;
 // box 2 specification
 Box2.height = 10.0;
 Box2.length = 12.0;
 Box2.breadth = 13.0;
 // volume of box 1
 volume = Box1.height * Box1.length * Box1.breadth;
C++
159
 cout &lt;&lt; "Volume of Box1 : " &lt;&lt; volume &lt;&lt;endl;
 // volume of box 2
 volume = Box2.height * Box2.length * Box2.breadth;
 cout &lt;&lt; "Volume of Box2 : " &lt;&lt; volume &lt;&lt;endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Volume of Box1 : 210
Volume of Box2 : 1560
It is important to note that private and protected members cannot be accessed
directly using direct member access operator (.). We will learn how private and
protected members can be accessed.
Classes &amp; Objects in Detail
So far, you have got very basic idea about C++ Classes and Objects. There are
further interesting concepts related to C++ Classes and Objects which we will
discuss in various sub-sections listed below:
Concept Description
Class member functions A member function of a class is a function that
has its definition or its prototype within the
class definition like any other variable.
Class access modifiers A class member can be defined as public,
private or protected. By default members
would be assumed as private.
Constructor &amp; destructor A class constructor is a special function in a
class that is called when a new object of the
class is created. A destructor is also a special
function which is called when created object is
deleted.
C++ copy constructor The copy constructor is a constructor which
creates an object by initializing it with an
object of the same class, which has been
C++
160
created previously.
C++ friend functions A friend function is permitted full access to
private and protected members of a class.
C++ inline functions With an inline function, the compiler tries to
expand the code in the body of the function in
place of a call to the function.
The this pointer in C++ Every object has a special pointer this which
points to the object itself.
Pointer to C++ classes A pointer to a class is done exactly the same
way a pointer to a structure is. In fact a class
is really just a structure with functions in it.
Static members of a class Both data members and function members of
a class can be declared as static.
Class member functions
A member function of a class is a function that has its definition or its prototype
within the class definition like any other variable. It operates on any object of
the class of which it is a member, and has access to all the members of a class
for that object.
Let us take previously defined class to access the members of the class using a
member function instead of directly accessing them:
class Box
{
 public:
 double length; // Length of a box
 double breadth; // Breadth of a box
 double height; // Height of a box
 double getVolume(void);// Returns box volume
};
Member functions can be defined within the class definition or separately
using scope resolution operator, ::. Defining a member function within the
C++
161
class definition declares the function inline, even if you do not use the inline
specifier. So either you can defineVolume() function as below:
class Box
{
 public:
 double length; // Length of a box
 double breadth; // Breadth of a box
 double height; // Height of a box

 double getVolume(void)
 {
 return length * breadth * height;
 }
};
If you like, you can define the same function outside the class using the scope
resolution operator (::) as follows:
double Box::getVolume(void)
{
 return length * breadth * height;
}
Here, only important point is that you would have to use class name just before
:: operator. A member function will be called using a dot operator (.) on a object
where it will manipulate data related to that object only as follows:
Box myBox; // Create an object
myBox.getVolume(); // Call member function for the object
Let us put above concepts to set and get the value of different class members in
a class:
#include &lt;iostream&gt;
using namespace std;
class Box
C++
162
{
 public:
 double length; // Length of a box
 double breadth; // Breadth of a box
 double height; // Height of a box
 // Member functions declaration
 double getVolume(void);
 void setLength( double len );
 void setBreadth( double bre );
 void setHeight( double hei );
};
// Member functions definitions
double Box::getVolume(void)
{
 return length * breadth * height;
}
void Box::setLength( double len )
{
 length = len;
}
void Box::setBreadth( double bre )
{
 breadth = bre;
}
void Box::setHeight( double hei )
{
 height = hei;
}
C++
163
// Main function for the program
int main( )
{
 Box Box1; // Declare Box1 of type Box
 Box Box2; // Declare Box2 of type Box
 double volume = 0.0; // Store the volume of a box here
 // box 1 specification
 Box1.setLength(6.0);
 Box1.setBreadth(7.0);
 Box1.setHeight(5.0);
 // box 2 specification
 Box2.setLength(12.0);
 Box2.setBreadth(13.0);
 Box2.setHeight(10.0);
 // volume of box 1
 volume = Box1.getVolume();
 cout &lt;&lt; "Volume of Box1 : " &lt;&lt; volume &lt;&lt;endl;
 // volume of box 2
 volume = Box2.getVolume();
 cout &lt;&lt; "Volume of Box2 : " &lt;&lt; volume &lt;&lt;endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Volume of Box1 : 210
Volume of Box2 : 1560
Class Access Modifiers
Data hiding is one of the important features of Object Oriented Programming
which allows preventing the functions of a program to access directly the
C++
164
internal representation of a class type. The access restriction to the class
members is specified by the labeled public, private, and protected sections
within the class body. The keywords public, private, and protected are called
access specifiers.
A class can have multiple public, protected, or private labeled sections. Each
section remains in effect until either another section label or the closing right
brace of the class body is seen. The default access for members and classes is
private.
class Base {
 public:
 // public members go here
 protected:
 // protected members go here
 private:
 // private members go here
};
The public Members
A public member is accessible from anywhere outside the class but within a
program. You can set and get the value of public variables without any member
function as shown in the following example:
#include &lt;iostream&gt;
using namespace std;
class Line
{
 public:
 double length;
C++
165
 void setLength( double len );
 double getLength( void );
};
// Member functions definitions
double Line::getLength(void)
{
 return length ;
}
void Line::setLength( double len )
{
 length = len;
}
// Main function for the program
int main( )
{
 Line line;
 // set line length
 line.setLength(6.0);
 cout &lt;&lt; "Length of line : " &lt;&lt; line.getLength() &lt;&lt;endl;
 // set line length without member function
 line.length = 10.0; // OK: because length is public
 cout &lt;&lt; "Length of line : " &lt;&lt; line.length &lt;&lt;endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Length of line : 6
Length of line : 10
The private Members
C++
166
A private member variable or function cannot be accessed, or even viewed from
outside the class. Only the class and friend functions can access private
members.
By default all the members of a class would be private, for example in the
following classwidth is a private member, which means until you label a
member, it will be assumed a private member:
class Box
{
 double width;
 public:
 double length;
 void setWidth( double wid );
 double getWidth( void );
};
Practically, we define data in private section and related functions in public
section so that they can be called from outside of the class as shown in the
following program.
#include &lt;iostream&gt;
using namespace std;
class Box
{
 public:
 double length;
 void setWidth( double wid );
 double getWidth( void );
 private:
 double width;
};
// Member functions definitions
double Box::getWidth(void)
C++
167
{
 return width ;
}
void Box::setWidth( double wid )
{
 width = wid;
}
// Main function for the program
int main( )
{
 Box box;
 // set box length without member function
 box.length = 10.0; // OK: because length is public
 cout &lt;&lt; "Length of box : " &lt;&lt; box.length &lt;&lt;endl;
 // set box width without member function
 // box.width = 10.0; // Error: because width is private
 box.setWidth(10.0); // Use member function to set it.
 cout &lt;&lt; "Width of box : " &lt;&lt; box.getWidth() &lt;&lt;endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Length of box : 10
Width of box : 10
The protected Members
A protected member variable or function is very similar to a private member
but it provided one additional benefit that they can be accessed in child classes
which are called derived classes.
C++
168
You will learn derived classes and inheritance in next chapter. For now you can
check following example where I have derived one child class SmallBox from a
parent class Box.
Following example is similar to above example and here width member will be
accessible by any member function of its derived class SmallBox.
#include &lt;iostream&gt;
using namespace std;
class Box
{
 protected:
 double width;
};
class SmallBox:Box // SmallBox is the derived class.
{
 public:
 void setSmallWidth( double wid );
 double getSmallWidth( void );
};
// Member functions of child class
double SmallBox::getSmallWidth(void)
{
 return width ;
}
void SmallBox::setSmallWidth( double wid )
{
 width = wid;
}
// Main function for the program
int main( )
{
C++
169
 SmallBox box;
 // set box width using member function
 box.setSmallWidth(5.0);
 cout &lt;&lt; "Width of box : "&lt;&lt; box.getSmallWidth() &lt;&lt; endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Width of box : 5
Constructor &amp; Destructor
A class constructor is a special member function of a class that is executed
whenever we create new objects of that class.
A constructor will have exact same name as the class and it does not have any
return type at all, not even void. Constructors can be very useful for setting
initial values for certain member variables.
Following example explains the concept of constructor:
#include &lt;iostream&gt;
using namespace std;
class Line
{
 public:
 void setLength( double len );
 double getLength( void );
 Line(); // This is the constructor
 private:
 double length;
};
// Member functions definitions including constructor
C++
170
Line::Line(void)
{
 cout &lt;&lt; "Object is being created" &lt;&lt; endl;
}
void Line::setLength( double len )
{
 length = len;
}
double Line::getLength( void )
{
 return length;
}
// Main function for the program
int main( )
{
 Line line;
 // set line length
 line.setLength(6.0);
 cout &lt;&lt; "Length of line : " &lt;&lt; line.getLength() &lt;&lt;endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Object is being created
Length of line : 6
Parameterized Constructor
A default constructor does not have any parameter, but if you need, a
constructor can have parameters. This helps you to assign initial value to an
object at the time of its creation as shown in the following example:
C++
171
#include &lt;iostream&gt;
using namespace std;
class Line
{
 public:
 void setLength( double len );
 double getLength( void );
 Line(double len); // This is the constructor
 private:
 double length;
};
// Member functions definitions including constructor
Line::Line( double len)
{
 cout &lt;&lt; "Object is being created, length = " &lt;&lt; len &lt;&lt; endl;
 length = len;
}
void Line::setLength( double len )
{
 length = len;
}
double Line::getLength( void )
{
 return length;
}
// Main function for the program
int main( )
{
C++
172
 Line line(10.0);
 // get initially set length.
 cout &lt;&lt; "Length of line : " &lt;&lt; line.getLength() &lt;&lt;endl;
 // set line length again
 line.setLength(6.0);
 cout &lt;&lt; "Length of line : " &lt;&lt; line.getLength() &lt;&lt;endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Object is being created, length = 10
Length of line : 10
Length of line : 6
Using Initialization Lists to Initialize Fields
In case of parameterized constructor, you can use following syntax to initialize
the fields:
Line::Line( double len): length(len)
{
 cout &lt;&lt; "Object is being created, length = " &lt;&lt; len &lt;&lt; endl;
}
Above syntax is equal to the following syntax:
Line::Line( double len)
{
 cout &lt;&lt; "Object is being created, length = " &lt;&lt; len &lt;&lt; endl;
 length = len;
}
If for a class C, you have multiple fields X, Y, Z, etc., to be initialized, then use
can use same syntax and separate the fields by comma as follows:
C::C( double a, double b, double c): X(a), Y(b), Z(c)
{
C++
173
 ....
}
The Class Destructor
A destructor is a special member function of a class that is executed whenever
an object of it's class goes out of scope or whenever the delete expression is
applied to a pointer to the object of that class.
A destructor will have exact same name as the class prefixed with a tilde (~)
and it can neither return a value nor can it take any parameters. Destructor can
be very useful for releasing resources before coming out of the program like
closing files, releasing memories etc.
Following example explains the concept of destructor:
#include &lt;iostream&gt;
using namespace std;
class Line
{
 public:
 void setLength( double len );
 double getLength( void );
 Line(); // This is the constructor declaration
 ~Line(); // This is the destructor: declaration
 private:
 double length;
};
// Member functions definitions including constructor
Line::Line(void)
{
 cout &lt;&lt; "Object is being created" &lt;&lt; endl;
}
Line::~Line(void)
{
C++
174
 cout &lt;&lt; "Object is being deleted" &lt;&lt; endl;
}
void Line::setLength( double len )
{
 length = len;
}
double Line::getLength( void )
{
 return length;
}
// Main function for the program
int main( )
{
 Line line;
 // set line length
 line.setLength(6.0);
 cout &lt;&lt; "Length of line : " &lt;&lt; line.getLength() &lt;&lt;endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Object is being created
Length of line : 6
Object is being deleted
Copy Constructor
C++
175
The copy constructor is a constructor which creates an object by initializing it
with an object of the same class, which has been created previously. The copy
constructor is used to:
 Initialize one object from another of the same type.
 Copy an object to pass it as an argument to a function.
 Copy an object to return it from a function.
If a copy constructor is not defined in a class, the compiler itself defines one.If
the class has pointer variables and has some dynamic memory allocations, then
it is a must to have a copy constructor. The most common form of copy
constructor is shown here:
classname (const classname &amp;obj) {
 // body of constructor
}
Here, obj is a reference to an object that is being used to initialize another
object.
#include &lt;iostream&gt;
using namespace std;
class Line
{
 public:
 int getLength( void );
 Line( int len ); // simple constructor
 Line( const Line &amp;obj); // copy constructor
 ~Line(); // destructor
 private:
 int *ptr;
};
// Member functions definitions including constructor
Line::Line(int len)
{
C++
176
 cout &lt;&lt; "Normal constructor allocating ptr" &lt;&lt; endl;
 // allocate memory for the pointer;
 ptr = new int;
 *ptr = len;
}
Line::Line(const Line &amp;obj)
{
 cout &lt;&lt; "Copy constructor allocating ptr." &lt;&lt; endl;
 ptr = new int;
 *ptr = *obj.ptr; // copy the value
}
Line::~Line(void)
{
 cout &lt;&lt; "Freeing memory!" &lt;&lt; endl;
 delete ptr;
}
int Line::getLength( void )
{
 return *ptr;
}
void display(Line obj)
{
 cout &lt;&lt; "Length of line : " &lt;&lt; obj.getLength() &lt;&lt;endl;
}
// Main function for the program
int main( )
{
 Line line(10);
 display(line);
C++
177
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Normal constructor allocating ptr
Copy constructor allocating ptr.
Length of line : 10
Freeing memory!
Freeing memory!
Let us see the same example but with a small change to create another object
using existing object of the same type:
#include &lt;iostream&gt;
using namespace std;
class Line
{
 public:
 int getLength( void );
 Line( int len ); // simple constructor
 Line( const Line &amp;obj); // copy constructor
 ~Line(); // destructor
 private:
 int *ptr;
};
// Member functions definitions including constructor
Line::Line(int len)
{
 cout &lt;&lt; "Normal constructor allocating ptr" &lt;&lt; endl;
 // allocate memory for the pointer;
 ptr = new int;
C++
178
 *ptr = len;
}
Line::Line(const Line &amp;obj)
{
 cout &lt;&lt; "Copy constructor allocating ptr." &lt;&lt; endl;
 ptr = new int;
 *ptr = *obj.ptr; // copy the value
}
Line::~Line(void)
{
 cout &lt;&lt; "Freeing memory!" &lt;&lt; endl;
 delete ptr;
}
int Line::getLength( void )
{
 return *ptr;
}
void display(Line obj)
{
 cout &lt;&lt; "Length of line : " &lt;&lt; obj.getLength() &lt;&lt;endl;
}
// Main function for the program
int main( )
{
 Line line1(10);
 Line line2 = line1; // This also calls copy constructor
 display(line1);
 display(line2);
C++
179
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Normal constructor allocating ptr
Copy constructor allocating ptr.
Copy constructor allocating ptr.
Length of line : 10
Freeing memory!
Copy constructor allocating ptr.
Length of line : 10
Freeing memory!
Freeing memory!
Freeing memory!
Friend Functions
A friend function of a class is defined outside that class' scope but it has the
right to access all private and protected members of the class. Even though the
prototypes for friend functions appear in the class definition, friends are not
member functions.
A friend can be a function, function template, or member function, or a class or
class template, in which case the entire class and all of its members are friends.
To declare a function as a friend of a class, precede the function prototype in the
class definition with keyword friend as follows:
class Box
{
 double width;
public:
 double length;
 friend void printWidth( Box box );
 void setWidth( double wid );
};
To declare all member functions of class ClassTwo as friends of class ClassOne,
place a following declaration in the definition of class ClassOne:
C++
180
friend class ClassTwo;
Consider the following program:
#include &lt;iostream&gt;
using namespace std;
class Box
{
 double width;
public:
 friend void printWidth( Box box );
 void setWidth( double wid );
};
// Member function definition
void Box::setWidth( double wid )
{
 width = wid;
}
// Note: printWidth() is not a member function of any class.
void printWidth( Box box )
{
 /* Because printWidth() is a friend of Box, it can
 directly access any member of this class */
 cout &lt;&lt; "Width of box : " &lt;&lt; box.width &lt;&lt;endl;
}
// Main function for the program
int main( )
{
 Box box;
C++
181
 // set box width without member function
 box.setWidth(10.0);

 // Use friend function to print the wdith.
 printWidth( box );
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Width of box : 10
Inline Functions
C++ inline function is powerful concept that is commonly used with classes. If a
function is inline, the compiler places a copy of the code of that function at each
point where the function is called at compile time.
Any change to an inline function could require all clients of the function to be
recompiled because compiler would need to replace all the code once again
otherwise it will continue with old functionality.
To inline a function, place the keyword inline before the function name and
define the function before any calls are made to the function. The compiler can
ignore the inline qualifier in case defined function is more than a line.
A function definition in a class definition is an inline function definition, even
without the use of the inline specifier.
Following is an example, which makes use of inline function to return max of two
numbers:
#include &lt;iostream&gt;
using namespace std;
inline int Max(int x, int y)
{
 return (x &gt; y)? x : y;
}
// Main function for the program
C++
182
int main( )
{
 cout &lt;&lt; "Max (20,10): " &lt;&lt; Max(20,10) &lt;&lt; endl;
 cout &lt;&lt; "Max (0,200): " &lt;&lt; Max(0,200) &lt;&lt; endl;
 cout &lt;&lt; "Max (100,1010): " &lt;&lt; Max(100,1010) &lt;&lt; endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Max (20,10): 20
Max (0,200): 200
Max (100,1010): 1010
this Pointer
Every object in C++ has access to its own address through an important pointer
called thispointer. The this pointer is an implicit parameter to all member
functions. Therefore, inside a member function, this may be used to refer to the
invoking object.
Friend functions do not have a this pointer, because friends are not members of
a class. Only member functions have a this pointer.
Let us try the following example to understand the concept of this pointer:
#include &lt;iostream&gt;
using namespace std;
class Box
{
 public:
 // Constructor definition
 Box(double l=2.0, double b=2.0, double h=2.0)
 {
 cout &lt;&lt;"Constructor called." &lt;&lt; endl;
 length = l;
 breadth = b;
C++
183
 height = h;
 }
 double Volume()
 {
 return length * breadth * height;
 }
 int compare(Box box)
 {
 return this-&gt;Volume() &gt; box.Volume();
 }
 private:
 double length; // Length of a box
 double breadth; // Breadth of a box
 double height; // Height of a box
};
int main(void)
{
 Box Box1(3.3, 1.2, 1.5); // Declare box1
 Box Box2(8.5, 6.0, 2.0); // Declare box2
 if(Box1.compare(Box2))
 {
 cout &lt;&lt; "Box2 is smaller than Box1" &lt;&lt;endl;
 }
 else
 {
 cout &lt;&lt; "Box2 is equal to or larger than Box1" &lt;&lt;endl;
 }
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Constructor called.
C++
184
Constructor called.
Box2 is equal to or larger than Box1
Pointer to C++ Classes
A pointer to a C++ class is done exactly the same way as a pointer to a
structure and to access members of a pointer to a class you use the member
access operator -&gt; operator, just as you do with pointers to structures. Also as
with all pointers, you must initialize the pointer before using it.
Let us try the following example to understand the concept of pointer to a class:
#include &lt;iostream&gt;
using namespace std;
class Box
{
 public:
 // Constructor definition
 Box(double l=2.0, double b=2.0, double h=2.0)
 {
 cout &lt;&lt;"Constructor called." &lt;&lt; endl;
 length = l;
 breadth = b;
 height = h;
 }
 double Volume()
 {
 return length * breadth * height;
 }
 private:
 double length; // Length of a box
 double breadth; // Breadth of a box
 double height; // Height of a box
};
C++
185
int main(void)
{
 Box Box1(3.3, 1.2, 1.5); // Declare box1
 Box Box2(8.5, 6.0, 2.0); // Declare box2
 Box *ptrBox; // Declare pointer to a class.
 // Save the address of first object
 ptrBox = &amp;Box1;
 // Now try to access a member using member access operator
 cout &lt;&lt; "Volume of Box1: " &lt;&lt; ptrBox-&gt;Volume() &lt;&lt; endl;
 // Save the address of first object
 ptrBox = &amp;Box2;
 // Now try to access a member using member access operator
 cout &lt;&lt; "Volume of Box2: " &lt;&lt; ptrBox-&gt;Volume() &lt;&lt; endl;

 return 0;
}
When the above code is compiled and executed, it produces the following result:
Constructor called.
Constructor called.
Volume of Box1: 5.94
Volume of Box2: 102
Static Members of a Class
We can define class members static using static keyword. When we declare a
member of a class as static it means no matter how many objects of the class
are created, there is only one copy of the static member.
A static member is shared by all objects of the class. All static data is initialized
to zero when the first object is created, if no other initialization is present. We
can't put it in the class definition but it can be initialized outside the class as
done in the following example by redeclaring the static variable, using the scope
resolution operator :: to identify which class it belongs to.
C++
186
Let us try the following example to understand the concept of static data
members:
#include &lt;iostream&gt;
using namespace std;
class Box
{
 public:
 static int objectCount;
 // Constructor definition
 Box(double l=2.0, double b=2.0, double h=2.0)
 {
 cout &lt;&lt;"Constructor called." &lt;&lt; endl;
 length = l;
 breadth = b;
 height = h;
 // Increase every time object is created
 objectCount++;
 }
 double Volume()
 {
 return length * breadth * height;
 }
 private:
 double length; // Length of a box
 double breadth; // Breadth of a box
 double height; // Height of a box
};
// Initialize static member of class Box
int Box::objectCount = 0;
int main(void)
C++
187
{
 Box Box1(3.3, 1.2, 1.5); // Declare box1
 Box Box2(8.5, 6.0, 2.0); // Declare box2
 // Print total number of objects.
 cout &lt;&lt; "Total objects: " &lt;&lt; Box::objectCount &lt;&lt; endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Constructor called.
Constructor called.
Total objects: 2
Static Function Members
By declaring a function member as static, you make it independent of any
particular object of the class. A static member function can be called even if no
objects of the class exist and the static functions are accessed using only the
class name and the scope resolution operator ::.
A static member function can only access static data member, other static
member functions and any other functions from outside the class.
Static member functions have a class scope and they do not have access to
the this pointer of the class. You could use a static member function to
determine whether some objects of the class have been created or not.
Let us try the following example to understand the concept of static function
members:
#include &lt;iostream&gt;
using namespace std;
class Box
{
 public:
 static int objectCount;
 // Constructor definition
C++
188
 Box(double l=2.0, double b=2.0, double h=2.0)
 {
 cout &lt;&lt;"Constructor called." &lt;&lt; endl;
 length = l;
 breadth = b;
 height = h;
 // Increase every time object is created
 objectCount++;
 }
 double Volume()
 {
 return length * breadth * height;
 }
 static int getCount()
 {
 return objectCount;
 }
 private:
 double length; // Length of a box
 double breadth; // Breadth of a box
 double height; // Height of a box
};
// Initialize static member of class Box
int Box::objectCount = 0;
int main(void)
{

 // Print total number of objects before creating object.
 cout &lt;&lt; "Inital Stage Count: " &lt;&lt; Box::getCount() &lt;&lt; endl;
 Box Box1(3.3, 1.2, 1.5); // Declare box1
 Box Box2(8.5, 6.0, 2.0); // Declare box2
C++
189
 // Print total number of objects after creating object.
 cout &lt;&lt; "Final Stage Count: " &lt;&lt; Box::getCount() &lt;&lt; endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Inital Stage Count: 0
Constructor called.
Constructor called.
Final Stage Count: 2
C++
190
One of the most important concepts in object-oriented programming is that of
inheritance. Inheritance allows us to define a class in terms of another class,
which makes it easier to create and maintain an application. This also provides
an opportunity to reuse the code functionality and fast implementation time.
When creating a class, instead of writing completely new data members and
member functions, the programmer can designate that the new class should
inherit the members of an existing class. This existing class is called
the base class, and the new class is referred to as the derived class.
The idea of inheritance implements the is a relationship. For example, mammal
IS-A animal, dog IS-A mammal hence dog IS-A animal as well and so on.
Base &amp; Derived Classes
A class can be derived from more than one classes, which means it can inherit
data and functions from multiple base classes. To define a derived class, we use
a class derivation list to specify the base class(es). A class derivation list names
one or more base classes and has the form:
class derived-class: access-specifier base-class
Where access-specifier is one of public, protected, or private, and base-class
is the name of a previously defined class. If the access-specifier is not used,
then it is private by default.
Consider a base class Shape and its derived class Rectangle as follows:
#include &lt;iostream&gt;
using namespace std;
// Base class
class Shape
{
 public:
 void setWidth(int w)
 {
 width = w;
 }
24. INHERITANCE
C++
191
 void setHeight(int h)
 {
 height = h;
 }
 protected:
 int width;
 int height;
};
// Derived class
class Rectangle: public Shape
{
 public:
 int getArea()
 {
 return (width * height);
 }
};
int main(void)
{
 Rectangle Rect;
 Rect.setWidth(5);
 Rect.setHeight(7);
 // Print the area of the object.
 cout &lt;&lt; "Total area: " &lt;&lt; Rect.getArea() &lt;&lt; endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
C++
192
Total area: 35
Access Control and Inheritance
A derived class can access all the non-private members of its base class. Thus
base-class members that should not be accessible to the member functions of
derived classes should be declared private in the base class.
We can summarize the different access types according to - who can access
them, in the following way:
Access public protected private
Same class yes yes yes
Derived classes yes yes no
Outside classes yes no no
A derived class inherits all base class methods with the following exceptions:
 Constructors, destructors and copy constructors of the base class.
 Overloaded operators of the base class.
 The friend functions of the base class.
Type of Inheritance
When deriving a class from a base class, the base class may be inherited
through public, protected or private inheritance. The type of inheritance is
specified by the access-specifier as explained above.
We hardly use protected or private inheritance, but public inheritance is
commonly used. While using different type of inheritance, following rules are
applied:
 Public Inheritance: When deriving a class from a public base
class, public members of the base class become public members of the
derived class and protected members of the base class
become protected members of the derived class. A base
class's private members are never accessible directly from a derived
class, but can be accessed through calls to
the public and protected members of the base class.
 Protected Inheritance: When deriving from a protected base
class, public and protected members of the base class
become protected members of the derived class.
C++
193
 Private Inheritance: When deriving from a private base
class, public and protected members of the base class
become private members of the derived class.
Multiple Inheritance
A C++ class can inherit members from more than one class and here is the
extended syntax:
class derived-class: access baseA, access baseB....
Where access is one of public, protected, or private and would be given for
every base class and they will be separated by comma as shown above. Let us
try the following example:
#include &lt;iostream&gt;
using namespace std;
// Base class Shape
class Shape
{
 public:
 void setWidth(int w)
 {
 width = w;
 }
 void setHeight(int h)
 {
 height = h;
 }
 protected:
 int width;
 int height;
};
// Base class PaintCost
class PaintCost
{
C++
194
 public:
 int getCost(int area)
 {
 return area * 70;
 }
};
// Derived class
class Rectangle: public Shape, public PaintCost
{
 public:
 int getArea()
 {
 return (width * height);
 }
};
int main(void)
{
 Rectangle Rect;
 int area;
 Rect.setWidth(5);
 Rect.setHeight(7);
 area = Rect.getArea();

 // Print the area of the object.
 cout &lt;&lt; "Total area: " &lt;&lt; Rect.getArea() &lt;&lt; endl;
 // Print the total cost of painting
 cout &lt;&lt; "Total paint cost: $" &lt;&lt; Rect.getCost(area) &lt;&lt; endl;
 return 0;
C++
195
}
When the above code is compiled and executed, it produces the following result:
Total area: 35
Total paint cost: $2450
C++
196
C++ allows you to specify more than one definition for a function name or
an operator in the same scope, which is called function
overloading and operator overloading respectively.
An overloaded declaration is a declaration that is declared with the same name
as a previously declared declaration in the same scope, except that both
declarations have different arguments and obviously different definition
(implementation).
When you call an overloaded function or operator, the compiler determines the
most appropriate definition to use, by comparing the argument types you have
used to call the function or operator with the parameter types specified in the
definitions. The process of selecting the most appropriate overloaded function or
operator is called overload resolution.
Function Overloading in C++
You can have multiple definitions for the same function name in the same scope.
The definition of the function must differ from each other by the types and/or
the number of arguments in the argument list. You cannot overload function
declarations that differ only by return type.
Following is the example where same function print() is being used to print
different data types:
#include &lt;iostream&gt;
using namespace std;
class printData
{
 public:
 void print(int i) {
 cout &lt;&lt; "Printing int: " &lt;&lt; i &lt;&lt; endl;
 }
 void print(double f) {
 cout &lt;&lt; "Printing float: " &lt;&lt; f &lt;&lt; endl;
 }
25. OVERLOADING (OPERATOR &amp;
FUNCTION)
C++
197
 void print(char* c) {
 cout &lt;&lt; "Printing character: " &lt;&lt; c &lt;&lt; endl;
 }
};
int main(void)
{
 printData pd;
 // Call print to print integer
 pd.print(5);
 // Call print to print float
 pd.print(500.263);
 // Call print to print character
 pd.print("Hello C++");
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Printing int: 5
Printing float: 500.263
Printing character: Hello C++
Operators Overloading in C++
You can redefine or overload most of the built-in operators available in C++.
Thus, a programmer can use operators with user-defined types as well.
Overloaded operators are functions with special names the keyword operator
followed by the symbol for the operator being defined. Like any other function,
an overloaded operator has a return type and a parameter list.
Box operator+(const Box&amp;);
Declares the addition operator that can be used to add two Box objects and
returns final Box object. Most overloaded operators may be defined as ordinary
non-member functions or as class member functions. In case we define above
function as non-member function of a class then we would have to pass two
arguments for each operand as follows:
C++
198
Box operator+(const Box&amp;, const Box&amp;);
Following is the example to show the concept of operator over loading using a
member function. Here an object is passed as an argument whose properties will
be accessed using this object, the object which will call this operator can be
accessed using this operator as explained below:
#include &lt;iostream&gt;
using namespace std;
class Box
{
 public:
 double getVolume(void)
 {
 return length * breadth * height;
 }
 void setLength( double len )
 {
 length = len;
 }
 void setBreadth( double bre )
 {
 breadth = bre;
 }
 void setHeight( double hei )
 {
 height = hei;
 }
 // Overload + operator to add two Box objects.
 Box operator+(const Box&amp; b)
 {
 Box box;
C++
199
 box.length = this-&gt;length + b.length;
 box.breadth = this-&gt;breadth + b.breadth;
 box.height = this-&gt;height + b.height;
 return box;
 }
 private:
 double length; // Length of a box
 double breadth; // Breadth of a box
 double height; // Height of a box
};
// Main function for the program
int main( )
{
 Box Box1; // Declare Box1 of type Box
 Box Box2; // Declare Box2 of type Box
 Box Box3; // Declare Box3 of type Box
 double volume = 0.0; // Store the volume of a box here
 // box 1 specification
 Box1.setLength(6.0);
 Box1.setBreadth(7.0);
 Box1.setHeight(5.0);
 // box 2 specification
 Box2.setLength(12.0);
 Box2.setBreadth(13.0);
 Box2.setHeight(10.0);
 // volume of box 1
 volume = Box1.getVolume();
 cout &lt;&lt; "Volume of Box1 : " &lt;&lt; volume &lt;&lt;endl;
 // volume of box 2
 volume = Box2.getVolume();
C++
200
 cout &lt;&lt; "Volume of Box2 : " &lt;&lt; volume &lt;&lt;endl;
 // Add two object as follows:
 Box3 = Box1 + Box2;
 // volume of box 3
 volume = Box3.getVolume();
 cout &lt;&lt; "Volume of Box3 : " &lt;&lt; volume &lt;&lt;endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Volume of Box1 : 210
Volume of Box2 : 1560
Volume of Box3 : 5400
Overloadable/Non-overloadable Operators
Following is the list of operators which can be overloaded:
+ - * / % ^
&amp; | ~ ! , =
&lt; &gt; &lt;= &gt;= ++ --
&lt;&lt; &gt;&gt; == != &amp;&amp; ||
+= -= /= %= ^= &amp;=
|= *= &lt;&lt;= &gt;&gt;= [] ()
-&gt; -&gt;* new new [] delete delete []
Following is the list of operators, which cannot be overloaded:
C++
201
:: .* . ?:
Operator Overloading Examples
Here are various operator overloading examples to help you in understanding
the concept.
S.N. Operators and Example
1 Unary operators overloading
2 Binary operators overloading
3 Relational operators overloading
4 Input/Output operators overloading
5 ++ and -- operators overloading
6 Assignment operators overloading
7 Function call () operator overloading
8 Subscripting [] operator overloading
9 Class member access operator -&gt; overloading
Unary Operators Overloading
The unary operators operate on a single operand and following are the examples
of Unary operators:
 The increment (++) and decrement (--) operators.
 The unary minus (-) operator.
 The logical not (!) operator.
The unary operators operate on the object for which they were called and
normally, this operator appears on the left side of the object, as in !obj, -obj,
and ++obj but sometime they can be used as postfix as well like obj++ or obj--.
Following example explain how minus (-) operator can be overloaded for prefix
as well as postfix usage.
C++
202
#include &lt;iostream&gt;
using namespace std;
class Distance
{
 private:
 int feet; // 0 to infinite
 int inches; // 0 to 12
 public:
 // required constructors
 Distance(){
 feet = 0;
 inches = 0;
 }
 Distance(int f, int i){
 feet = f;
 inches = i;
 }
 // method to display distance
 void displayDistance()
 {
 cout &lt;&lt; "F: " &lt;&lt; feet &lt;&lt; " I:" &lt;&lt; inches &lt;&lt;endl;
 }
 // overloaded minus (-) operator
 Distance operator- ()
 {
 feet = -feet;
 inches = -inches;
 return Distance(feet, inches);
 }
};
int main()
{
 Distance D1(11, 10), D2(-5, 11);
C++
203
 -D1; // apply negation
 D1.displayDistance(); // display D1
 -D2; // apply negation
 D2.displayDistance(); // display D2
 return 0;
}
When the above code is compiled and executed, it produces the following result:
F: -11 I:-10
F: 5 I:-11
Hope above example makes your concept clear and you can apply similar
concept to overload Logical Not Operators (!).
Increment (++) and Decrement (- -) Operators
The increment (++) and decrement (--) operators are two important unary
operators available in C++.
Following example explain how increment (++) operator can be overloaded for
prefix as well as postfix usage. Similar way, you can overload operator (--).
#include &lt;iostream&gt;
using namespace std;
class Time
{
 private:
 int hours; // 0 to 23
 int minutes; // 0 to 59
 public:
 // required constructors
 Time(){
 hours = 0;
 minutes = 0;
 }
C++
204
 Time(int h, int m){
 hours = h;
 minutes = m;
 }
 // method to display time
 void displayTime()
 {
 cout &lt;&lt; "H: " &lt;&lt; hours &lt;&lt; " M:" &lt;&lt; minutes &lt;&lt;endl;
 }
 // overloaded prefix ++ operator
 Time operator++ ()
 {
 ++minutes; // increment this object
 if(minutes &gt;= 60)
 {
 ++hours;
 minutes -= 60;
 }
 return Time(hours, minutes);
 }
 // overloaded postfix ++ operator
 Time operator++( int )
 {
 // save the orignal value
 Time T(hours, minutes);
 // increment this object
 ++minutes;
 if(minutes &gt;= 60)
 {
 ++hours;
 minutes -= 60;
 }
 // return old original value
 return T;
C++
205
 }
};
int main()
{
 Time T1(11, 59), T2(10,40);
 ++T1; // increment T1
 T1.displayTime(); // display T1
 ++T1; // increment T1 again
 T1.displayTime(); // display T1
 T2++; // increment T2
 T2.displayTime(); // display T2
 T2++; // increment T2 again
 T2.displayTime(); // display T2
 return 0;
}
When the above code is compiled and executed, it produces the following result:
H: 12 M:0
H: 12 M:1
H: 10 M:41
H: 10 M:42
Binary Operators Overloading
The unary operators take two arguments and following are the examples of
Binary operators. You use binary operators very frequently like addition (+)
operator, subtraction (-) operator and division (/) operator.
Following example explains how addition (+) operator can be overloaded.
Similar way, you can overload subtraction (-) and division (/) operators.
#include &lt;iostream&gt;
using namespace std;
C++
206
class Box
{
 double length; // Length of a box
 double breadth; // Breadth of a box
 double height; // Height of a box
public:
 double getVolume(void)
 {
 return length * breadth * height;
 }
 void setLength( double len )
 {
 length = len;
 }
 void setBreadth( double bre )
 {
 breadth = bre;
 }
 void setHeight( double hei )
 {
 height = hei;
 }
 // Overload + operator to add two Box objects.
 Box operator+(const Box&amp; b)
 {
 Box box;
 box.length = this-&gt;length + b.length;
 box.breadth = this-&gt;breadth + b.breadth;
 box.height = this-&gt;height + b.height;
 return box;
C++
207
 }
};
// Main function for the program
int main( )
{
 Box Box1; // Declare Box1 of type Box
 Box Box2; // Declare Box2 of type Box
 Box Box3; // Declare Box3 of type Box
 double volume = 0.0; // Store the volume of a box here
 // box 1 specification
 Box1.setLength(6.0);
 Box1.setBreadth(7.0);
 Box1.setHeight(5.0);
 // box 2 specification
 Box2.setLength(12.0);
 Box2.setBreadth(13.0);
 Box2.setHeight(10.0);
 // volume of box 1
 volume = Box1.getVolume();
 cout &lt;&lt; "Volume of Box1 : " &lt;&lt; volume &lt;&lt;endl;
 // volume of box 2
 volume = Box2.getVolume();
 cout &lt;&lt; "Volume of Box2 : " &lt;&lt; volume &lt;&lt;endl;
 // Add two object as follows:
 Box3 = Box1 + Box2;
 // volume of box 3
 volume = Box3.getVolume();
 cout &lt;&lt; "Volume of Box3 : " &lt;&lt; volume &lt;&lt;endl;
C++
208
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Volume of Box1 : 210
Volume of Box2 : 1560
Volume of Box3 : 5400
Relational Operators Overloading
There are various relational operators supported by C++ language like (&lt;, &gt;,
&lt;=, &gt;=, ==, etc.) which can be used to compare C++ built-in data types.
You can overload any of these operators, which can be used to compare the
objects of a class.
Following example explains how a &lt; operator can be overloaded and similar way
you can overload other relational operators.
#include &lt;iostream&gt;
using namespace std;
class Distance
{
 private:
 int feet; // 0 to infinite
 int inches; // 0 to 12
 public:
 // required constructors
 Distance(){
 feet = 0;
 inches = 0;
 }
 Distance(int f, int i){
 feet = f;
 inches = i;
 }
 // method to display distance
C++
209
 void displayDistance()
 {
 cout &lt;&lt; "F: " &lt;&lt; feet &lt;&lt; " I:" &lt;&lt; inches &lt;&lt;endl;
 }
 // overloaded minus (-) operator
 Distance operator- ()
 {
 feet = -feet;
 inches = -inches;
 return Distance(feet, inches);
 }
 // overloaded &lt; operator
 bool operator &lt;(const Distance&amp; d)
 {
 if(feet &lt; d.feet)
 {
 return true;
 }
 if(feet == d.feet &amp;&amp; inches &lt; d.inches)
 {
 return true;
 }
 return false;
 }
};
int main()
{
 Distance D1(11, 10), D2(5, 11);
 if( D1 &lt; D2 )
 {
 cout &lt;&lt; "D1 is less than D2 " &lt;&lt; endl;
 }
 else
C++
210
 {
 cout &lt;&lt; "D2 is less than D1 " &lt;&lt; endl;
 }
 return 0;
}
When the above code is compiled and executed, it produces the following result:
D2 is less than D1
Input/Output Operators Overloading
C++ is able to input and output the built-in data types using the stream
extraction operator &gt;&gt; and the stream insertion operator &lt;&lt;. The stream
insertion and stream extraction operators also can be overloaded to perform
input and output for user-defined types like an object.
Here, it is important to make operator overloading function a friend of the class
because it would be called without creating an object.
Following example explains how extraction operator &gt;&gt; and insertion operator
&lt;&lt;.
#include &lt;iostream&gt;
using namespace std;
class Distance
{
 private:
 int feet; // 0 to infinite
 int inches; // 0 to 12
 public:
 // required constructors
 Distance(){
 feet = 0;
 inches = 0;
 }
 Distance(int f, int i){
 feet = f;
 inches = i;
C++
211
 }
 friend ostream &amp;operator&lt;&lt;( ostream &amp;output,
 const Distance &amp;D )
 {
 output &lt;&lt; "F : " &lt;&lt; D.feet &lt;&lt; " I : " &lt;&lt; D.inches;
 return output;
 }
 friend istream &amp;operator&gt;&gt;( istream &amp;input, Distance &amp;D )
 {
 input &gt;&gt; D.feet &gt;&gt; D.inches;
 return input;
 }
};
int main()
{
 Distance D1(11, 10), D2(5, 11), D3;
 cout &lt;&lt; "Enter the value of object : " &lt;&lt; endl;
 cin &gt;&gt; D3;
 cout &lt;&lt; "First Distance : " &lt;&lt; D1 &lt;&lt; endl;
 cout &lt;&lt; "Second Distance :" &lt;&lt; D2 &lt;&lt; endl;
 cout &lt;&lt; "Third Distance :" &lt;&lt; D3 &lt;&lt; endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
$./a.out
Enter the value of object :
70
10
First Distance : F : 11 I : 10
C++
212
Second Distance :F : 5 I : 11
Third Distance :F : 70 I : 10
++ and - - Operators Overloading
The increment (++) and decrement (--) operators are two important unary
operators available in C++.
Following example explain how increment (++) operator can be overloaded for
prefix as well as postfix usage. Similar way, you can overload operator (--).
#include &lt;iostream&gt;
using namespace std;
class Time
{
 private:
 int hours; // 0 to 23
 int minutes; // 0 to 59
 public:
 // required constructors
 Time(){
 hours = 0;
 minutes = 0;
 }
 Time(int h, int m){
 hours = h;
 minutes = m;
 }
 // method to display time
 void displayTime()
 {
 cout &lt;&lt; "H: " &lt;&lt; hours &lt;&lt; " M:" &lt;&lt; minutes &lt;&lt;endl;
 }
 // overloaded prefix ++ operator
 Time operator++ ()
 {
C++
213
 ++minutes; // increment this object
 if(minutes &gt;= 60)
 {
 ++hours;
 minutes -= 60;
 }
 return Time(hours, minutes);
 }
 // overloaded postfix ++ operator
 Time operator++( int )
 {
 // save the orignal value
 Time T(hours, minutes);
 // increment this object
 ++minutes;
 if(minutes &gt;= 60)
 {
 ++hours;
 minutes -= 60;
 }
 // return old original value
 return T;
 }
};
int main()
{
 Time T1(11, 59), T2(10,40);
 ++T1; // increment T1
 T1.displayTime(); // display T1
 ++T1; // increment T1 again
 T1.displayTime(); // display T1
 T2++; // increment T2
C++
214
 T2.displayTime(); // display T2
 T2++; // increment T2 again
 T2.displayTime(); // display T2
 return 0;
}
When the above code is compiled and executed, it produces the following result:
H: 12 M:0
H: 12 M:1
H: 10 M:41
H: 10 M:42
Assignment Operators Overloading
You can overload the assignment operator (=) just as you can other operators
and it can be used to create an object just like the copy constructor.
Following example explains how an assignment operator can be overloaded.
#include &lt;iostream&gt;
using namespace std;
class Distance
{
 private:
 int feet; // 0 to infinite
 int inches; // 0 to 12
 public:
 // required constructors
 Distance(){
 feet = 0;
 inches = 0;
 }
 Distance(int f, int i){
 feet = f;
 inches = i;
 }
C++
215
 void operator=(const Distance &amp;D )
 {
 feet = D.feet;
 inches = D.inches;
 }
 // method to display distance
 void displayDistance()
 {
 cout &lt;&lt; "F: " &lt;&lt; feet &lt;&lt; " I:" &lt;&lt; inches &lt;&lt; endl;
 }

};
int main()
{
 Distance D1(11, 10), D2(5, 11);
 cout &lt;&lt; "First Distance : ";
 D1.displayDistance();
 cout &lt;&lt; "Second Distance :";
 D2.displayDistance();
 // use assignment operator
 D1 = D2;
 cout &lt;&lt; "First Distance :";
 D1.displayDistance();
 return 0;
}
When the above code is compiled and executed, it produces the following result:
First Distance : F: 11 I:10
Second Distance :F: 5 I:11
First Distance :F: 5 I:11
Function Call () Operator Overloading
C++
216
The function call operator () can be overloaded for objects of class type. When
you overload ( ), you are not creating a new way to call a function. Rather, you
are creating an operator function that can be passed an arbitrary number of
parameters.
Following example explains how a function call operator () can be overloaded.
#include &lt;iostream&gt;
using namespace std;
class Distance
{
 private:
 int feet; // 0 to infinite
 int inches; // 0 to 12
 public:
 // required constructors
 Distance(){
 feet = 0;
 inches = 0;
 }
 Distance(int f, int i){
 feet = f;
 inches = i;
 }
 // overload function call
 Distance operator()(int a, int b, int c)
 {
 Distance D;
 // just put random calculation
 D.feet = a + c + 10;
 D.inches = b + c + 100 ;
 return D;
 }
 // method to display distance
 void displayDistance()
 {
C++
217
 cout &lt;&lt; "F: " &lt;&lt; feet &lt;&lt; " I:" &lt;&lt; inches &lt;&lt; endl;
 }

};
int main()
{
 Distance D1(11, 10), D2;
 cout &lt;&lt; "First Distance : ";
 D1.displayDistance();
 D2 = D1(10, 10, 10); // invoke operator()
 cout &lt;&lt; "Second Distance :";
 D2.displayDistance();
 return 0;
}
When the above code is compiled and executed, it produces the following result:
First Distance : F: 11 I:10
Second Distance :F: 30 I:120
Subscripting [ ] Operator Overloading
The subscript operator [] is normally used to access array elements. This
operator can be overloaded to enhance the existing functionality of C++ arrays.
Following example explains how a subscript operator [] can be overloaded.
#include &lt;iostream&gt;
using namespace std;
const int SIZE = 10;
class safearay
{
 private:
C++
218
 int arr[SIZE];
 public:
 safearay()
 {
 register int i;
 for(i = 0; i &lt; SIZE; i++)
 {
 arr[i] = i;
 }
 }
 int &amp;operator[](int i)
 {
 if( i &gt; SIZE )
 {
 cout &lt;&lt; "Index out of bounds" &lt;&lt;endl;
 // return first element.
 return arr[0];
 }
 return arr[i];
 }
};
int main()
{
 safearay A;
 cout &lt;&lt; "Value of A[2] : " &lt;&lt; A[2] &lt;&lt;endl;
 cout &lt;&lt; "Value of A[5] : " &lt;&lt; A[5]&lt;&lt;endl;
 cout &lt;&lt; "Value of A[12] : " &lt;&lt; A[12]&lt;&lt;endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Value of A[2] : 2
C++
219
Value of A[5] : 5
Index out of bounds
Value of A[12] : 0
Class Member Access Operator - &gt; Overloading
The class member access operator (-&gt;) can be overloaded but it is bit trickier. It
is defined to give a class type a "pointer-like" behavior. The operator -&gt; must be
a member function. If used, its return type must be a pointer or an object of a
class to which you can apply.
The operator-&gt; is used often in conjunction with the pointer-dereference
operator * to implement "smart pointers." These pointers are objects that
behave like normal pointers except they perform other tasks when you access
an object through them, such as automatic object deletion either when the
pointer is destroyed, or the pointer is used to point to another object.
The dereferencing operator-&gt; can be defined as a unary postfix operator. That
is, given a class:
class Ptr{
 //...
 X * operator-&gt;();
};
Objects of class Ptr can be used to access members of class X in a very similar
manner to the way pointers are used. For example:
void f(Ptr p )
{
 p-&gt;m = 10 ; // (p.operator-&gt;())-&gt;m = 10
}
The statement p-&gt;m is interpreted as (p.operator-&gt;())-&gt;m. Using the same
concept, following example explains how a class access operator -&gt; can be
overloaded.
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
// Consider an actual class.
class Obj {
C++
220
 static int i, j;
public:
 void f() const { cout &lt;&lt; i++ &lt;&lt; endl; }
 void g() const { cout &lt;&lt; j++ &lt;&lt; endl; }
};
// Static member definitions:
int Obj::i = 10;
int Obj::j = 12;
// Implement a container for the above class
class ObjContainer {
 vector&lt;Obj*&gt; a;
public:
 void add(Obj* obj)
 {
 a.push_back(obj); // call vector's standard method.
 }
 friend class SmartPointer;
};
// implement smart pointer to access member of Obj class.
class SmartPointer {
 ObjContainer oc;
 int index;
public:
 SmartPointer(ObjContainer&amp; objc)
 {
 oc = objc;
 index = 0;
 }
 // Return value indicates end of list:
 bool operator++() // Prefix version
 {
C++
221
 if(index &gt;= oc.a.size()) return false;
 if(oc.a[++index] == 0) return false;
 return true;
 }
 bool operator++(int) // Postfix version
 {
 return operator++();
 }
 // overload operator-&gt;
 Obj* operator-&gt;() const
 {
 if(!oc.a[index])
 {
 cout &lt;&lt; "Zero value";
 return (Obj*)0;
 }
 return oc.a[index];
 }
};
int main() {
 const int sz = 10;
 Obj o[sz];
 ObjContainer oc;
 for(int i = 0; i &lt; sz; i++)
 {
 oc.add(&amp;o[i]);
 }
 SmartPointer sp(oc); // Create an iterator
 do {
 sp-&gt;f(); // smart pointer call
 sp-&gt;g();
 } while(sp++);
 return 0;
C++
222
}
When the above code is compiled and executed, it produces the following result:
10
12
11
13
12
14
13
15
14
16
15
17
16
18
17
19
18
20
19
21
C++
223
The word polymorphism means having many forms. Typically, polymorphism
occurs when there is a hierarchy of classes and they are related by inheritance.
C++ polymorphism means that a call to a member function will cause a different
function to be executed depending on the type of object that invokes the
function.
Consider the following example where a base class has been derived by other
two classes:
#include &lt;iostream&gt;
using namespace std;
class Shape {
 protected:
 int width, height;
 public:
 Shape( int a=0, int b=0)
 {
 width = a;
 height = b;
 }
 int area()
 {
 cout &lt;&lt; "Parent class area :" &lt;&lt;endl;
 return 0;
 }
};
class Rectangle: public Shape{
 public:
 Rectangle( int a=0, int b=0):Shape(a, b) { }
 int area ()
 {
 cout &lt;&lt; "Rectangle class area :" &lt;&lt;endl;
26. POLYMORPHISM
C++
224
 return (width * height);
 }
};
class Triangle: public Shape{
 public:
 Triangle( int a=0, int b=0):Shape(a, b) { }
 int area ()
 {
 cout &lt;&lt; "Triangle class area :" &lt;&lt;endl;
 return (width * height / 2);
 }
};
// Main function for the program
int main( )
{
 Shape *shape;
 Rectangle rec(10,7);
 Triangle tri(10,5);
 // store the address of Rectangle
 shape = &amp;rec;
 // call rectangle area.
 shape-&gt;area();
 // store the address of Triangle
 shape = &amp;tri;
 // call triangle area.
 shape-&gt;area();

 return 0;
}
C++
225
When the above code is compiled and executed, it produces the following result:
Parent class area
Parent class area
The reason for the incorrect output is that the call of the function area() is being
set once by the compiler as the version defined in the base class. This is
called static resolution of the function call, or static linkage - the function call
is fixed before the program is executed. This is also sometimes called early
binding because the area() function is set during the compilation of the
program.
But now, let's make a slight modification in our program and precede the
declaration of area() in the Shape class with the keyword virtual so that it looks
like this:
class Shape {
 protected:
 int width, height;
 public:
 Shape( int a=0, int b=0)
 {
 width = a;
 height = b;
 }
 virtual int area()
 {
 cout &lt;&lt; "Parent class area :" &lt;&lt;endl;
 return 0;
 }
};
After this slight modification, when the previous example code is compiled and
executed, it produces the following result:
Rectangle class area
Triangle class area
This time, the compiler looks at the contents of the pointer instead of its type.
Hence, since addresses of objects of tri and rec classes are stored in *shape the
respective area() function is called.
C++
226
As you can see, each of the child classes has a separate implementation for the
function area(). This is how polymorphism is generally used. You have different
classes with a function of the same name, and even the same parameters, but
with different implementations.
Virtual Function
A virtual function is a function in a base class that is declared using the
keyword virtual. Defining in a base class a virtual function, with another version
in a derived class, signals to the compiler that we don't want static linkage for
this function.
What we do want is the selection of the function to be called at any given point
in the program to be based on the kind of object for which it is called. This sort
of operation is referred to as dynamic linkage, or late binding.
Pure Virtual Functions
It is possible that you want to include a virtual function in a base class so that it
may be redefined in a derived class to suit the objects of that class, but that
there is no meaningful definition you could give for the function in the base
class.
We can change the virtual function area() in the base class to the following:
class Shape {
 protected:
 int width, height;
 public:
 Shape( int a=0, int b=0)
 {
 width = a;
 height = b;
 }
 // pure virtual function
 virtual int area() = 0;
};
The = 0 tells the compiler that the function has no body and above virtual
function will be called pure virtual function.
C++
227
Data abstraction refers to providing only essential information to the outside
world and hiding their background details, i.e., to represent the needed
information in program without presenting the details.
Data abstraction is a programming (and design) technique that relies on the
separation of interface and implementation.
Let's take one real life example of a TV, which you can turn on and off, change
the channel, adjust the volume, and add external components such as speakers,
VCRs, and DVD players, BUT you do not know its internal details, that is, you do
not know how it receives signals over the air or through a cable, how it
translates them, and finally displays them on the screen.
Thus, we can say a television clearly separates its internal implementation from
its external interface and you can play with its interfaces like the power button,
channel changer, and volume control without having zero knowledge of its
internals.
In C++, classes provides great level of data abstraction. They provide
sufficient public methods to the outside world to play with the functionality of
the object and to manipulate object data, i.e., state without actually knowing
how class has been implemented internally.
For example, your program can make a call to the sort() function without
knowing what algorithm the function actually uses to sort the given values. In
fact, the underlying implementation of the sorting functionality could change
between releases of the library, and as long as the interface stays the same,
your function call will still work.
In C++, we use classes to define our own abstract data types (ADT). You can
use the cout object of class ostream to stream data to standard output like
this:
#include &lt;iostream&gt;
using namespace std;
int main( )
{
 cout &lt;&lt; "Hello C++" &lt;&lt;endl;
 return 0;
}
27. DATA ABSTRACTION
C++
228
Here, you don't need to understand how cout displays the text on the user's
screen. You need to only know the public interface and the underlying
implementation of ‘cout’ is free to change.
Access Labels Enforce Abstraction
In C++, we use access labels to define the abstract interface to the class. A
class may contain zero or more access labels:
 Members defined with a public label are accessible to all parts of the
program. The data-abstraction view of a type is defined by its public
members.
 Members defined with a private label are not accessible to code that uses
the class. The private sections hide the implementation from code that
uses the type.
There are no restrictions on how often an access label may appear. Each access
label specifies the access level of the succeeding member definitions. The
specified access level remains in effect until the next access label is encountered
or the closing right brace of the class body is seen.
Benefits of Data Abstraction
Data abstraction provides two important advantages:
 Class internals are protected from inadvertent user-level errors, which
might corrupt the state of the object.
 The class implementation may evolve over time in response to changing
requirements or bug reports without requiring change in user-level code.
By defining data members only in the private section of the class, the class
author is free to make changes in the data. If the implementation changes, only
the class code needs to be examined to see what affect the change may have. If
data is public, then any function that directly access the data members of the
old representation might be broken.
Data Abstraction Example
Any C++ program where you implement a class with public and private
members is an example of data abstraction. Consider the following example:
#include &lt;iostream&gt;
using namespace std;
class Adder{
 public:
 // constructor
 Adder(int i = 0)
C++
229
 {
 total = i;
 }
 // interface to outside world
 void addNum(int number)
 {
 total += number;
 }
 // interface to outside world
 int getTotal()
 {
 return total;
 };
 private:
 // hidden data from outside world
 int total;
};
int main( )
{
 Adder a;

 a.addNum(10);
 a.addNum(20);
 a.addNum(30);
 cout &lt;&lt; "Total " &lt;&lt; a.getTotal() &lt;&lt;endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Total 60
Above class adds numbers together, and returns the sum. The public members -
addNum and getTotal are the interfaces to the outside world and a user needs
to know them to use the class. The private member total is something that the
user doesn't need to know about, but is needed for the class to operate properly.
C++
230
Designing Strategy
Abstraction separates code into interface and implementation. So while
designing your component, you must keep interface independent of the
implementation so that if you change underlying implementation then interface
would remain intact.
In this case whatever programs are using these interfaces, they would not be
impacted and would just need a recompilation with the latest implementation.
C++
231
All C++ programs are composed of the following two fundamental elements:
 Program statements (code): This is the part of a program that
performs actions and they are called functions.
 Program data: The data is the information of the program which gets
affected by the program functions.
Encapsulation is an Object Oriented Programming concept that binds together
the data and functions that manipulate the data, and that keeps both safe from
outside interference and misuse. Data encapsulation led to the important OOP
concept of data hiding.
Data encapsulation is a mechanism of bundling the data, and the functions
that use them and data abstraction is a mechanism of exposing only the
interfaces and hiding the implementation details from the user.
C++ supports the properties of encapsulation and data hiding through the
creation of user-defined types, called classes. We already have studied that a
class can contain private, protected and public members. By default, all items
defined in a class are private. For example:
class Box
{
 public:
 double getVolume(void)
 {
 return length * breadth * height;
 }
 private:
 double length; // Length of a box
 double breadth; // Breadth of a box
 double height; // Height of a box
};
The variables length, breadth, and height are private. This means that they can
be accessed only by other members of the Box class, and not by any other part
of your program. This is one way encapsulation is achieved.
To make parts of a class public (i.e., accessible to other parts of your program),
you must declare them after the public keyword. All variables or functions
28. DATA ENCAPSULATION
C++
232
defined after the public specifier are accessible by all other functions in your
program.
Making one class a friend of another, exposes the implementation details and
reduces encapsulation. The ideal is to keep as many of the details of each class
hidden from all other classes as possible.
Data Encapsulation Example
Any C++ program where you implement a class with public and private
members is an example of data encapsulation and data abstraction. Consider the
following example:
#include &lt;iostream&gt;
using namespace std;
class Adder{
 public:
 // constructor
 Adder(int i = 0)
 {
 total = i;
 }
 // interface to outside world
 void addNum(int number)
 {
 total += number;
 }
 // interface to outside world
 int getTotal()
 {
 return total;
 };
 private:
 // hidden data from outside world
 int total;
};
int main( )
{
C++
233
 Adder a;

 a.addNum(10);
 a.addNum(20);
 a.addNum(30);
 cout &lt;&lt; "Total " &lt;&lt; a.getTotal() &lt;&lt;endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Total 60
Above class adds numbers together, and returns the sum. The public members -
addNum and getTotal are the interfaces to the outside world and a user needs
to know them to use the class. The private member total is something that is
hidden from the outside world, but is needed for the class to operate properly.
Designing Strategy
Most of us have learnt to make class members private by default unless we
really need to expose them. That's just good encapsulation.
This is applied most frequently to data members, but it applies equally to all
members, including virtual functions.
C++
234
An interface describes the behavior or capabilities of a C++ class without
committing to a particular implementation of that class.
The C++ interfaces are implemented using abstract classes and these abstract
classes should not be confused with data abstraction which is a concept of
keeping implementation details separate from associated data.
A class is made abstract by declaring at least one of its functions as pure
virtual function. A pure virtual function is specified by placing "= 0" in its
declaration as follows:
class Box
{
 public:
 // pure virtual function
 virtual double getVolume() = 0;
 private:
 double length; // Length of a box
 double breadth; // Breadth of a box
 double height; // Height of a box
};
The purpose of an abstract class (often referred to as an ABC) is to provide an
appropriate base class from which other classes can inherit. Abstract classes
cannot be used to instantiate objects and serves only as an interface.
Attempting to instantiate an object of an abstract class causes a compilation
error.
Thus, if a subclass of an ABC needs to be instantiated, it has to implement each
of the virtual functions, which means that it supports the interface declared by
the ABC. Failure to override a pure virtual function in a derived class, then
attempting to instantiate objects of that class, is a compilation error.
Classes that can be used to instantiate objects are called concrete classes.
Abstract Class Example
Consider the following example where parent class provides an interface to the
base class to implement a function called getArea():
#include &lt;iostream&gt;
29. INTERFACES
C++
235
using namespace std;
// Base class
class Shape
{
public:
 // pure virtual function providing interface framework.
 virtual int getArea() = 0;
 void setWidth(int w)
 {
 width = w;
 }
 void setHeight(int h)
 {
 height = h;
 }
protected:
 int width;
 int height;
};
// Derived classes
class Rectangle: public Shape
{
public:
 int getArea()
 {
 return (width * height);
 }
};
class Triangle: public Shape
{
public:
C++
236
 int getArea()
 {
 return (width * height)/2;
 }
};
int main(void)
{
 Rectangle Rect;
 Triangle Tri;
 Rect.setWidth(5);
 Rect.setHeight(7);
 // Print the area of the object.
 cout &lt;&lt; "Total Rectangle area: " &lt;&lt; Rect.getArea() &lt;&lt; endl;
 Tri.setWidth(5);
 Tri.setHeight(7);
 // Print the area of the object.
 cout &lt;&lt; "Total Triangle area: " &lt;&lt; Tri.getArea() &lt;&lt; endl;
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Total Rectangle area: 35
Total Triangle area: 17
You can see how an abstract class defined an interface in terms of getArea() and
two other classes implemented same function but with different algorithm to
calculate the area specific to the shape.
Designing Strategy
An object-oriented system might use an abstract base class to provide a
common and standardized interface appropriate for all the external applications.
Then, through inheritance from that abstract base class, derived classes are
formed that operate similarly.
C++
237
The capabilities (i.e., the public functions) offered by the external applications
are provided as pure virtual functions in the abstract base class. The
implementations of these pure virtual functions are provided in the derived
classes that correspond to the specific types of the application.
This architecture also allows new applications to be added to a system easily,
even after the system has been defined.
C++
238
So far, we have been using the iostream standard library, which
provides cin and cout methods for reading from standard input and writing to
standard output respectively.
This tutorial will teach you how to read and write from a file. This requires
another standard C++ library called fstream, which defines three new data
types:
Data Type Description
ofstream This data type represents the output file stream and is
used to create files and to write information to files.
ifstream This data type represents the input file stream and is
used to read information from files.
fstream This data type represents the file stream generally,
and has the capabilities of both ofstream and ifstream
which means it can create files, write information to
files, and read information from files.
To perform file processing in C++, header files &lt;iostream&gt; and &lt;fstream&gt; must
be included in your C++ source file.
Opening a File
A file must be opened before you can read from it or write to it. Either
ofstream or fstream object may be used to open a file for writing. And ifstream
object is used to open a file for reading purpose only.
Following is the standard syntax for open() function, which is a member of
fstream, ifstream, and ofstream objects.
void open(const char *filename, ios::openmode mode);
Here, the first argument specifies the name and location of the file to be opened
and the second argument of the open() member function defines the mode in
which the file should be opened.
Mode Flag Description
30. FILES AND STREAMS
C++
239
ios::app Append mode. All output to that file to be appended to
the end.
ios::ate Open a file for output and move the read/write control
to the end of the file.
ios::in Open a file for reading.
ios::out Open a file for writing.
ios::trunc If the file already exists, its contents will be truncated
before opening the file.
You can combine two or more of these values by ORing them together. For
example if you want to open a file in write mode and want to truncate it in case
that already exists, following will be the syntax:
ofstream outfile;
outfile.open("file.dat", ios::out | ios::trunc );
Similar way, you can open a file for reading and writing purpose as follows:
fstream afile;
afile.open("file.dat", ios::out | ios::in );
Closing a File
When a C++ program terminates it automatically flushes all the streams,
release all the allocated memory and close all the opened files. But it is always a
good practice that a programmer should close all the opened files before
program termination.
Following is the standard syntax for close() function, which is a member of
fstream, ifstream, and ofstream objects.
void close();
Writing to a File
While doing C++ programming, you write information to a file from your
program using the stream insertion operator (&lt;&lt;) just as you use that operator
to output information to the screen. The only difference is that you use
an ofstream or fstream object instead of the cout object.
Reading from a File
C++
240
You read information from a file into your program using the stream extraction
operator (&gt;&gt;) just as you use that operator to input information from the
keyboard. The only difference is that you use an ifstream or fstream object
instead of the cin object.
Read &amp; Write Example
Following is the C++ program which opens a file in reading and writing mode.
After writing information entered by the user to a file named afile.dat, the
program reads information from the file and outputs it onto the screen:
#include &lt;fstream&gt;
#include &lt;iostream&gt;
using namespace std;
int main ()
{

 char data[100];
 // open a file in write mode.
 ofstream outfile;
 outfile.open("afile.dat");
 cout &lt;&lt; "Writing to the file" &lt;&lt; endl;
 cout &lt;&lt; "Enter your name: ";
 cin.getline(data, 100);
 // write inputted data into the file.
 outfile &lt;&lt; data &lt;&lt; endl;
 cout &lt;&lt; "Enter your age: ";
 cin &gt;&gt; data;
 cin.ignore();

 // again write inputted data into the file.
 outfile &lt;&lt; data &lt;&lt; endl;
C++
241
 // close the opened file.
 outfile.close();
 // open a file in read mode.
 ifstream infile;
 infile.open("afile.dat");
 cout &lt;&lt; "Reading from the file" &lt;&lt; endl;
 infile &gt;&gt; data;
 // write the data at the screen.
 cout &lt;&lt; data &lt;&lt; endl;

 // again read the data from the file and display it.
 infile &gt;&gt; data;
 cout &lt;&lt; data &lt;&lt; endl;
 // close the opened file.
 infile.close();
 return 0;
}
When the above code is compiled and executed, it produces the following
sample input and output:
$./a.out
Writing to the file
Enter your name: Zara
Enter your age: 9
Reading from the file
Zara
9
Above examples make use of additional functions from cin object, like getline()
function to read the line from outside, and ignore() function to ignore the extra
characters left by previous read statement.
C++
242
File Position Pointers
Both istream and ostream provide member functions for repositioning the fileposition pointer. These member functions are seekg ("seek get") for istream
and seekp ("seek put") for ostream.
The argument to seekg and seekp normally is a long integer. A second argument
can be specified to indicate the seek direction. The seek direction can
be ios::beg (the default) for positioning relative to the beginning of a
stream, ios::cur for positioning relative to the current position in a stream
or ios::end for positioning relative to the end of a stream.
The file-position pointer is an integer value that specifies the location in the file
as a number of bytes from the file's starting location. Some examples of
positioning the "get" file-position pointer are:
// position to the nth byte of fileObject (assumes ios::beg)
fileObject.seekg( n );
// position n bytes forward in fileObject
fileObject.seekg( n, ios::cur );
// position n bytes back from end of fileObject
fileObject.seekg( n, ios::end );
// position at end of fileObject
fileObject.seekg( 0, ios::end );
C++
243
An exception is a problem that arises during the execution of a program. A C++
exception is a response to an exceptional circumstance that arises while a
program is running, such as an attempt to divide by zero.
Exceptions provide a way to transfer control from one part of a program to
another. C++ exception handling is built upon three keywords: try,
catch, and throw.
 throw: A program throws an exception when a problem shows up. This is
done using a throw keyword.
 catch: A program catches an exception with an exception handler at the
place in a program where you want to handle the problem.
The catch keyword indicates the catching of an exception.
 try: A try block identifies a block of code for which particular exceptions
will be activated. It is followed by one or more catch blocks.
Assuming a block will raise an exception, a method catches an exception using a
combination of the try and catch keywords. A try/catch block is placed around
the code that might generate an exception. Code within a try/catch block is
referred to as protected code, and the syntax for using try/catch is as follows:
try
{
 // protected code
}catch( ExceptionName e1 )
{
 // catch block
}catch( ExceptionName e2 )
{
 // catch block
}catch( ExceptionName eN )
{
 // catch block
}
You can list down multiple catch statements to catch different type of exceptions
in case your try block raises more than one exception in different situations.
31. EXCEPTION HANDLING
C++
244
Throwing Exceptions
Exceptions can be thrown anywhere within a code block using throw statement.
The operand of the throw statement determines a type for the exception and can
be any expression and the type of the result of the expression determines the
type of exception thrown.
Following is an example of throwing an exception when dividing by zero
condition occurs:
double division(int a, int b)
{
 if( b == 0 )
 {
 throw "Division by zero condition!";
 }
 return (a/b);
}
Catching Exceptions
The catch block following the try block catches any exception. You can specify
what type of exception you want to catch and this is determined by the
exception declaration that appears in parentheses following the keyword catch.
try
{
 // protected code
}catch( ExceptionName e )
{
 // code to handle ExceptionName exception
}
Above code will catch an exception of ExceptionName type. If you want to
specify that a catch block should handle any type of exception that is thrown in a
try block, you must put an ellipsis, ..., between the parentheses enclosing the
exception declaration as follows:
try
{
 // protected code
}catch(...)
C++
245
{
 // code to handle any exception
}
The following is an example, which throws a division by zero exception and we
catch it in catch block.
#include &lt;iostream&gt;
using namespace std;
double division(int a, int b)
{
 if( b == 0 )
 {
 throw "Division by zero condition!";
 }
 return (a/b);
}
int main ()
{
 int x = 50;
 int y = 0;
 double z = 0;
 try {
 z = division(x, y);
 cout &lt;&lt; z &lt;&lt; endl;
 }catch (const char* msg) {
 cerr &lt;&lt; msg &lt;&lt; endl;
 }
 return 0;
}
C++
246
Because we are raising an exception of type const char*, so while catching this
exception, we have to use const char* in catch block. If we compile and run
above code, this would produce the following result:
Division by zero condition!
C++ Standard Exceptions
C++ provides a list of standard exceptions defined in &lt;exception&gt; which we
can use in our programs. These are arranged in a parent-child class hierarchy
shown below:
Here is the small description of each exception mentioned in the above
hierarchy:
Exception Description
std::exception An exception and parent class of all the standard C++
exceptions.
C++
247
std::bad_alloc This can be thrown by new.
std::bad_cast This can be thrown by dynamic_cast.
std::bad_exception This is useful device to handle unexpected exceptions
in a C++ program.
std::bad_typeid This can be thrown by typeid.
std::logic_error An exception that theoretically can be detected by
reading the code.
std::domain_error This is an exception thrown when a mathematically
invalid domain is used.
std::invalid_argument This is thrown due to invalid arguments.
std::length_error This is thrown when a too big std::string is created.
std::out_of_range This can be thrown by the ‘at’ method, for example a
std::vector and std::bitset&lt;&gt;::operator[]().
std::runtime_error An exception that theoretically cannot be detected by
reading the code.
std::overflow_error This is thrown if a mathematical overflow occurs.
std::range_error This is occurred when you try to store a value which is
out of range.
std::underflow_error This is thrown if a mathematical underflow occurs.
Define New Exceptions
You can define your own exceptions by inheriting and overriding exception class
functionality. Following is the example, which shows how you can use
std::exception class to implement your own exception in standard way:
#include &lt;iostream&gt;
#include &lt;exception&gt;
using namespace std;
C++
248
struct MyException : public exception
{
 const char * what () const throw ()
 {
 return "C++ Exception";
 }
};
int main()
{
 try
 {
 throw MyException();
 }
 catch(MyException&amp; e)
 {
 std::cout &lt;&lt; "MyException caught" &lt;&lt; std::endl;
 std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
 }
 catch(std::exception&amp; e)
 {
 //Other errors
 }
}
This would produce the following result:
MyException caught
C++ Exception
Here, what() is a public method provided by exception class and it has been
overridden by all the child exception classes. This returns the cause of an
exception.
C++
249
A good understanding of how dynamic memory really works in C++ is essential
to becoming a good C++ programmer. Memory in your C++ program is divided
into two parts:
 The stack: All variables declared inside the function will take up memory
from the stack.
 The heap: This is unused memory of the program and can be used to
allocate the memory dynamically when program runs.
Many times, you are not aware in advance how much memory you will need to
store particular information in a defined variable and the size of required
memory can be determined at run time.
You can allocate memory at run time within the heap for the variable of a given
type using a special operator in C++ which returns the address of the space
allocated. This operator is called new operator.
If you are not in need of dynamically allocated memory anymore, you can use
delete operator, which de-allocates memory previously allocated by new
operator.
The new and delete Operators
There is following generic syntax to use new operator to allocate memory
dynamically for any data-type.
new data-type;
Here, data-type could be any built-in data type including an array or any user
defined data types include class or structure. Let us start with built-in data
types. For example we can define a pointer to type double and then request that
the memory be allocated at execution time. We can do this using the new
operator with the following statements:
double* pvalue = NULL; // Pointer initialized with null
pvalue = new double; // Request memory for the variable
The memory may not have been allocated successfully, if the free store had
been used up. So it is good practice to check if new operator is returning NULL
pointer and take appropriate action as below:
32. DYNAMIC MEMORY
C++
250
double* pvalue = NULL;
if( !(pvalue = new double ))
{
 cout &lt;&lt; "Error: out of memory." &lt;&lt;endl;
 exit(1);
}
The malloc() function from C, still exists in C++, but it is recommended to
avoid using malloc() function. The main advantage of new over malloc() is that
new doesn't just allocate memory, it constructs objects which is prime purpose
of C++.
At any point, when you feel a variable that has been dynamically allocated is not
anymore required, you can free up the memory that it occupies in the free store
with the delete operator as follows:
delete pvalue; // Release memory pointed to by pvalue
Let us put above concepts and form the following example to show how new and
delete work:
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 double* pvalue = NULL; // Pointer initialized with null
 pvalue = new double; // Request memory for the variable
 *pvalue = 29494.99; // Store value at allocated address
 cout &lt;&lt; "Value of pvalue : " &lt;&lt; *pvalue &lt;&lt; endl;
 delete pvalue; // free up the memory.
 return 0;
}
If we compile and run above code, this would produce the following result:
C++
251
Value of pvalue : 29495
Dynamic Memory Allocation for Arrays
Consider you want to allocate memory for an array of characters, i.e., string of
20 characters. Using the same syntax what we have used above we can allocate
memory dynamically as shown below.
char* pvalue = NULL; // Pointer initialized with null
pvalue = new char[20]; // Request memory for the variable
To remove the array that we have just created the statement would look like
this:
delete [] pvalue; // Delete array pointed to by pvalue
Following is the syntax of new operator for a multi-dimensional array as follows:
int ROW = 2;
int COL = 3;
double **pvalue = new double* [ROW]; // Allocate memory for rows
// Now allocate memory for columns
for(int i = 0; i &lt; COL; i++) {
 pvalue[i] = new double[COL];
}
The syntax to release the memory for multi-dimensional will be as follows:
for(int i = 0; i &lt; COL; i++) {
 delete[] pvalue[i];
}
delete [] pvalue;
Dynamic Memory Allocation for Objects
Objects are no different from simple data types. For example, consider the
following code where we are going to use an array of objects to clarify the
concept:
#include &lt;iostream&gt;
using namespace std;
C++
252
class Box
{
 public:
 Box() {
 cout &lt;&lt; "Constructor called!" &lt;&lt;endl;
 }
 ~Box() {
 cout &lt;&lt; "Destructor called!" &lt;&lt;endl;
 }
};
int main( )
{
 Box* myBoxArray = new Box[4];
 delete [] myBoxArray; // Delete array
 return 0;
}
If you were to allocate an array of four Box objects, the Simple constructor
would be called four times and similarly while deleting these objects, destructor
will also be called same number of times.
If we compile and run above code, this would produce the following result:
Constructor called!
Constructor called!
Constructor called!
Constructor called!
Destructor called!
Destructor called!
Destructor called!
Destructor called!
C++
253
Consider a situation, when we have two persons with the same name, Zara, in
the same class. Whenever we need to differentiate them definitely we would
have to use some additional information along with their name, like either the
area, if they live in different area or their mother’s or father’s name, etc.
Same situation can arise in your C++ applications. For example, you might be
writing some code that has a function called xyz() and there is another library
available which is also having same function xyz(). Now the compiler has no way
of knowing which version of xyz() function you are referring to within your code.
A namespace is designed to overcome this difficulty and is used as additional
information to differentiate similar functions, classes, variables etc. with the
same name available in different libraries. Using namespace, you can define the
context in which names are defined. In essence, a namespace defines a scope.
Defining a Namespace
A namespace definition begins with the keyword namespace followed by the
namespace name as follows:
namespace namespace_name {
 // code declarations
}
To call the namespace-enabled version of either function or variable, prepend
(::) the namespace name as follows:
name::code; // code could be variable or function.
Let us see how namespace scope the entities including variable and functions:
#include &lt;iostream&gt;
using namespace std;
// first name space
namespace first_space{
 void func(){
 cout &lt;&lt; "Inside first_space" &lt;&lt; endl;
 }
}
33. NAMESPACES
C++
254
// second name space
namespace second_space{
 void func(){
 cout &lt;&lt; "Inside second_space" &lt;&lt; endl;
 }
}
int main ()
{
 // Calls function from first name space.
 first_space::func();

 // Calls function from second name space.
 second_space::func();
 return 0;
}
If we compile and run above code, this would produce the following result:
Inside first_space
Inside second_space
The using directive
You can also avoid prepending of namespaces with the using
namespace directive. This directive tells the compiler that the subsequent code
is making use of names in the specified namespace. The namespace is thus
implied for the following code:
#include &lt;iostream&gt;
using namespace std;
// first name space
namespace first_space{
 void func(){
 cout &lt;&lt; "Inside first_space" &lt;&lt; endl;
 }
C++
255
}
// second name space
namespace second_space{
 void func(){
 cout &lt;&lt; "Inside second_space" &lt;&lt; endl;
 }
}
using namespace first_space;
int main ()
{
 // This calls function from first name space.
 func();

 return 0;
}
If we compile and run above code, this would produce the following result:
Inside first_space
The ‘using’ directive can also be used to refer to a particular item within a
namespace. For example, if the only part of the std namespace that you intend
to use is cout, you can refer to it as follows:
using std::cout;
Subsequent code can refer to cout without prepending the namespace, but other
items in the std namespace will still need to be explicit as follows:
#include &lt;iostream&gt;
using std::cout;
int main ()
{
 cout &lt;&lt; "std::endl is used with std!" &lt;&lt; std::endl;

C++
256
 return 0;
}
If we compile and run above code, this would produce the following result:
std::endl is used with std!
Names introduced in a using directive obey normal scope rules. The name is
visible from the point of the using directive to the end of the scope in which the
directive is found. Entities with the same name defined in an outer scope are
hidden.
Discontiguous Namespaces
A namespace can be defined in several parts and so a namespace is made up of
the sum of its separately defined parts. The separate parts of a namespace can
be spread over multiple files.
So, if one part of the namespace requires a name defined in another file, that
name must still be declared. Writing a following namespace definition either
defines a new namespace or adds new elements to an existing one:
namespace namespace_name {
 // code declarations
}
Nested Namespaces
Namespaces can be nested where you can define one namespace inside another
namespace as follows:
namespace namespace_name1 {
 // code declarations
 namespace namespace_name2 {
 // code declarations
 }
}
You can access members of nested namespace by using resolution operators as
follows:
// to access members of namespace_name2
using namespace namespace_name1::namespace_name2;
C++
257
// to access members of namespace:name1
using namespace namespace_name1;
In the above statements if you are using namespace_name1, then it will make
elements of namespace_name2 available in the scope as follows:
#include &lt;iostream&gt;
using namespace std;
// first name space
namespace first_space{
 void func(){
 cout &lt;&lt; "Inside first_space" &lt;&lt; endl;
 }
 // second name space
 namespace second_space{
 void func(){
 cout &lt;&lt; "Inside second_space" &lt;&lt; endl;
 }
 }
}
using namespace first_space::second_space;
int main ()
{
 // This calls function from second name space.
 func();

 return 0;
}
If we compile and run above code, this would produce the following result:
Inside second_space
C++
258
Templates are the foundation of generic programming, which involves writing
code in a way that is independent of any particular type.
A template is a blueprint or formula for creating a generic class or a function.
The library containers like iterators and algorithms are examples of generic
programming and have been developed using template concept.
There is a single definition of each container, such as vector, but we can define
many different kinds of vectors for example, vector &lt;int&gt; or vector &lt;string&gt;.
You can use templates to define functions as well as classes, let us see how
they work:
Function Template
The general form of a template function definition is shown here:
template &lt;class type&gt; ret-type func-name(parameter list)
{
 // body of function
}
Here, type is a placeholder name for a data type used by the function. This
name can be used within the function definition.
The following is the example of a function template that returns the maximum of
two values:
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
template &lt;typename T&gt;
inline T const&amp; Max (T const&amp; a, T const&amp; b)
{
 return a &lt; b ? b:a;
}
int main ()
{
34. TEMPLATES
C++
259
 int i = 39;
 int j = 20;
 cout &lt;&lt; "Max(i, j): " &lt;&lt; Max(i, j) &lt;&lt; endl;
 double f1 = 13.5;
 double f2 = 20.7;
 cout &lt;&lt; "Max(f1, f2): " &lt;&lt; Max(f1, f2) &lt;&lt; endl;
 string s1 = "Hello";
 string s2 = "World";
 cout &lt;&lt; "Max(s1, s2): " &lt;&lt; Max(s1, s2) &lt;&lt; endl;
 return 0;
}
If we compile and run above code, this would produce the following result:
Max(i, j): 39
Max(f1, f2): 20.7
Max(s1, s2): World
Class Template
Just as we can define function templates, we can also define class templates.
The general form of a generic class declaration is shown here:
template &lt;class type&gt; class class-name {
.
.
.
}
Here, type is the placeholder type name, which will be specified when a class is
instantiated. You can define more than one generic data type by using a commaseparated list.
Following is the example to define class Stack&lt;&gt; and implement generic
methods to push and pop the elements from the stack:
C++
260
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cstdlib&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;
using namespace std;
template &lt;class T&gt;
class Stack {
 private:
 vector&lt;T&gt; elems; // elements
 public:
 void push(T const&amp;); // push element
 void pop(); // pop element
 T top() const; // return top element
 bool empty() const{ // return true if empty.
 return elems.empty();
 }
};
template &lt;class T&gt;
void Stack&lt;T&gt;::push (T const&amp; elem)
{
 // append copy of passed element
 elems.push_back(elem);
}
template &lt;class T&gt;
void Stack&lt;T&gt;::pop ()
{
 if (elems.empty()) {
 throw out_of_range("Stack&lt;&gt;::pop(): empty stack");
C++
261
 }
// remove last element
 elems.pop_back();
}
template &lt;class T&gt;
T Stack&lt;T&gt;::top () const
{
 if (elems.empty()) {
 throw out_of_range("Stack&lt;&gt;::top(): empty stack");
 }
// return copy of last element
 return elems.back();
}
int main()
{
 try {
 Stack&lt;int&gt; intStack; // stack of ints
 Stack&lt;string&gt; stringStack; // stack of strings
 // manipulate int stack
 intStack.push(7);
 cout &lt;&lt; intStack.top() &lt;&lt;endl;
 // manipulate string stack
 stringStack.push("hello");
 cout &lt;&lt; stringStack.top() &lt;&lt; std::endl;
 stringStack.pop();
 stringStack.pop();
 }
 catch (exception const&amp; ex) {
 cerr &lt;&lt; "Exception: " &lt;&lt; ex.what() &lt;&lt;endl;
 return -1;
C++
262
 }
}
If we compile and run above code, this would produce the following result:
7
hello
Exception: Stack&lt;&gt;::pop(): empty stack
C++
263
The preprocessors are the directives, which give instructions to the compiler to
preprocess the information before actual compilation starts.
All preprocessor directives begin with #, and only white-space characters may
appear before a preprocessor directive on a line. Preprocessor directives are not
C++ statements, so they do not end in a semicolon (;).
You already have seen a #include directive in all the examples. This macro is
used to include a header file into the source file.
There are number of preprocessor directives supported by C++ like #include,
#define, #if, #else, #line, etc. Let us see important directives:
The #define Preprocessor
The #define preprocessor directive creates symbolic constants. The symbolic
constant is called a macro and the general form of the directive is:
#define macro-name replacement-text
When this line appears in a file, all subsequent occurrences of macro in that file
will be replaced by replacement-text before the program is compiled. For
example:
#include &lt;iostream&gt;
using namespace std;
#define PI 3.14159
int main ()
{
 cout &lt;&lt; "Value of PI :" &lt;&lt; PI &lt;&lt; endl;
 return 0;
}
Now, let us do the preprocessing of this code to see the result assuming we have
the source code file. So let us compile it with -E option and redirect the result to
35. PREPROCESSOR
C++
264
test.p. Now, if you check test.p, it will have lots of information and at the
bottom, you will find the value replaced as follows:
$gcc -E test.cpp &gt; test.p
...
int main ()
{
 cout &lt;&lt; "Value of PI :" &lt;&lt; 3.14159 &lt;&lt; endl;
 return 0;
}
Function-Like Macros
You can use #define to define a macro which will take argument as follows:
#include &lt;iostream&gt;
using namespace std;
#define MIN(a,b) (((a)&lt;(b)) ? a : b)
int main ()
{
 int i, j;
 i = 100;
 j = 30;
 cout &lt;&lt;"The minimum is " &lt;&lt; MIN(i, j) &lt;&lt; endl;
 return 0;
}
If we compile and run above code, this would produce the following result:
The minimum is 30
Conditional Compilation
C++
265
There are several directives, which can be used to compile selective portions of
your program's source code. This process is called conditional compilation.
The conditional preprocessor construct is much like the ‘if’ selection structure.
Consider the following preprocessor code:
#ifndef NULL
 #define NULL 0
#endif
You can compile a program for debugging purpose. You can also turn on or off
the debugging using a single macro as follows:
#ifdef DEBUG
 cerr &lt;&lt;"Variable x = " &lt;&lt; x &lt;&lt; endl;
#endif
This causes the cerr statement to be compiled in the program if the symbolic
constant DEBUG has been defined before directive #ifdef DEBUG. You can use
#if 0 statement to comment out a portion of the program as follows:
#if 0
 code prevented from compiling
#endif
Let us try the following example:
#include &lt;iostream&gt;
using namespace std;
#define DEBUG
#define MIN(a,b) (((a)&lt;(b)) ? a : b)
int main ()
{
 int i, j;
 i = 100;
 j = 30;
#ifdef DEBUG
 cerr &lt;&lt;"Trace: Inside main function" &lt;&lt; endl;
#endif
C++
266
#if 0
 /* This is commented part */
 cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl;
#endif
 cout &lt;&lt;"The minimum is " &lt;&lt; MIN(i, j) &lt;&lt; endl;
#ifdef DEBUG
 cerr &lt;&lt;"Trace: Coming out of main function" &lt;&lt; endl;
#endif
 return 0;
}
If we compile and run above code, this would produce the following result:
Trace: Inside main function
The minimum is 30
Trace: Coming out of main function
The # and # # Operators
The # and ## preprocessor operators are available in C++ and ANSI/ISO C. The
# operator causes a replacement-text token to be converted to a string
surrounded by quotes.
Consider the following macro definition:
#include &lt;iostream&gt;
using namespace std;
#define MKSTR( x ) #x
int main ()
{
 cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl;
 return 0;
C++
267
}
If we compile and run above code, this would produce the following result:
HELLO C++
Let us see how it worked. It is simple to understand that the C++ preprocessor
turns the line:
 cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl;
Above line will be turned into the following line:
 cout &lt;&lt; "HELLO C++" &lt;&lt; endl;
The ## operator is used to concatenate two tokens. Here is an example:
#define CONCAT( x, y ) x ## y
When CONCAT appears in the program, its arguments are concatenated and
used to replace the macro. For example, CONCAT(HELLO, C++) is replaced by
"HELLO C++" in the program as follows.
#include &lt;iostream&gt;
using namespace std;
#define concat(a, b) a ## b
int main()
{
 int xy = 100;

 cout &lt;&lt; concat(x, y);
 return 0;
}
If we compile and run above code, this would produce the following result:
100
Let us see how it worked. It is simple to understand that the C++ preprocessor
transforms:
 cout &lt;&lt; concat(x, y);
C++
268
Above line will be transformed into the following line:
 cout &lt;&lt; xy;
Predefined C++ Macros
C++ provides a number of predefined macros mentioned below:
Macro Description
__LINE__ This contains the current line number of the program
when it is being compiled.
__FILE__ This contains the current file name of the program
when it is being compiled.
__DATE__ This contains a string of the form month/day/year that
is the date of the translation of the source file into
object code.
__TIME__ This contains a string of the form hour:minute:second
that is the time at which the program was compiled.
Let us see an example for all the above macros:
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 cout &lt;&lt; "Value of __LINE__ : " &lt;&lt; __LINE__ &lt;&lt; endl;
 cout &lt;&lt; "Value of __FILE__ : " &lt;&lt; __FILE__ &lt;&lt; endl;
 cout &lt;&lt; "Value of __DATE__ : " &lt;&lt; __DATE__ &lt;&lt; endl;
 cout &lt;&lt; "Value of __TIME__ : " &lt;&lt; __TIME__ &lt;&lt; endl;
 return 0;
}
If we compile and run above code, this would produce the following result:
C++
269
Value of __LINE__ : 6
Value of __FILE__ : test.cpp
Value of __DATE__ : Feb 28 2011
Value of __TIME__ : 18:52:48
C++
270
Signals are the interrupts delivered to a process by the operating system which
can terminate a program prematurely. You can generate interrupts by pressing
Ctrl+C on a UNIX, LINUX, Mac OS X or Windows system.
There are signals which cannot be caught by the program but there is a
following list of signals which you can catch in your program and can take
appropriate actions based on the signal. These signals are defined in C++
header file &lt;csignal&gt;.
Signal Description
SIGABRT Abnormal termination of the program, such as a call to abort.
SIGFPE An erroneous arithmetic operation, such as a divide by zero or
an operation resulting in overflow.
SIGILL Detection of an illegal instruction.
SIGINT Receipt of an interactive attention signal.
SIGSEGV An invalid access to storage.
SIGTERM A termination request sent to the program.
The signal() Function
C++ signal-handling library provides function signal to trap unexpected events.
Following is the syntax of the signal() function:
void (*signal (int sig, void (*func)(int)))(int);
Keeping it simple, this function receives two arguments: first argument as an
integer, which represents signal number and second argument as a pointer to
the signal-handling function.
Let us write a simple C++ program where we will catch SIGINT signal using
signal() function. Whatever signal you want to catch in your program, you must
register that signal using signal function and associate it with a signal handler.
Examine the following example:
#include &lt;iostream&gt;
36. SIGNAL HANDLING
C++
271
#include &lt;csignal&gt;
using namespace std;
void signalHandler( int signum )
{
 cout &lt;&lt; "Interrupt signal (" &lt;&lt; signum &lt;&lt; ") received.\n";
 // cleanup and close up stuff here
 // terminate program
 exit(signum);
}
int main ()
{
 // register signal SIGINT and signal handler
 signal(SIGINT, signalHandler);
 while(1){
 cout &lt;&lt; "Going to sleep...." &lt;&lt; endl;
 sleep(1);
 }
 return 0;
}
When the above code is compiled and executed, it produces the following result:
Going to sleep....
Going to sleep....
Going to sleep....
Now, press Ctrl+C to interrupt the program and you will see that your program
will catch the signal and would come out by printing something as follows:
C++
272
Going to sleep....
Going to sleep....
Going to sleep....
Interrupt signal (2) received.
The raise() Function
You can generate signals by function raise(), which takes an integer signal
number as an argument and has the following syntax.
int raise (signal sig);
Here, sig is the signal number to send any of the signals: SIGINT, SIGABRT,
SIGFPE, SIGILL, SIGSEGV, SIGTERM, SIGHUP. Following is the example where
we raise a signal internally using raise() function as follows:
#include &lt;iostream&gt;
#include &lt;csignal&gt;
using namespace std;
void signalHandler( int signum )
{
 cout &lt;&lt; "Interrupt signal (" &lt;&lt; signum &lt;&lt; ") received.\n";
 // cleanup and close up stuff here
 // terminate program
 exit(signum);
}
int main ()
{
 int i = 0;
 // register signal SIGINT and signal handler
 signal(SIGINT, signalHandler);
C++
273
 while(++i){
 cout &lt;&lt; "Going to sleep...." &lt;&lt; endl;
 if( i == 3 ){
 raise( SIGINT);
 }
 sleep(1);
 }
 return 0;
}
When the above code is compiled and executed, it produces the following result
and would come out automatically:
Going to sleep....
Going to sleep....
Going to sleep....
Interrupt signal (2) received.
C++
274
Multithreading is a specialized form of multitasking and a multitasking is the
feature that allows your computer to run two or more programs concurrently. In
general, there are two types of multitasking: process-based and thread-based.
Process-based multitasking handles the concurrent execution of programs.
Thread-based multitasking deals with the concurrent execution of pieces of the
same program.
A multithreaded program contains two or more parts that can run concurrently.
Each part of such a program is called a thread, and each thread defines a
separate path of execution.
C++ does not contain any built-in support for multithreaded applications.
Instead, it relies entirely upon the operating system to provide this feature.
This tutorial assumes that you are working on Linux OS and we are going to
write multi-threaded C++ program using POSIX. POSIX Threads, or Pthreads
provides API which are available on many Unix-like POSIX systems such as
FreeBSD, NetBSD, GNU/Linux, Mac OS X and Solaris.
Creating Threads
The following routine is used to create a POSIX thread:
#include &lt;pthread.h&gt;
pthread_create (thread, attr, start_routine, arg)
Here, pthread_create creates a new thread and makes it executable. This
routine can be called any number of times from anywhere within your code.
Here is the description of the parameters:
Parameter Description
thread An opaque, unique identifier for the new thread returned
by the subroutine.
attr An opaque attribute object that may be used to set thread
attributes. You can specify a thread attributes object, or
NULL for the default values.
start_routine The C++ routine that the thread will execute once it is
created.
37. MULTITHREADING
C++
275
arg A single argument that may be passed to start_routine. It
must be passed by reference as a pointer cast of type
void. NULL may be used if no argument is to be passed.
The maximum number of threads that may be created by a process is
implementation dependent. Once created, threads are peers, and may create
other threads. There is no implied hierarchy or dependency between threads.
Terminating Threads
There is following routine which we use to terminate a POSIX thread:
#include &lt;pthread.h&gt;
pthread_exit (status)
Here pthread_exit is used to explicitly exit a thread. Typically, the
pthread_exit() routine is called after a thread has completed its work and is no
longer required to exist.
If main() finishes before the threads it has created, and exits with
pthread_exit(), the other threads will continue to execute. Otherwise, they will
be automatically terminated when main() finishes.
Example:
This simple example code creates 5 threads with the pthread_create() routine.
Each thread prints a "Hello World!" message, and then terminates with a call to
pthread_exit().
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;pthread.h&gt;
using namespace std;
#define NUM_THREADS 5
void *PrintHello(void *threadid)
{
 long tid;
 tid = (long)threadid;
 cout &lt;&lt; "Hello World! Thread ID, " &lt;&lt; tid &lt;&lt; endl;
C++
276
 pthread_exit(NULL);
}
int main ()
{
 pthread_t threads[NUM_THREADS];
 int rc;
 int i;
 for( i=0; i &lt; NUM_THREADS; i++ ){
 cout &lt;&lt; "main() : creating thread, " &lt;&lt; i &lt;&lt; endl;
 rc = pthread_create(&amp;threads[i], NULL,
 PrintHello, (void *)i);
 if (rc){
 cout &lt;&lt; "Error:unable to create thread," &lt;&lt; rc &lt;&lt; endl;
 exit(-1);
 }
 }
 pthread_exit(NULL);
}
Compile the following program using -lpthread library as follows:
$gcc test.cpp -lpthread
Now, execute your program which gives the following output:
main() : creating thread, 0
main() : creating thread, 1
main() : creating thread, 2
main() : creating thread, 3
main() : creating thread, 4
Hello World! Thread ID, 0
Hello World! Thread ID, 1
Hello World! Thread ID, 2
Hello World! Thread ID, 3
Hello World! Thread ID, 4
C++
277
Passing Arguments to Threads
This example shows how to pass multiple arguments via a structure. You can
pass any data type in a thread callback because it points to void as explained in
the following example:
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;pthread.h&gt;
using namespace std;
#define NUM_THREADS 5
struct thread_data{
 int thread_id;
 char *message;
};
void *PrintHello(void *threadarg)
{
 struct thread_data *my_data;
 my_data = (struct thread_data *) threadarg;
 cout &lt;&lt; "Thread ID : " &lt;&lt; my_data-&gt;thread_id ;
 cout &lt;&lt; " Message : " &lt;&lt; my_data-&gt;message &lt;&lt; endl;
 pthread_exit(NULL);
}
int main ()
{
 pthread_t threads[NUM_THREADS];
 struct thread_data td[NUM_THREADS];
 int rc;
C++
278
 int i;
 for( i=0; i &lt; NUM_THREADS; i++ ){
 cout &lt;&lt;"main() : creating thread, " &lt;&lt; i &lt;&lt; endl;
 td[i].thread_id = i;
 td[i].message = "This is message";
 rc = pthread_create(&amp;threads[i], NULL,
 PrintHello, (void *)&amp;td[i]);
 if (rc){
 cout &lt;&lt; "Error:unable to create thread," &lt;&lt; rc &lt;&lt; endl;
 exit(-1);
 }
 }
 pthread_exit(NULL);
}
When the above code is compiled and executed, it produces the following result:
main() : creating thread, 0
main() : creating thread, 1
main() : creating thread, 2
main() : creating thread, 3
main() : creating thread, 4
Thread ID : 3 Message : This is message
Thread ID : 2 Message : This is message
Thread ID : 0 Message : This is message
Thread ID : 1 Message : This is message
Thread ID : 4 Message : This is message
Joining and Detaching Threads
There are following two routines which we can use to join or detach threads:
pthread_join (threadid, status)
pthread_detach (threadid)
C++
279
The pthread_join() subroutine blocks the calling thread until the specified
‘threadid’ thread terminates. When a thread is created, one of its attributes
defines whether it is joinable or detached. Only threads that are created as
joinable can be joined. If a thread is created as detached, it can never be joined.
This example demonstrates how to wait for thread completions by using the
Pthread join routine.
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;
using namespace std;
#define NUM_THREADS 5
void *wait(void *t)
{
 int i;
 long tid;
 tid = (long)t;
 sleep(1);
 cout &lt;&lt; "Sleeping in thread " &lt;&lt; endl;
 cout &lt;&lt; "Thread with id : " &lt;&lt; tid &lt;&lt; " ...exiting " &lt;&lt; endl;
 pthread_exit(NULL);
}
int main ()
{
 int rc;
 int i;
 pthread_t threads[NUM_THREADS];
 pthread_attr_t attr;
 void *status;
C++
280
 // Initialize and set thread joinable
 pthread_attr_init(&amp;attr);
 pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);
 for( i=0; i &lt; NUM_THREADS; i++ ){
 cout &lt;&lt; "main() : creating thread, " &lt;&lt; i &lt;&lt; endl;
 rc = pthread_create(&amp;threads[i], NULL, wait, (void *)i );
 if (rc){
 cout &lt;&lt; "Error:unable to create thread," &lt;&lt; rc &lt;&lt; endl;
 exit(-1);
 }
 }
 // free attribute and wait for the other threads
 pthread_attr_destroy(&amp;attr);
 for( i=0; i &lt; NUM_THREADS; i++ ){
 rc = pthread_join(threads[i], &amp;status);
 if (rc){
 cout &lt;&lt; "Error:unable to join," &lt;&lt; rc &lt;&lt; endl;
 exit(-1);
 }
 cout &lt;&lt; "Main: completed thread id :" &lt;&lt; i ;
 cout &lt;&lt; " exiting with status :" &lt;&lt; status &lt;&lt; endl;
 }
 cout &lt;&lt; "Main: program exiting." &lt;&lt; endl;
 pthread_exit(NULL);
}
When the above code is compiled and executed, it produces the following result:
main() : creating thread, 0
main() : creating thread, 1
main() : creating thread, 2
C++
281
main() : creating thread, 3
main() : creating thread, 4
Sleeping in thread
Thread with id : 0 .... exiting
Sleeping in thread
Thread with id : 1 .... exiting
Sleeping in thread
Thread with id : 2 .... exiting
Sleeping in thread
Thread with id : 3 .... exiting
Sleeping in thread
Thread with id : 4 .... exiting
Main: completed thread id :0 exiting with status :0
Main: completed thread id :1 exiting with status :0
Main: completed thread id :2 exiting with status :0
Main: completed thread id :3 exiting with status :0
Main: completed thread id :4 exiting with status :0
Main: program exiting.
C++
282
What is CGI?
The Common Gateway Interface, or CGI, is a set of standards that define how
information is exchanged between the web server and a custom script.
The CGI specs are currently maintained by the NCSA and NCSA defines CGI is as
follows:
The Common Gateway Interface, or CGI, is a standard for external gateway
programs to interface with information servers such as HTTP servers.
The current version is CGI/1.1 and CGI/1.2 is under progress.
Web Browsing
To understand the concept of CGI, let's see what happens when we click a
hyperlink to browse a particular web page or URL.
 Your browser contacts the HTTP web server and demand for the URL i.e.
filename.
 Web Server will parse the URL and will look for the filename. If it finds the
requested file then web server sends that file back to the browser
otherwise sends an error message indicating that you have requested a
wrong file.
 Web browser takes response from web server and displays either the
received file or error message based on the received response.
However, it is possible to set up the HTTP server in such a way that whenever a
file in a certain directory is requested, that file is not sent back; instead it is
executed as a program, and produced output from the program is sent back to
your browser to display.
The Common Gateway Interface (CGI) is a standard protocol for enabling
applications (called CGI programs or CGI scripts) to interact with Web servers
and with clients. These CGI programs can be a written in Python, PERL, Shell, C
or C++ etc.
CGI Architecture Diagram
The following simple program shows a simple architecture of CGI:
38. WEB PROGRAMMING
C++
283
Web Server Configuration
Before you proceed with CGI Programming, make sure that your Web Server
supports CGI and it is configured to handle CGI Programs. All the CGI Programs
to be executed by the HTTP server are kept in a pre-configured directory. This
directory is called CGI directory and by convention it is named as /var/www/cgibin. By convention CGI files will have extension as .cgi, though they are C++
executable.
By default, Apache Web Server is configured to run CGI programs in
/var/www/cgi-bin. If you want to specify any other directory to run your CGI
scripts, you can modify the following section in the httpd.conf file:
&lt;Directory "/var/www/cgi-bin"&gt;
 AllowOverride None
 Options ExecCGI
 Order allow,deny
 Allow from all
&lt;/Directory&gt;
C++
284
&lt;Directory "/var/www/cgi-bin"&gt;
Options All
&lt;/Directory&gt;
Here, I assume that you have Web Server up and running successfully and you
are able to run any other CGI program like Perl or Shell etc.
First CGI Program
Consider the following C++ Program content:
#include &lt;iostream&gt;
using namespace std;
int main ()
{

 cout &lt;&lt; "Content-type:text/html\r\n\r\n";
 cout &lt;&lt; "&lt;html&gt;\n";
 cout &lt;&lt; "&lt;head&gt;\n";
 cout &lt;&lt; "&lt;title&gt;Hello World - First CGI Program&lt;/title&gt;\n";
 cout &lt;&lt; "&lt;/head&gt;\n";
 cout &lt;&lt; "&lt;body&gt;\n";
 cout &lt;&lt; "&lt;h2&gt;Hello World! This is my first CGI program&lt;/h2&gt;\n";
 cout &lt;&lt; "&lt;/body&gt;\n";
 cout &lt;&lt; "&lt;/html&gt;\n";

 return 0;
}
Compile above code and name the executable as cplusplus.cgi. This file is being
kept in /var/www/cgi-bin directory and it has following content. Before running
your CGI program make sure you have change mode of file using chmod 755
cplusplus.cgi UNIX command to make file executable. Now if you
click cplusplus.cgi then this produces the following output:
My First CGI program
The above C++ program is a simple program which is writing its output on
STDOUT file i.e. screen. There is one important and extra feature available which
is first line printing Content-type:text/html\r\n\r\n. This line is sent back to
the browser and specify the content type to be displayed on the browser screen.
C++
285
Now you must have understood the basic concept of CGI and you can write
many complicated CGI programs using Python. A C++ CGI program can interact
with any other external system, such as RDBMS, to exchange information.
HTTP Header
The line Content-type:text/html\r\n\r\n is a part of HTTP header, which is
sent to the browser to understand the content. All the HTTP header will be in the
following form:
HTTP Field Name: Field Content
For Example
Content-type: text/html\r\n\r\n
There are few other important HTTP headers, which you will use frequently in
your CGI Programming.
Header Description
Content-type: A MIME string defining the format of the file being
returned. Example is Content-type:text/html.
Expires: Date The date the information becomes invalid. This should
be used by the browser to decide when a page needs
to be refreshed. A valid date string should be in the
format 01 Jan 1998 12:00:00 GMT.
Location: URL The URL that should be returned instead of the URL
requested. You can use this field to redirect a request
to any file.
Last-modified: Date The date of last modification of the resource.
Content-length: N The length, in bytes, of the data being returned. The
browser uses this value to report the estimated
download time for a file.
Set-Cookie: String Set the cookie passed through the string.
CGI Environment Variables
All the CGI program will have access to the following environment variables.
These variables play an important role while writing any CGI program.
C++
286
Variable Name Description
CONTENT_TYPE The data type of the content, used when the client is
sending attached content to the server. For example
file upload etc.
CONTENT_LENGTH The length of the query information that is available
only for POST requests.
HTTP_COOKIE Returns the set cookies in the form of key &amp; value
pair.
HTTP_USER_AGENT The User-Agent request-header field contains
information about the user agent originating the
request. It is a name of the web browser.
PATH_INFO The path for the CGI script.
QUERY_STRING The URL-encoded information that is sent with GET
method request.
REMOTE_ADDR The IP address of the remote host making the
request. This can be useful for logging or for
authentication purpose.
REMOTE_HOST The fully qualified name of the host making the
request. If this information is not available then
REMOTE_ADDR can be used to get IR address.
REQUEST_METHOD The method used to make the request. The most
common methods are GET and POST.
SCRIPT_FILENAME The full path to the CGI script.
SCRIPT_NAME The name of the CGI script.
SERVER_NAME The server's hostname or IP Address.
SERVER_SOFTWARE The name and version of the software the server is
running.
C++
287
Here is small CGI program to list out all the CGI variables.
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
using namespace std;
const string ENV[ 24 ] = {
 "COMSPEC", "DOCUMENT_ROOT", "GATEWAY_INTERFACE",
 "HTTP_ACCEPT", "HTTP_ACCEPT_ENCODING",
 "HTTP_ACCEPT_LANGUAGE", "HTTP_CONNECTION",
 "HTTP_HOST", "HTTP_USER_AGENT", "PATH",
 "QUERY_STRING", "REMOTE_ADDR", "REMOTE_PORT",
 "REQUEST_METHOD", "REQUEST_URI", "SCRIPT_FILENAME",
 "SCRIPT_NAME", "SERVER_ADDR", "SERVER_ADMIN",
 "SERVER_NAME","SERVER_PORT","SERVER_PROTOCOL",
 "SERVER_SIGNATURE","SERVER_SOFTWARE" };
int main ()
{

 cout &lt;&lt; "Content-type:text/html\r\n\r\n";
 cout &lt;&lt; "&lt;html&gt;\n";
 cout &lt;&lt; "&lt;head&gt;\n";
 cout &lt;&lt; "&lt;title&gt;CGI Environment Variables&lt;/title&gt;\n";
 cout &lt;&lt; "&lt;/head&gt;\n";
 cout &lt;&lt; "&lt;body&gt;\n";
 cout &lt;&lt; "&lt;table border = \"0\" cellspacing = \"2\"&gt;";
 for ( int i = 0; i &lt; 24; i++ )
 {
 cout &lt;&lt; "&lt;tr&gt;&lt;td&gt;" &lt;&lt; ENV[ i ] &lt;&lt; "&lt;/td&gt;&lt;td&gt;";
 // attempt to retrieve value of environment variable
 char *value = getenv( ENV[ i ].c_str() );
C++
288
 if ( value != 0 ){
 cout &lt;&lt; value;
 }else{
 cout &lt;&lt; "Environment variable does not exist.";
 }
 cout &lt;&lt; "&lt;/td&gt;&lt;/tr&gt;\n";
 }
 cout &lt;&lt; "&lt;/table&gt;&lt;\n";
 cout &lt;&lt; "&lt;/body&gt;\n";
 cout &lt;&lt; "&lt;/html&gt;\n";

 return 0;
}
The output is as follows:
COMSPEC Environment variable does not exist.
DOCUMENT_ROOT /var/www/tutorialspoint
GATEWAY_INTERFACE CGI/1.1
HTTP_ACCEPT text/html, application/xhtml+xml, */*
HTTP_ACCEPT_ENCODING gzip, deflate
HTTP_ACCEPT_LANGUAGE en-US
HTTP_CONNECTION Keep-Alive
HTTP_HOST www.tutorialspoint.com
HTTP_USER_AGENT Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0;
rv:11.0) like Gecko
PATH /sbin:/usr/sbin:/bin:/usr/bin
QUERY_STRING
REMOTE_ADDR 183.82.104.71
REMOTE_PORT 50902
REQUEST_METHOD GET
REQUEST_URI /cgi-bin/cpp_env.cgi
SCRIPT_FILENAME /var/www/cgi-bin/cpp_env.cgi
SCRIPT_NAME /cgi-bin/cpp_env.cgi
SERVER_ADDR 66.135.33.172
C++
289
SERVER_ADMIN webmaster@tutorialspoint.com
SERVER_NAME www.tutorialspoint.com
SERVER_PORT 80
SERVER_PROTOCOL HTTP/1.1
SERVER_SIGNATURE
SERVER_SOFTWARE Apache
&lt;
C++ CGI Library
For real examples, you would need to do many operations by your CGI program.
There is a CGI library written for C++ program which you can download from
ftp://ftp.gnu.org/gnu/cgicc/ and follow the steps to install the library:
$tar xzf cgicc-X.X.X.tar.gz
$cd cgicc-X.X.X/
$./configure --prefix=/usr
$make
$make install
You can check related documentation available at ‘C++ CGI Lib Documentation’.
GET and POST Methods
You must have come across many situations when you need to pass some
information from your browser to web server and ultimately to your CGI
Program. Most frequently browser uses two methods to pass this information to
web server. These methods are GET Method and POST Method.
Passing Information Using GET Method
The GET method sends the encoded user information appended to the page
request. The page and the encoded information are separated by the ‘?’
character as follows:
http://www.test.com/cgi-bin/cpp.cgi?key1=value1&amp;key2=value2
The GET method is the default method to pass information from browser to web
server and it produces a long string that appears in your browser's Location:box.
Never use the GET method if you have password or other sensitive information
to pass to the server. The GET method has size limitation and you can pass up
to 1024 characters in a request string.
When using GET method, information is passed using QUERY_STRING http
header and will be accessible in your CGI Program through QUERY_STRING
environment variable.
C++
290
You can pass information by simply concatenating key and value pairs along
with any URL or you can use HTML &lt;FORM&gt; tags to pass information using GET
method.
Simple URL Example: Get Method
Here is a simple URL which will pass two values to hello_get.py program using
GET method.
/cgi-bin/cpp_get.cgi?first_name=ZARA&amp;last_name=ALI
Below is a program to generate cpp_get.cgi CGI program to handle input given
by web browser. We are going to use C++ CGI library which makes it very easy
to access passed information:
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;cgicc/CgiDefs.h&gt;
#include &lt;cgicc/Cgicc.h&gt;
#include &lt;cgicc/HTTPHTMLHeader.h&gt;
#include &lt;cgicc/HTMLClasses.h&gt;
using namespace std;
using namespace cgicc;
int main ()
{
 Cgicc formData;

 cout &lt;&lt; "Content-type:text/html\r\n\r\n";
 cout &lt;&lt; "&lt;html&gt;\n";
 cout &lt;&lt; "&lt;head&gt;\n";
 cout &lt;&lt; "&lt;title&gt;Using GET and POST Methods&lt;/title&gt;\n";
 cout &lt;&lt; "&lt;/head&gt;\n";
 cout &lt;&lt; "&lt;body&gt;\n";
C++
291
 form_iterator fi = formData.getElement("first_name");
 if( !fi-&gt;isEmpty() &amp;&amp; fi != (*formData).end()) {
 cout &lt;&lt; "First name: " &lt;&lt; **fi &lt;&lt; endl;
 }else{
 cout &lt;&lt; "No text entered for first name" &lt;&lt; endl;
 }
 cout &lt;&lt; "&lt;br/&gt;\n";
 fi = formData.getElement("last_name");
 if( !fi-&gt;isEmpty() &amp;&amp;fi != (*formData).end()) {
 cout &lt;&lt; "Last name: " &lt;&lt; **fi &lt;&lt; endl;
 }else{
 cout &lt;&lt; "No text entered for last name" &lt;&lt; endl;
 }
 cout &lt;&lt; "&lt;br/&gt;\n";
 cout &lt;&lt; "&lt;/body&gt;\n";
 cout &lt;&lt; "&lt;/html&gt;\n";

 return 0;
}
Now, compile the above program as follows:
$g++ -o cpp_get.cgi cpp_get.cpp -lcgicc
Generate cpp_get.cgi and put it in your CGI directory and try to access using
following link:
/cgi-bin/cpp_get.cgi?first_name=ZARA&amp;last_name=ALI
This would generate following result:
First name: ZARA
Last name: ALI
Simple FORM Example: GET Method
Here is a simple example which passes two values using HTML FORM and submit
button. We are going to use same CGI script cpp_get.cgi to handle this input.
&lt;form action="/cgi-bin/cpp_get.cgi" method="get"&gt;
C++
292
First Name: &lt;input type="text" name="first_name"&gt; &lt;br /&gt;
Last Name: &lt;input type="text" name="last_name" /&gt;
&lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
Here is the actual output of the above form. You enter First and Last Name and
then click submit button to see the result.
First Name:
Last Name:
Submit
Passing Information Using POST Method
A generally more reliable method of passing information to a CGI program is the
POST method. This packages the information in exactly the same way as GET
methods, but instead of sending it as a text string after a ‘?’ in the URL it sends
it as a separate message. This message comes into the CGI script in the form of
the standard input.
The same cpp_get.cgi program will handle POST method as well. Let us take
same example as above, which passes two values using HTML FORM and submit
button but this time with POST method as follows:
&lt;form action="/cgi-bin/cpp_get.cgi" method="post"&gt;
First Name: &lt;input type="text" name="first_name"&gt;&lt;br /&gt;
Last Name: &lt;input type="text" name="last_name" /&gt;
&lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
Here is the actual output of the above form. You enter First and Last Name and
then click submit button to see the result.
First Name:
Last Name:
Submit
Passing Checkbox Data to CGI Program
Checkboxes are used when more than one option is required to be selected.
C++
293
Here is example HTML code for a form with two checkboxes:
&lt;form action="/cgi-bin/cpp_checkbox.cgi"
 method="POST"
 target="_blank"&gt;
&lt;input type="checkbox" name="maths" value="on" /&gt; Maths
&lt;input type="checkbox" name="physics" value="on" /&gt; Physics
&lt;input type="submit" value="Select Subject" /&gt;
&lt;/form&gt;
The result of this code is the following form:
Maths Physics
Select Subject
Below is C++ program, which will generate cpp_checkbox.cgi script to handle
input given by web browser through checkbox button.
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;cgicc/CgiDefs.h&gt;
#include &lt;cgicc/Cgicc.h&gt;
#include &lt;cgicc/HTTPHTMLHeader.h&gt;
#include &lt;cgicc/HTMLClasses.h&gt;
using namespace std;
using namespace cgicc;
int main ()
{
 Cgicc formData;
 bool maths_flag, physics_flag;
 cout &lt;&lt; "Content-type:text/html\r\n\r\n";
 cout &lt;&lt; "&lt;html&gt;\n";
C++
294
 cout &lt;&lt; "&lt;head&gt;\n";
 cout &lt;&lt; "&lt;title&gt;Checkbox Data to CGI&lt;/title&gt;\n";
 cout &lt;&lt; "&lt;/head&gt;\n";
 cout &lt;&lt; "&lt;body&gt;\n";
 maths_flag = formData.queryCheckbox("maths");
 if( maths_flag ) {
 cout &lt;&lt; "Maths Flag: ON " &lt;&lt; endl;
 }else{
 cout &lt;&lt; "Maths Flag: OFF " &lt;&lt; endl;
 }
 cout &lt;&lt; "&lt;br/&gt;\n";
 physics_flag = formData.queryCheckbox("physics");
 if( physics_flag ) {
 cout &lt;&lt; "Physics Flag: ON " &lt;&lt; endl;
 }else{
 cout &lt;&lt; "Physics Flag: OFF " &lt;&lt; endl;
 }
 cout &lt;&lt; "&lt;br/&gt;\n";
 cout &lt;&lt; "&lt;/body&gt;\n";
 cout &lt;&lt; "&lt;/html&gt;\n";

 return 0;
}
Passing Radio Button Data to CGI Program
Radio Buttons are used when only one option is required to be selected.
Here is example HTML code for a form with two radio button:
&lt;form action="/cgi-bin/cpp_radiobutton.cgi"
 method="post"
 target="_blank"&gt;
&lt;input type="radio" name="subject" value="maths"
 checked="checked"/&gt; Maths
C++
295
&lt;input type="radio" name="subject" value="physics" /&gt; Physics
&lt;input type="submit" value="Select Subject" /&gt;
&lt;/form&gt;
The result of this code is the following form:
Maths Physics
Select Subject
Below is C++ program, which will generate cpp_radiobutton.cgi script to handle
input given by web browser through radio buttons.
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;cgicc/CgiDefs.h&gt;
#include &lt;cgicc/Cgicc.h&gt;
#include &lt;cgicc/HTTPHTMLHeader.h&gt;
#include &lt;cgicc/HTMLClasses.h&gt;
using namespace std;
using namespace cgicc;
int main ()
{
 Cgicc formData;

 cout &lt;&lt; "Content-type:text/html\r\n\r\n";
 cout &lt;&lt; "&lt;html&gt;\n";
 cout &lt;&lt; "&lt;head&gt;\n";
 cout &lt;&lt; "&lt;title&gt;Radio Button Data to CGI&lt;/title&gt;\n";
 cout &lt;&lt; "&lt;/head&gt;\n";
 cout &lt;&lt; "&lt;body&gt;\n";
 form_iterator fi = formData.getElement("subject");
C++
296
 if( !fi-&gt;isEmpty() &amp;&amp; fi != (*formData).end()) {
 cout &lt;&lt; "Radio box selected: " &lt;&lt; **fi &lt;&lt; endl;
 }

 cout &lt;&lt; "&lt;br/&gt;\n";
 cout &lt;&lt; "&lt;/body&gt;\n";
 cout &lt;&lt; "&lt;/html&gt;\n";

 return 0;
}
Passing Text Area Data to CGI Program
TEXTAREA element is used when multiline text has to be passed to the CGI
Program.
Here is example HTML code for a form with a TEXTAREA box:
&lt;form action="/cgi-bin/cpp_textarea.cgi"
 method="post"
 target="_blank"&gt;
&lt;textarea name="textcontent" cols="40" rows="4"&gt;
Type your text here...
&lt;/textarea&gt;
&lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
The result of this code is the following form:
Submit
Below is C++ program, which will generate cpp_textarea.cgi script to handle
input given by web browser through text area.
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stdio.h&gt;
C++
297
#include &lt;stdlib.h&gt;
#include &lt;cgicc/CgiDefs.h&gt;
#include &lt;cgicc/Cgicc.h&gt;
#include &lt;cgicc/HTTPHTMLHeader.h&gt;
#include &lt;cgicc/HTMLClasses.h&gt;
using namespace std;
using namespace cgicc;
int main ()
{
 Cgicc formData;

 cout &lt;&lt; "Content-type:text/html\r\n\r\n";
 cout &lt;&lt; "&lt;html&gt;\n";
 cout &lt;&lt; "&lt;head&gt;\n";
 cout &lt;&lt; "&lt;title&gt;Text Area Data to CGI&lt;/title&gt;\n";
 cout &lt;&lt; "&lt;/head&gt;\n";
 cout &lt;&lt; "&lt;body&gt;\n";
 form_iterator fi = formData.getElement("textcontent");
 if( !fi-&gt;isEmpty() &amp;&amp; fi != (*formData).end()) {
 cout &lt;&lt; "Text Content: " &lt;&lt; **fi &lt;&lt; endl;
 }else{
 cout &lt;&lt; "No text entered" &lt;&lt; endl;
 }

 cout &lt;&lt; "&lt;br/&gt;\n";
 cout &lt;&lt; "&lt;/body&gt;\n";
 cout &lt;&lt; "&lt;/html&gt;\n";

 return 0;
}
C++
298
Passing Dropdown Box Data to CGI Program
Dropdown Box is used when we have many options available but only one or two
will be selected.
Here is example HTML code for a form with one dropdown box:
&lt;form action="/cgi-bin/cpp_dropdown.cgi"
 method="post" target="_blank"&gt;
&lt;select name="dropdown"&gt;
&lt;option value="Maths" selected&gt;Maths&lt;/option&gt;
&lt;option value="Physics"&gt;Physics&lt;/option&gt;
&lt;/select&gt;
&lt;input type="submit" value="Submit"/&gt;
&lt;/form&gt;
The result of this code is the following form:
Maths Submit
Below is C++ program, which will generate cpp_dropdown.cgi script to handle
input given by web browser through drop down box.
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;cgicc/CgiDefs.h&gt;
#include &lt;cgicc/Cgicc.h&gt;
#include &lt;cgicc/HTTPHTMLHeader.h&gt;
#include &lt;cgicc/HTMLClasses.h&gt;
using namespace std;
using namespace cgicc;
int main ()
{
 Cgicc formData;
C++
299

 cout &lt;&lt; "Content-type:text/html\r\n\r\n";
 cout &lt;&lt; "&lt;html&gt;\n";
 cout &lt;&lt; "&lt;head&gt;\n";
 cout &lt;&lt; "&lt;title&gt;Drop Down Box Data to CGI&lt;/title&gt;\n";
 cout &lt;&lt; "&lt;/head&gt;\n";
 cout &lt;&lt; "&lt;body&gt;\n";
 form_iterator fi = formData.getElement("dropdown");
 if( !fi-&gt;isEmpty() &amp;&amp; fi != (*formData).end()) {
 cout &lt;&lt; "Value Selected: " &lt;&lt; **fi &lt;&lt; endl;
 }

 cout &lt;&lt; "&lt;br/&gt;\n";
 cout &lt;&lt; "&lt;/body&gt;\n";
 cout &lt;&lt; "&lt;/html&gt;\n";

 return 0;
}
Using Cookies in CGI
HTTP protocol is a stateless protocol. But for a commercial website it is required
to maintain session information among different pages. For example one user
registration ends after completing many pages. But how to maintain user's
session information across all the web pages.
In many situations, using cookies is the most efficient method of remembering
and tracking preferences, purchases, commissions, and other information
required for better visitor experience or site statistics.
How It Works
Your server sends some data to the visitor's browser in the form of a cookie. The
browser may accept the cookie. If it does, it is stored as a plain text record on
the visitor's hard drive. Now, when the visitor arrives at another page on your
site, the cookie is available for retrieval. Once retrieved, your server
knows/remembers what was stored.
Cookies are a plain text data record of 5 variable-length fields:
 Expires: This showsthe date the cookie will expire. If this is blank, the
cookie will expire when the visitor quits the browser.
C++
300
 Domain: This is the domain name of your site.
 Path: This is the path to the directory or web page that sets the cookie.
This may be blank if you want to retrieve the cookie from any directory or
page.
 Secure: If this field contains the word "secure" then the cookie may only
be retrieved with a secure server. If this field is blank, no such restriction
exists.
 Name=Value: Cookies are set and retrieved in the form of key and value
pairs.
Setting up Cookies
It is very easy to send cookies to browser. These cookies will be sent along with
HTTP Header before the Content-type filed. Assuming you want to set UserID
and Password as cookies. So cookies setting will be done as follows:
#include &lt;iostream&gt;
using namespace std;
int main ()
{
 cout &lt;&lt; "Set-Cookie:UserID=XYZ;\r\n";
 cout &lt;&lt; "Set-Cookie:Password=XYZ123;\r\n";
 cout &lt;&lt; "Set-Cookie:Domain=www.tutorialspoint.com;\r\n";
 cout &lt;&lt; "Set-Cookie:Path=/perl;\n";
 cout &lt;&lt; "Content-type:text/html\r\n\r\n";
 cout &lt;&lt; "&lt;html&gt;\n";
 cout &lt;&lt; "&lt;head&gt;\n";
 cout &lt;&lt; "&lt;title&gt;Cookies in CGI&lt;/title&gt;\n";
 cout &lt;&lt; "&lt;/head&gt;\n";
 cout &lt;&lt; "&lt;body&gt;\n";
 cout &lt;&lt; "Setting cookies" &lt;&lt; endl;

 cout &lt;&lt; "&lt;br/&gt;\n";
 cout &lt;&lt; "&lt;/body&gt;\n";
C++
301
 cout &lt;&lt; "&lt;/html&gt;\n";

 return 0;
}
From this example, you must have understood how to set cookies. We use SetCookie HTTP header to set cookies.
Here, it is optional to set cookies attributes like Expires, Domain, and Path. It is
notable that cookies are set before sending magic line "Contenttype:text/html\r\n\r\n.
Compile above program to produce setcookies.cgi, and try to set cookies using
following link. It will set four cookies at your computer:
/cgi-bin/setcookies.cgi
Retrieving Cookies
It is easy to retrieve all the set cookies. Cookies are stored in CGI environment
variable HTTP_COOKIE and they will have following form.
key1=value1;key2=value2;key3=value3....
Here is an example of how to retrieve cookies.
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;cgicc/CgiDefs.h&gt;
#include &lt;cgicc/Cgicc.h&gt;
#include &lt;cgicc/HTTPHTMLHeader.h&gt;
#include &lt;cgicc/HTMLClasses.h&gt;
using namespace std;
using namespace cgicc;
int main ()
{
C++
302
 Cgicc cgi;
 const_cookie_iterator cci;
 cout &lt;&lt; "Content-type:text/html\r\n\r\n";
 cout &lt;&lt; "&lt;html&gt;\n";
 cout &lt;&lt; "&lt;head&gt;\n";
 cout &lt;&lt; "&lt;title&gt;Cookies in CGI&lt;/title&gt;\n";
 cout &lt;&lt; "&lt;/head&gt;\n";
 cout &lt;&lt; "&lt;body&gt;\n";
 cout &lt;&lt; "&lt;table border = \"0\" cellspacing = \"2\"&gt;";

 // get environment variables
 const CgiEnvironment&amp; env = cgi.getEnvironment();
 for( cci = env.getCookieList().begin();
 cci != env.getCookieList().end();
 ++cci )
 {
 cout &lt;&lt; "&lt;tr&gt;&lt;td&gt;" &lt;&lt; cci-&gt;getName() &lt;&lt; "&lt;/td&gt;&lt;td&gt;";
 cout &lt;&lt; cci-&gt;getValue();
 cout &lt;&lt; "&lt;/td&gt;&lt;/tr&gt;\n";
 }
 cout &lt;&lt; "&lt;/table&gt;&lt;\n";

 cout &lt;&lt; "&lt;br/&gt;\n";
 cout &lt;&lt; "&lt;/body&gt;\n";
 cout &lt;&lt; "&lt;/html&gt;\n";

 return 0;
}
Now, compile above program to produce getcookies.cgi, and try to get a list of
all the cookies available at your computer:
/cgi-bin/getcookies.cgi
C++
303
This will produce a list of all the four cookies set in previous section and all other
cookies set in your computer:
UserID XYZ
Password XYZ123
Domain www.tutorialspoint.com
Path /perl
File Upload Example
To upload a file the HTML form must have the enctype attribute set
to multipart/form-data. The input tag with the file type will create a "Browse"
button.
&lt;html&gt;
&lt;body&gt;
 &lt;form enctype="multipart/form-data"
 action="/cgi-bin/cpp_uploadfile.cgi"
 method="post"&gt;
 &lt;p&gt;File: &lt;input type="file" name="userfile" /&gt;&lt;/p&gt;
 &lt;p&gt;&lt;input type="submit" value="Upload" /&gt;&lt;/p&gt;
 &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
The result of this code is the following form:
File:
Upload
Note: Above example has been disabled intentionally to stop people uploading
files on our server. But you can try above code with your server.
Here is the script cpp_uploadfile.cpp to handle file upload:
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
C++
304
#include &lt;cgicc/CgiDefs.h&gt;
#include &lt;cgicc/Cgicc.h&gt;
#include &lt;cgicc/HTTPHTMLHeader.h&gt;
#include &lt;cgicc/HTMLClasses.h&gt;
using namespace std;
using namespace cgicc;
int main ()
{
 Cgicc cgi;
 cout &lt;&lt; "Content-type:text/html\r\n\r\n";
 cout &lt;&lt; "&lt;html&gt;\n";
 cout &lt;&lt; "&lt;head&gt;\n";
 cout &lt;&lt; "&lt;title&gt;File Upload in CGI&lt;/title&gt;\n";
 cout &lt;&lt; "&lt;/head&gt;\n";
 cout &lt;&lt; "&lt;body&gt;\n";
 // get list of files to be uploaded
 const_file_iterator file = cgi.getFile("userfile");
 if(file != cgi.getFiles().end()) {
 // send data type at cout.
 cout &lt;&lt; HTTPContentHeader(file-&gt;getDataType());
 // write content at cout.
 file-&gt;writeToStream(cout);
 }
 cout &lt;&lt; "&lt;File uploaded successfully&gt;\n";
 cout &lt;&lt; "&lt;/body&gt;\n";
 cout &lt;&lt; "&lt;/html&gt;\n";

 return 0;
}
C++
305
The above example is for writing content at cout stream but you can open your
file stream and save the content of uploaded file in a file at desired location.
Hope you have enjoyed this tutorial. If yes, please send us your feedback.
C++
306
Hope you have already understood the concept of C++ Template which we have
discussed earlier. The C++ STL (Standard Template Library) is a powerful set of
C++ template classes to provide general-purpose classes and functions with
templates that implement many popular and commonly used algorithms and
data structures like vectors, lists, queues, and stacks.
At the core of the C++ Standard Template Library are following three wellstructured components:
Component Description
Containers Containers are used to manage collections of objects
of a certain kind. There are several different types of
containers like deque, list, vector, map etc.
Algorithms Algorithms act on containers. They provide the means
by which you will perform initialization, sorting,
searching, and transforming of the contents of
containers.
Iterators Iterators are used to step through the elements of
collections of objects. These collections may be
containers or subsets of containers.
We will discuss about all the three C++ STL components in next chapter while
discussing C++ Standard Library. For now, keep in mind that all the three
components have a rich set of pre-defined functions which help us in doing
complicated tasks in very easy fashion.
Let us take the following program that demonstrates the vector container (a
C++ Standard Template) which is similar to an array with an exception that it
automatically handles its own storage requirements in case it grows:
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
int main()
{
39. STL TUTORIAL
C++
307
 // create a vector to store int
 vector&lt;int&gt; vec;
 int i;
 // display the original size of vec
 cout &lt;&lt; "vector size = " &lt;&lt; vec.size() &lt;&lt; endl;
 // push 5 values into the vector
 for(i = 0; i &lt; 5; i++){
 vec.push_back(i);
 }
 // display extended size of vec
 cout &lt;&lt; "extended vector size = " &lt;&lt; vec.size() &lt;&lt; endl;
 // access 5 values from the vector
 for(i = 0; i &lt; 5; i++){
 cout &lt;&lt; "value of vec [" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; vec[i] &lt;&lt; endl;
 }
 // use iterator to access the values
 vector&lt;int&gt;::iterator v = vec.begin();
 while( v != vec.end()) {
 cout &lt;&lt; "value of v = " &lt;&lt; *v &lt;&lt; endl;
 v++;
 }
 return 0;
}
When the above code is compiled and executed, it produces the following result:
vector size = 0
extended vector size = 5
value of vec [0] = 0
C++
308
value of vec [1] = 1
value of vec [2] = 2
value of vec [3] = 3
value of vec [4] = 4
value of v = 0
value of v = 1
value of v = 2
value of v = 3
value of v = 4
Here are following points to be noted related to various functions we used in the
above example:
 The push_back( ) member function inserts value at the end of the vector,
expanding its size as needed.
 The size( ) function displays the size of the vector.
 The function begin( ) returns an iterator to the start of the vector.
 The function end( ) returns an iterator to the end of the vector.
C++
309
The C++ Standard Library can be categorized into two parts:
 The Standard Function Library: This library consists of generalpurpose, stand-alone functions that are not part of any class. The function
library is inherited from C.
 The Object Oriented Class Library: This is a collection of classes and
associated functions.
Standard C++ Library incorporates all the Standard C libraries also, with small
additions and changes to support type safety.
The Standard Function Library
The standard function library is divided into the following categories:
 I/O,
 String and character handling,
 Mathematical,
 Time, date, and localization,
 Dynamic allocation,
 Miscellaneous,
 Wide-character functions
The Object Oriented Class Library
Standard C++ Object Oriented Library defines an extensive set of classes that
provide support for a number of common activities, including I/O, strings, and
numeric processing. This library includes the following:
 The Standard C++ I/O Classes
 The String Class
 The Numeric Classes
 The STL Container Classes
 The STL Algorithms
 The STL Function Objects
 The STL Iterators
 The STL Allocators
40. STANDARD LIBRARY
C++
310
 The Localization library
 Exception Handling Classes
 Miscellaneous Support Library........................................................................................................................................26 Defining Constants................................................................................................................................27 9. MODIFIER TYPES ................................................................................................................ 29 Type Qualifiers in C++............................................................................................................................30 10. STORAGE CLASSES ............................................................................................................. 31 The auto Storage Class..........................................................................................................................31 The register Storage Class .....................................................................................................................31 The static Storage Class.........................................................................................................................31 The extern Storage Class.......................................................................................................................33 The mutable Storage Class ....................................................................................................................34 11. OPERATORS ....................................................................................................................... 35 iv Arithmetic Operators............................................................................................................................35 Relational Operators.............................................................................................................................37 Logical Operators..................................................................................................................................40 Bitwise Operators .................................................................................................................................41 Assignment Operators...........................................................................................................................44 Misc Operators......................................................................................................................................47 Operators Precedence in C++ ................................................................................................................48 12. LOOP TYPES ....................................................................................................................... 51 While Loop............................................................................................................................................52 for Loop.................................................................................................................................................54 do…while Loop......................................................................................................................................56 nested Loops.........................................................................................................................................58 Loop Control Statements.......................................................................................................................60 Break Statement ...................................................................................................................................61 continue Statement ..............................................................................................................................63 goto Statement.....................................................................................................................................65 The Infinite Loop ...................................................................................................................................67 13. DECISION-MAKING STATEMENTS ...................................................................................... 69 If Statement..........................................................................................................................................70 if…else Statement .................................................................................................................................72 if...else if...else Statement.....................................................................................................................73 Switch Statement..................................................................................................................................75 Nested if Statement ..............................................................................................................................78 The ? : Operator....................................................................................................................................81 14. FUNCTIONS ....................................................................................................................... 82 Defining a Function ...............................................................................................................................82 v Function Declarations ...........................................................................................................................83 Calling a Function..................................................................................................................................84 Function Arguments..............................................................................................................................85 Call by Value .........................................................................................................................................86 Call by Pointer.......................................................................................................................................87 Call by Reference...................................................................................................................................89 Default Values for Parameters ..............................................................................................................90 15. NUMBERS .......................................................................................................................... 93 Defining Numbers in C++.......................................................................................................................93 Math Operations in C++ ........................................................................................................................94 Random Numbers in C++.......................................................................................................................96 16. ARRAYS .............................................................................................................................. 98 Declaring Arrays....................................................................................................................................98 Initializing Arrays ..................................................................................................................................98 Accessing Array Elements......................................................................................................................99 Arrays in C++ .......................................................................................................................................100 Pointer to an Array..............................................................................................................................103 Passing Arrays to Functions.................................................................................................................105 Return Array from Functions...............................................................................................................107 17. STRINGS........................................................................................................................... 111 The C-Style Character String................................................................................................................111 The String Class in C++.........................................................................................................................114 18. POINTERS ........................................................................................................................ 116 What are Pointers? .............................................................................................................................116 Using Pointers in C++...........................................................................................................................117 Pointers in C++ ....................................................................................................................................118 vi Null Pointers .......................................................................................................................................119 Pointer Arithmetic...............................................................................................................................120 Pointers vs Arrays ...............................................................................................................................124 Array of Pointers.................................................................................................................................126 Pointer to a Pointer.............................................................................................................................128 Passing Pointers to Functions..............................................................................................................130 Return Pointer from Functions............................................................................................................132 19. REFERENCES .................................................................................................................... 135 References vs Pointers........................................................................................................................135 Creating References in C++..................................................................................................................135 References as Parameters...................................................................................................................137 Reference as Return Value ..................................................................................................................138 20. DATE AND TIME ............................................................................................................... 141 Current Date and Time........................................................................................................................142 Format Time using struct tm ...............................................................................................................143 21. BASIC INPUT/OUTPUT ..................................................................................................... 145 I/O Library Header Files.......................................................................................................................145 The Standard Output Stream (cout) ....................................................................................................145 The Standard Input Stream (cin)..........................................................................................................146 The Standard Error Stream (cerr) ........................................................................................................147 The Standard Log Stream (clog)...........................................................................................................148 22. DATA STRUCTURES .......................................................................................................... 149 Defining a Structure ............................................................................................................................149 Accessing Structure Members.............................................................................................................150 vii Structures as Function Arguments.......................................................................................................151 Pointers to Structures .........................................................................................................................153 The typedef Keyword ..........................................................................................................................155 23. CLASSES AND OBJECTS .................................................................................................... 157 C++ Class Definitions...........................................................................................................................157 Define C++ Objects..............................................................................................................................157 Accessing the Data Members..............................................................................................................158 Classes &amp; Objects in Detail ..................................................................................................................159 Class Access Modifiers.........................................................................................................................163 The public Members............................................................................................................................164 The private Members..........................................................................................................................165 The protected Members......................................................................................................................167 Constructor &amp; Destructor....................................................................................................................169 Parameterized Constructor .................................................................................................................170 The Class Destructor............................................................................................................................173 Copy Constructor ................................................................................................................................174 Friend Functions..................................................................................................................................179 Inline Functions...................................................................................................................................181 this Pointer .........................................................................................................................................182 Pointer to C++ Classes.........................................................................................................................184 Static Members of a Class ...................................................................................................................185 Static Function Members ....................................................................................................................187 24. INHERITANCE................................................................................................................... 190 Base &amp; Derived Classes........................................................................................................................190 Access Control and Inheritance ...........................................................................................................192 viii Type of Inheritance .............................................................................................................................192 Multiple Inheritance ...........................................................................................................................193 25. OVERLOADING (OPERATOR &amp; FUNCTION) ....................................................................... 196 Function Overloading in C++ ...............................................................................................................196 Operators Overloading in C++ .............................................................................................................197 Overloadable/Non-overloadable Operators........................................................................................200 Operator Overloading Examples .........................................................................................................201 Unary Operators Overloading .............................................................................................................201 Increment (++) and Decrement (- -) Operators....................................................................................203 Binary Operators Overloading.............................................................................................................205 Relational Operators Overloading.......................................................................................................208 Input/Output Operators Overloading..................................................................................................210 ++ and - - Operators Overloading ........................................................................................................212 Assignment Operators Overloading ....................................................................................................214 Function Call () Operator Overloading.................................................................................................215 Subscripting [ ] Operator Overloading.................................................................................................217 Class Member Access Operator - &gt; Overloading ..................................................................................219 26. POLYMORPHISM.............................................................................................................. 223 Virtual Function ..................................................................................................................................226 Pure Virtual Functions.........................................................................................................................226 27. DATA ABSTRACTION ........................................................................................................ 227 Access Labels Enforce Abstraction.......................................................................................................228 Benefits of Data Abstraction ...............................................................................................................228 Data Abstraction Example...................................................................................................................228 Designing Strategy ..............................................................................................................................230 28. DATA ENCAPSULATION .................................................................................................... 231 ix Data Encapsulation Example ...............................................................................................................232 Designing Strategy ..............................................................................................................................233 29. INTERFACES ..................................................................................................................... 234 Abstract Class Example .......................................................................................................................234 Designing Strategy ..............................................................................................................................236 30. FILES AND STREAMS ........................................................................................................ 238 Opening a File .....................................................................................................................................238 Closing a File .......................................................................................................................................239 Writing to a File...................................................................................................................................239 Reading from a File .............................................................................................................................239 Read &amp; Write Example ........................................................................................................................240 File Position Pointers...........................................................................................................................242 31. EXCEPTION HANDLING ...................................................................................................... 243 Throwing Exceptions...........................................................................................................................244 Catching Exceptions ............................................................................................................................244 C++ Standard Exceptions.....................................................................................................................246 Define New Exceptions .......................................................................................................................247 32. DYNAMIC MEMORY ......................................................................................................... 249 The new and delete Operators............................................................................................................249 Dynamic Memory Allocation for Arrays ..............................................................................................251 Dynamic Memory Allocation for Objects.............................................................................................251 33. NAMESPACES .................................................................................................................. 253 Defining a Namespace.........................................................................................................................253 The using directive ..............................................................................................................................254 x Discontiguous Namespaces.................................................................................................................256 Nested Namespaces............................................................................................................................256 34. TEMPLATES ..................................................................................................................... 258 Function Template ..............................................................................................................................258 Class Template ....................................................................................................................................259 35. PREPROCESSOR ............................................................................................................... 263 The #define Preprocessor....................................................................................................................263 Function-Like Macros..........................................................................................................................264 Conditional Compilation .....................................................................................................................264 The # and # # Operators......................................................................................................................266 Predefined C++ Macros .......................................................................................................................268 36. SIGNAL HANDLING .......................................................................................................... 270 The signal() Function ...........................................................................................................................270 The raise() Function.............................................................................................................................272 37. MULTITHREADING ........................................................................................................... 274 Creating Threads.................................................................................................................................274 Terminating Threads...........................................................................................................................275 Passing Arguments to Threads............................................................................................................277 Joining and Detaching Threads............................................................................................................278 38. WEB PROGRAMMING ...................................................................................................... 282 What is CGI?........................................................................................................................................282 Web Browsing.....................................................................................................................................282 CGI Architecture Diagram....................................................................................................................282 Web Server Configuration ...................................................................................................................283 First CGI Program ................................................................................................................................284 xi My First CGI program ..........................................................................................................................284 HTTP Header .......................................................................................................................................285 CGI Environment Variables..................................................................................................................285 C++ CGI Library....................................................................................................................................289 GET and POST Methods.......................................................................................................................289 Passing Information Using GET Method ..............................................................................................289 Simple URL Example: Get Method.......................................................................................................290 Simple FORM Example: GET Method...................................................................................................291 Passing Information Using POST Method ............................................................................................292 Passing Checkbox Data to CGI Program...............................................................................................292 Passing Radio Button Data to CGI Program .........................................................................................294 Passing Text Area Data to CGI Program...............................................................................................296 Passing Dropdown Box Data to CGI Program.......................................................................................298 Using Cookies in CGI............................................................................................................................299 How It Works ......................................................................................................................................299 Setting up Cookies...............................................................................................................................300 Retrieving Cookies...............................................................................................................................301 File Upload Example............................................................................................................................303 39. STL TUTORIAL .................................................................................................................. 306 40. STANDARD LIBRARY ......................................................................................................... 309 The Standard Function Library ............................................................................................................309 The Object Oriented Class Library .......................................................................................................309 C++ 1 C++ is a statically typed, compiled, general-purpose, case-sensitive, free-form programming language that supports procedural, object-oriented, and generic programming. C++ is regarded as a middle-level language, as it comprises a combination of both high-level and low-level language features. C++ was developed by Bjarne Stroustrup starting in 1979 at Bell Labs in Murray Hill, New Jersey, as an enhancement to the C language and originally named C with Classes but later it was renamed C++ in 1983. C++ is a superset of C, and that virtually any legal C program is a legal C++ program. Note: A programming language is said to use static typing when type checking is performed during compile-time as opposed to run-time. Object-Oriented Programming C++ fully supports object-oriented programming, including the four pillars of object-oriented development: · Encapsulation · Data hiding · Inheritance · Polymorphism Standard Libraries Standard C++ consists of three important parts: · The core language giving all the building blocks including variables, data types and literals, etc. · The C++ Standard Library giving a rich set of functions manipulating files, strings, etc. · The Standard Template Library (STL) giving a rich set of methods manipulating data structures, etc. The ANSI Standard The ANSI standard is an attempt to ensure that C++ is portable; that code you write for Microsoft's compiler will compile without errors, using a compiler on a Mac, UNIX, a Windows box, or an Alpha. 1. OVERVIEW C++ 2 The ANSI standard has been stable for a while, and all the major C++ compiler manufacturers support the ANSI standard. Learning C++ The most important thing while learning C++ is to focus on concepts. The purpose of learning a programming language is to become a better programmer; that is, to become more effective at designing and implementing new systems and at maintaining old ones. C++ supports a variety of programming styles. You can write in the style of Fortran, C, Smalltalk, etc., in any language. Each style can achieve its aims effectively while maintaining runtime and space efficiency. Use of C++ C++ is used by hundreds of thousands of programmers in essentially every application domain. C++ is being highly used to write device drivers and other software that rely on direct manipulation of hardware under real-time constraints. C++ is widely used for teaching and research because it is clean enough for successful teaching of basic concepts. Anyone who has used either an Apple Macintosh or a PC running Windows has indirectly used C++ because the primary user interfaces of these systems are written in C++. C++ 3 Try it Option Online You really do not need to set up your own environment to start learning C++ programming language. Reason is very simple, we have already set up C++ Programming environment online, so that you can compile and execute all the available examples online at the same time when you are doing your theory work. This gives you confidence in what you are reading and to check the result with different options. Feel free to modify any example and execute it online. Try the following example using our online compiler option available at http://www.compileonline.com/ #include using namespace std; int main() { cout &lt;&lt; "Hello World"; return 0; } For most of the examples given in this tutorial, you will find Try it option in our website code sections at the top right corner that will take you to the online compiler. So just make use of it and enjoy your learning. Local Environment Setup If you are still willing to set up your environment for C++, you need to have the following two softwares on your computer. Text Editor: This will be used to type your program. Examples of few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi. Name and version of text editor can vary on different operating systems. For example, Notepad will be used on Windows and vim or vi can be used on windows as well as Linux, or UNIX. The files you create with your editor are called source files and for C++ they typically are named with the extension .cpp, .cp, or .c. A text editor should be in place to start your C++ programming. 2. ENVIORNMENT SETUP C++ 4 C++ Compiler: This is an actual C++ compiler, which will be used to compile your source code into final executable program. Most C++ compilers don't care what extension you give to your source code, but if you don't specify otherwise, many will use .cpp by default. Most frequently used and free available compiler is GNU C/C++ compiler, otherwise you can have compilers either from HP or Solaris if you have the respective Operating Systems. Installing GNU C/C++ Compiler: UNIX/Linux Installation: If you are using Linux or UNIX then check whether GCC is installed on your system by entering the following command from the command line: $ g++ -v If you have installed GCC, then it should print a message such as the following: Using built-in specs. Target: i386-redhat-linux Configured with: ../configure --prefix=/usr ....... Thread model: posix gcc version 4.1.2 20080704 (Red Hat 4.1.2-46) If GCC is not installed, then you will have to install it yourself using the detailed instructions available at http://gcc.gnu.org/install/ . Mac OS X Installation: If you use Mac OS X, the easiest way to obtain GCC is to download the Xcode development environment from Apple's website and follow the simple installation instructions. Xcode is currently available at developer.apple.com/technologies/tools/. Windows Installation: To install GCC at Windows you need to install MinGW. To install MinGW, go to the MinGW homepage, www.mingw.org, and follow the link to the MinGW download page. Download the latest version of the MinGW installation program which should be named MinGW-.exe. While installing MinGW, at a minimum, you must install gcc-core, gcc-g++, binutils, and the MinGW runtime, but you may wish to install more. C++ 5 Add the bin subdirectory of your MinGW installation to your PATH environment variable so that you can specify these tools on the command line by their simple names. When the installation is complete, you will be able to run gcc, g++, ar, ranlib, dlltool, and several other GNU tools from the Windows command line. C++ 6 When we consider a C++ program, it can be defined as a collection of objects that communicate via invoking each other's methods. Let us now briefly look into what a class, object, methods, and instant variables mean. · Object - Objects have states and behaviors. Example: A dog has states - color, name, breed as well as behaviors - wagging, barking, and eating. An object is an instance of a class. · Class - A class can be defined as a template/blueprint that describes the behaviors/states that object of its type support. · Methods - A method is basically a behavior. A class can contain many methods. It is in methods where the logics are written, data is manipulated and all the actions are executed. · Instant Variables - Each object has its unique set of instant variables. An object's state is created by the values assigned to these instant variables. C++ Program Structure: Let us look at a simple code that would print the words Hello World. #include using namespace std; // main() is where program execution begins. int main() { cout &lt;&lt; "Hello World"; // prints Hello World return 0; } Let us look at the various parts of the above program: 1. The C++ language defines several headers, which contain information that is either necessary or useful to your program. For this program, the header is needed. 2. The line using namespace std; tells the compiler to use the std namespace. Namespaces are a relatively recent addition to C++. 3. BASIC SYNTAX C++ 7 3. The next line ‘// main() is where program execution begins.’ is a single-line comment available in C++. Single-line comments begin with // and stop at the end of the line. 4. The line int main() is the main function where program execution begins. 5. The next line cout &lt;&lt; "This is my first C++ program."; causes the message "This is my first C++ program" to be displayed on the screen. 6. The next line return 0; terminates main() function and causes it to return the value 0 to the calling process. Compile &amp; Execute C++ Program: Let's look at how to save the file, compile and run the program. Please follow the steps given below: 1. Open a text editor and add the code as above. 2. Save the file as: hello.cpp 3. Open a command prompt and go to the directory where you saved the file. 4. Type 'g++ hello.cpp' and press enter to compile your code. If there are no errors in your code the command prompt will take you to the next line and would generate a.out executable file. 5. Now, type 'a.out' to run your program. 6. You will be able to see ' Hello World ' printed on the window. $ g++ hello.cpp $ ./a.out Hello World Make sure that g++ is in your path and that you are running it in the directory containing file hello.cpp. You can compile C/C++ programs using makefile. For more details, you can check our ‘Makefile Tutorial’. Semicolons &amp; Blocks in C++ In C++, the semicolon is a statement terminator. That is, each individual statement must be ended with a semicolon. It indicates the end of one logical entity. For example, following are three different statements: x = y; y = y+1; C++ 8 add(x, y); A block is a set of logically connected statements that are surrounded by opening and closing braces. For example: { cout &lt;&lt; "Hello World"; // prints Hello World return 0; } C++ does not recognize the end of the line as a terminator. For this reason, it does not matter where you put a statement in a line. For example: x = y; y = y+1; add(x, y); is the same as x = y; y = y+1; add(x, y); C++ Identifiers A C++ identifier is a name used to identify a variable, function, class, module, or any other user-defined item. An identifier starts with a letter A to Z or a to z or an underscore (_) followed by zero or more letters, underscores, and digits (0 to 9). C++ does not allow punctuation characters such as @, $, and % within identifiers. C++ is a case-sensitive programming language. Thus, Manpower and manpower are two different identifiers in C++. Here are some examples of acceptable identifiers: mohd zara abc move_name a_123 myname50 _temp j a23b9 retVal C++ Keywords The following list shows the reserved words in C++. These reserved words may not be used as constant or variable or any other identifier names. asm else new this auto enum operator throw C++ 9 bool explicit private true break export protected try case extern public typedef catch false register typeid char float reinterpret_cast typename class for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template Trigraphs A few characters have an alternative representation, called a trigraph sequence. A trigraph is a three-character sequence that represents a single character and the sequence always starts with two question marks. Trigraphs are expanded anywhere they appear, including within string literals and character literals, in comments, and in preprocessor directives. Following are most frequently used trigraph sequences: Trigraph Replacement C++ 10 ??= # ??/ \ ??' ^ ??( [ ??) ] ??! | ??&lt; { ??&gt; } ??- ~ All the compilers do not support trigraphs and they are not advised to be used because of their confusing nature. Whitespace in C++ A line containing only whitespace, possibly with a comment, is known as a blank line, and C++ compiler totally ignores it. Whitespace is the term used in C++ to describe blanks, tabs, newline characters and comments. Whitespace separates one part of a statement from another and enables the compiler to identify where one element in a statement, such as int, ends and the next element begins. Statement 1: int age; In the above statement there must be at least one whitespace character (usually a space) between int and age for the compiler to be able to distinguish them. Statement 2: fruit = apples + oranges; // Get the total fruit In the above statement 2, no whitespace characters are necessary between fruit and =, or between = and apples, although you are free to include some if you wish for readability purpose. C++ 11 Program comments are explanatory statements that you can include in the C++ code. These comments help anyone reading the source code. All programming languages allow for some form of comments. C++ supports single-line and multi-line comments. All characters available inside any comment are ignored by C++ compiler. C++ comments start with /* and end with */. For example: /* This is a comment */ /* C++ comments can also * span multiple lines */ A comment can also start with //, extending to the end of the line. For example: #include using namespace std; main() { cout &lt;&lt; "Hello World"; // prints Hello World return 0; } When the above code is compiled, it will ignore // prints Hello World and final executable will produce the following result: Hello World Within a /* and */ comment, // characters have no special meaning. Within a // comment, /* and */ have no special meaning. Thus, you can "nest" one kind of comment within the other kind. For example: /* Comment out printing of Hello World: 4. COMMENTS IN C++ C++ 12 cout &lt;&lt; "Hello World"; // prints Hello World */ C++ 13 While writing program in any language, you need to use various variables to store various information. Variables are nothing but reserved memory locations to store values. This means that when you create a variable you reserve some space in memory. You may like to store information of various data types like character, wide character, integer, floating point, double floating point, boolean etc. Based on the data type of a variable, the operating system allocates memory and decides what can be stored in the reserved memory. Primitive Built-in Types C++ offers the programmer a rich assortment of built-in as well as user defined data types. Following table lists down seven basic C++ data types: Type Keyword Boolean bool Character char Integer int Floating point float Double floating point double Valueless void Wide character wchar_t Several of the basic types can be modified using one or more of these type modifiers: · signed · unsigned · short · long 5. DATA TYPES C++ 14 The following table shows the variable type, how much memory it takes to store the value in memory, and what is maximum and minimum value which can be stored in such type of variables. Type Typical Bit Width Typical Range char 1byte -127 to 127 or 0 to 255 unsigned char 1byte 0 to 255 signed char 1byte -127 to 127 int 4bytes -2147483648 to 2147483647 unsigned int 4bytes 0 to 4294967295 signed int 4bytes -2147483648 to 2147483647 short int 2bytes -32768 to 32767 unsigned short int Range 0 to 65,535 signed short int Range -32768 to 32767 long int 4bytes -2,147,483,647 to 2,147,483,647 signed long int 4bytes same as long int unsigned long int 4bytes 0 to 4,294,967,295 float 4bytes +/- 3.4e +/- 38 (~7 digits) double 8bytes +/- 1.7e +/- 308 (~15 digits) long double 8bytes +/- 1.7e +/- 308 (~15 digits) wchar_t 2 or 4 bytes 1 wide character The size of variables might be different from those shown in the above table, depending on the compiler and the computer you are using. C++ 15 Following is the example, which will produce correct size of various data types on your computer. #include using namespace std; int main() { cout &lt;&lt; "Size of char : " &lt;&lt; sizeof(char) &lt;&lt; endl; cout &lt;&lt; "Size of int : " &lt;&lt; sizeof(int) &lt;&lt; endl; cout &lt;&lt; "Size of short int : " &lt;&lt; sizeof(short int) &lt;&lt; endl; cout &lt;&lt; "Size of long int : " &lt;&lt; sizeof(long int) &lt;&lt; endl; cout &lt;&lt; "Size of float : " &lt;&lt; sizeof(float) &lt;&lt; endl; cout &lt;&lt; "Size of double : " &lt;&lt; sizeof(double) &lt;&lt; endl; cout &lt;&lt; "Size of wchar_t : " &lt;&lt; sizeof(wchar_t) &lt;&lt; endl; return 0; } This example uses endl, which inserts a new-line character after every line and &lt;&lt; operator is being used to pass multiple values out to the screen. We are also using sizeof() function to get size of various data types. When the above code is compiled and executed, it produces the following result which can vary from machine to machine: Size of char : 1 Size of int : 4 Size of short int : 2 Size of long int : 4 Size of float : 4 Size of double : 8 Size of wchar_t : 4 typedef Declarations You can create a new name for an existing type using typedef. Following is the simple syntax to define a new type using typedef: typedef type newname; For example, the following tells the compiler that feet is another name for int: C++ 16 typedef int feet; Now, the following declaration is perfectly legal and creates an integer variable called distance: feet distance; Enumerated Types An enumerated type declares an optional type name and a set of zero or more identifiers that can be used as values of the type. Each enumerator is a constant whose type is the enumeration. Creating an enumeration requires the use of the keyword enum. The general form of an enumeration type is: enum enum-name { list of names } var-list; Here, the enum-name is the enumeration's type name. The list of names is comma separated. For example, the following code defines an enumeration of colors called colors and the variable c of type color. Finally, c is assigned the value "blue". enum color { red, green, blue } c; c = blue; By default, the value of the first name is 0, the second name has the value 1, and the third has the value 2, and so on. But you can give a name, a specific value by adding an initializer. For example, in the following enumeration, green will have the value 5. enum color { red, green=5, blue }; Here, blue will have a value of 6 because each name will be one greater than the one that precedes it. C++ 17 A variable provides us with named storage that our programs can manipulate. Each variable in C++ has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable. The name of a variable can be composed of letters, digits, and the underscore character. It must begin with either a letter or an underscore. Upper and lowercase letters are distinct because C++ is case-sensitive: There are following basic types of variable in C++ as explained in last chapter: Type Description bool Stores either value true or false. char Typically a single octet (one byte). This is an integer type. int The most natural size of integer for the machine. float A single-precision floating point value. double A double-precision floating point value. void Represents the absence of type. wchar_t A wide character type. C++ also allows to define various other types of variables, which we will cover in subsequent chapters like Enumeration, Pointer, Array, Reference, Data structures, and Classes. Following section will cover how to define, declare and use various types of variables. Variable Definition in C++ A variable definition tells the compiler where and how much storage to create for the variable. A variable definition specifies a data type, and contains a list of one or more variables of that type as follows: 6. VARIABLE TYPES C++ 18 type variable_list; Here, type must be a valid C++ data type including char, w_char, int, float, double, bool or any user-defined object, etc., and variable_list may consist of one or more identifier names separated by commas. Some valid declarations are shown here: int i, j, k; char c, ch; float f, salary; double d; The line int i, j, k; both declares and defines the variables i, j and k; which instructs the compiler to create variables named i, j and k of type int. Variables can be initialized (assigned an initial value) in their declaration. The initializer consists of an equal sign followed by a constant expression as follows: type variable_name = value; Some examples are: extern int d = 3, f = 5; // declaration of d and f. int d = 3, f = 5; // definition and initializing d and f. byte z = 22; // definition and initializes z. char x = 'x'; // the variable x has the value 'x'. For definition without an initializer: variables with static storage duration are implicitly initialized with NULL (all bytes have the value 0); the initial value of all other variables is undefined. Variable Declaration in C++ A variable declaration provides assurance to the compiler that there is one variable existing with the given type and name so that compiler proceed for further compilation without needing complete detail about the variable. A variable declaration has its meaning at the time of compilation only, compiler needs actual variable declaration at the time of linking of the program. A variable declaration is useful when you are using multiple files and you define your variable in one of the files which will be available at the time of linking of the program. You will use extern keyword to declare a variable at any place. Though you can declare a variable multiple times in your C++ program, but it can be defined only once in a file, a function or a block of code. Example: C++ 19 Try the following example where a variable has been declared at the top, but it has been defined inside the main function: #include using namespace std; // Variable declaration: extern int a, b; extern int c; extern float f; int main () { // Variable definition: int a, b; int c; float f; // actual initialization a = 10; b = 20; c = a + b; cout &lt;&lt; c &lt;&lt; endl ; f = 70.0/3.0; cout &lt;&lt; f &lt;&lt; endl ; return 0; } When the above code is compiled and executed, it produces the following result: 30 23.3333 C++ 20 Same concept applies on function declaration where you provide a function name at the time of its declaration and its actual definition can be given anywhere else. For example: // function declaration int func(); int main() { // function call int i = func(); } // function definition int func() { return 0; } Lvalues and Rvalues There are two kinds of expressions in C++: · lvalue : Expressions that refer to a memory location is called "lvalue" expression. An lvalue may appear as either the left-hand or right-hand side of an assignment. · rvalue : The term rvalue refers to a data value that is stored at some address in memory. An rvalue is an expression that cannot have a value assigned to it which means an rvalue may appear on the right- but not left-hand side of an assignment. Variables are lvalues and so may appear on the left-hand side of an assignment. Numeric literals are rvalues and so may not be assigned and cannot appear on the left-hand side. Following is a valid statement: int g = 20; But the following is not a valid statement and would generate compile-time error: 10 = 20; C++ 21 A scope is a region of the program and broadly speaking there are three places, where variables can be declared: · Inside a function or a block which is called local variables, · In the definition of function parameters which is called formal parameters. · Outside of all functions which is called global variables. We will learn what a function is, and it's parameter in subsequent chapters. Here let us explain what local and global variables are. Local Variables Variables that are declared inside a function or block are local variables. They can be used only by statements that are inside that function or block of code. Local variables are not known to functions outside their own. Following is the example using local variables: #include using namespace std; int main () { // Local variable declaration: int a, b; int c; // actual initialization a = 10; b = 20; c = a + b; cout &lt;&lt; c; return 0; } 7. VARIABLE SCOPE C++ 22 Global Variables Global variables are defined outside of all the functions, usually on top of the program. The global variables will hold their value throughout the life-time of your program. A global variable can be accessed by any function. That is, a global variable is available for use throughout your entire program after its declaration. Following is the example using global and local variables: #include using namespace std; // Global variable declaration: int g; int main () { // Local variable declaration: int a, b; // actual initialization a = 10; b = 20; g = a + b; cout &lt;&lt; g; return 0; } A program can have same name for local and global variables but value of local variable inside a function will take preference. For example: #include using namespace std; // Global variable declaration: int g = 20; C++ 23 int main () { // Local variable declaration: int g = 10; cout &lt;&lt; g; return 0; } When the above code is compiled and executed, it produces the following result: 10 Initializing Local and Global Variables When a local variable is defined, it is not initialized by the system, you must initialize it yourself. Global variables are initialized automatically by the system when you define them as follows: Data Type Initializer int 0 char '\0' float 0 double 0 pointer NULL It is a good programming practice to initialize variables properly, otherwise sometimes program would produce unexpected result. C++ 24 Constants refer to fixed values that the program may not alter and they are called literals. Constants can be of any of the basic data types and can be divided into Integer Numerals, Floating-Point Numerals, Characters, Strings and Boolean Values. Again, constants are treated just like regular variables except that their values cannot be modified after their definition. Integer Literals An integer literal can be a decimal, octal, or hexadecimal constant. A prefix specifies the base or radix: 0x or 0X for hexadecimal, 0 for octal, and nothing for decimal. An integer literal can also have a suffix that is a combination of U and L, for unsigned and long, respectively. The suffix can be uppercase or lowercase and can be in any order. Here are some examples of integer literals: 212 // Legal 215u // Legal 0xFeeL // Legal 078 // Illegal: 8 is not an octal digit 032UU // Illegal: cannot repeat a suffix Following are other examples of various types of Integer literals: 85 // decimal 0213 // octal 0x4b // hexadecimal 30 // int 30u // unsigned int 30l // long 30ul // unsigned long Floating-point Literals A floating-point literal has an integer part, a decimal point, a fractional part, and an exponent part. You can represent floating point literals either in decimal form or exponential form. 8. CONSTANTS/LITERALS C++ 25 While representing using decimal form, you must include the decimal point, the exponent, or both and while representing using exponential form, you must include the integer part, the fractional part, or both. The signed exponent is introduced by e or E. Here are some examples of floating-point literals: 3.14159 // Legal 314159E-5L // Legal 510E // Illegal: incomplete exponent 210f // Illegal: no decimal or exponent .e55 // Illegal: missing integer or fraction Boolean Literals There are two Boolean literals and they are part of standard C++ keywords: · A value of true representing true. · A value of false representing false. You should not consider the value of true equal to 1 and value of false equal to 0. Character Literals Character literals are enclosed in single quotes. If the literal begins with L (uppercase only), it is a wide character literal (e.g., L'x') and should be stored in wchar_t type of variable. Otherwise, it is a narrow character literal (e.g., 'x') and can be stored in a simple variable of char type. A character literal can be a plain character (e.g., 'x'), an escape sequence (e.g., '\t'), or a universal character (e.g., '\u02C0'). There are certain characters in C++ when they are preceded by a backslash they will have special meaning and they are used to represent like newline (\n) or tab (\t). Here, you have a list of some of such escape sequence codes: Escape sequence Meaning \\ \ character \' ' character \" " character \? ? character C++ 26 \a Alert or bell \b Backspace \f Form feed \n Newline \r Carriage return \t Horizontal tab \v Vertical tab \ooo Octal number of one to three digits \xhh . . . Hexadecimal number of one or more digits Following is the example to show a few escape sequence characters: #include using namespace std; int main() { cout &lt;&lt; "Hello\tWorld\n\n"; return 0; } When the above code is compiled and executed, it produces the following result: Hello World String Literals String literals are enclosed in double quotes. A string contains characters that are similar to character literals: plain characters, escape sequences, and universal characters. C++ 27 You can break a long line into multiple lines using string literals and separate them using whitespaces. Here are some examples of string literals. All the three forms are identical strings. "hello, dear" "hello, \ dear" "hello, " "d" "ear" Defining Constants There are two simple ways in C++ to define constants: · Using #define preprocessor. · Using const keyword. The #define Preprocessor Following is the form to use #define preprocessor to define a constant: #define identifier value Following example explains it in detail: #include using namespace std; #define LENGTH 10 #define WIDTH 5 #define NEWLINE '\n' int main() { int area; area = LENGTH * WIDTH; C++ 28 cout &lt;&lt; area; cout &lt;&lt; NEWLINE; return 0; } When the above code is compiled and executed, it produces the following result: 50 The const Keyword You can use const prefix to declare constants with a specific type as follows: const type variable = value; Following example explains it in detail: #include using namespace std; int main() { const int LENGTH = 10; const int WIDTH = 5; const char NEWLINE = '\n'; int area; area = LENGTH * WIDTH; cout &lt;&lt; area; cout &lt;&lt; NEWLINE; return 0; } When the above code is compiled and executed, it produces the following result: 50 Note that it is a good programming practice to define constants in CAPITALS. C++ 29 C++ allows the char, int, and double data types to have modifiers preceding them. A modifier is used to alter the meaning of the base type so that it more precisely fits the needs of various situations. The data type modifiers are listed here: · signed · unsigned · long · short The modifiers signed, unsigned, long, and short can be applied to integer base types. In addition, signed and unsigned can be applied to char, and long can be applied to double. The modifiers signed and unsigned can also be used as prefix to long or short modifiers. For example, unsigned long int. C++ allows a shorthand notation for declaring unsigned, short, or long integers. You can simply use the word unsigned, short, or long, without int. It automatically implies int. For example, the following two statements both declare unsigned integer variables. unsigned x; unsigned int y; To understand the difference between the way signed and unsigned integer modifiers are interpreted by C++, you should run the following short program: #include using namespace std; /* This program shows the difference between * signed and unsigned integers. */ int main() { short int i; // a signed short integer short unsigned int j; // an unsigned short integer 9. MODIFIER TYPES C++ 30 j = 50000; i = j; cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j; return 0; } When this program is run, following is the output: -15536 50000 The above result is because the bit pattern that represents 50,000 as a short unsigned integer is interpreted as -15,536 by a short. Type Qualifiers in C++ The type qualifiers provide additional information about the variables they precede. Qualifier Meaning const Objects of type const cannot be changed by your program during execution volatile The modifier volatile tells the compiler that a variable's value may be changed in ways not explicitly specified by the program. restrict A pointer qualified by restrict is initially the only means by which the object it points to can be accessed. Only C99 adds a new type qualifier called restrict. C++ 31 A storage class defines the scope (visibility) and life-time of variables and/or functions within a C++ Program. These specifiers precede the type that they modify. There are following storage classes, which can be used in a C++ Program · auto · register · static · extern · mutable The auto Storage Class The auto storage class is the default storage class for all local variables. { int mount; auto int month; } The example above defines two variables with the same storage class, auto can only be used within functions, i.e., local variables. The register Storage Class The register storage class is used to define local variables that should be stored in a register instead of RAM. This means that the variable has a maximum size equal to the register size (usually one word) and can't have the unary '&amp;' operator applied to it (as it does not have a memory location). { register int miles; } The register should only be used for variables that require quick access such as counters. It should also be noted that defining 'register' does not mean that the variable will be stored in a register. It means that it MIGHT be stored in a register depending on hardware and implementation restrictions. The static Storage Class 10. STORAGE CLASSES C++ 32 The static storage class instructs the compiler to keep a local variable in existence during the life-time of the program instead of creating and destroying it each time it comes into and goes out of scope. Therefore, making local variables static allows them to maintain their values between function calls. The static modifier may also be applied to global variables. When this is done, it causes that variable's scope to be restricted to the file in which it is declared. In C++, when static is used on a class data member, it causes only one copy of that member to be shared by all objects of its class. #include // Function declaration void func(void); static int count = 10; /* Global variable */ main() { while(count--) { func(); } return 0; } // Function definition void func( void ) { static int i = 5; // local static variable i++; std::cout &lt;&lt; "i is " &lt;&lt; i ; std::cout &lt;&lt; " and count is " &lt;&lt; count &lt;&lt; std::endl; } When the above code is compiled and executed, it produces the following result: i is 6 and count is 9 i is 7 and count is 8 C++ 33 i is 8 and count is 7 i is 9 and count is 6 i is 10 and count is 5 i is 11 and count is 4 i is 12 and count is 3 i is 13 and count is 2 i is 14 and count is 1 i is 15 and count is 0 The extern Storage Class The extern storage class is used to give a reference of a global variable that is visible to ALL the program files. When you use 'extern' the variable cannot be initialized as all it does is point the variable name at a storage location that has been previously defined. When you have multiple files and you define a global variable or function, which will be used in other files also, then extern will be used in another file to give reference of defined variable or function. Just for understanding extern is used to declare a global variable or function in another file. The extern modifier is most commonly used when there are two or more files sharing the same global variables or functions as explained below. First File: main.cpp #include int count ; extern void write_extern(); main() { count = 5; write_extern(); } Second File: support.cpp #include C++ 34 extern int count; void write_extern(void) { std::cout &lt;&lt; "Count is " &lt;&lt; count &lt;&lt; std::endl; } Here, extern keyword is being used to declare count in another file. Now compile these two files as follows: $g++ main.cpp support.cpp -o write This will produce write executable program, try to execute write and check the result as follows: $./write 5 The mutable Storage Class The mutable specifier applies only to class objects, which are discussed later in this tutorial. It allows a member of an object to override const member function. That is, a mutable member can be modified by a const member function. C++ 35 An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. C++ is rich in built-in operators and provide the following types of operators: · Arithmetic Operators · Relational Operators · Logical Operators · Bitwise Operators · Assignment Operators · Misc Operators This chapter will examine the arithmetic, relational, logical, bitwise, assignment and other operators one by one. Arithmetic Operators There are following arithmetic operators supported by C++ language: Assume variable A holds 10 and variable B holds 20, then: Operator Description Example + Adds two operands A + B will give 30 - Subtracts second operand from the first A - B will give -10 * Multiplies both operands A * B will give 200 / Divides numerator by denumerator B / A will give 2 % Modulus Operator and remainder of after an integer division B % A will give 0 11. OPERATORS C++ 36 ++ Increment operator, increases integer value by one A++ will give 11 -- Decrement operator, decreases integer value by one A-- will give 9 Try the following example to understand all the arithmetic operators available in C++. Copy and paste the following C++ program in test.cpp file and compile and run this program. #include using namespace std; main() { int a = 21; int b = 10; int c ; c = a + b; cout &lt;&lt; "Line 1 - Value of c is :" &lt;&lt; c &lt;&lt; endl ; c = a - b; cout &lt;&lt; "Line 2 - Value of c is :" &lt;&lt; c &lt;&lt; endl ; c = a * b; cout &lt;&lt; "Line 3 - Value of c is :" &lt;&lt; c &lt;&lt; endl ; c = a / b; cout &lt;&lt; "Line 4 - Value of c is :" &lt;&lt; c &lt;&lt; endl ; c = a % b; cout &lt;&lt; "Line 5 - Value of c is :" &lt;&lt; c &lt;&lt; endl ; c = a++; cout &lt;&lt; "Line 6 - Value of c is :" &lt;&lt; c &lt;&lt; endl ; c = a--; cout &lt;&lt; "Line 7 - Value of c is :" &lt;&lt; c &lt;&lt; endl ; return 0; C++ 37 } When the above code is compiled and executed, it produces the following result: Line 1 - Value of c is :31 Line 2 - Value of c is :11 Line 3 - Value of c is :210 Line 4 - Value of c is :2 Line 5 - Value of c is :1 Line 6 - Value of c is :21 Line 7 - Value of c is :22 Relational Operators There are following relational operators supported by C++ language Assume variable A holds 10 and variable B holds 20, then: Operator Description Example == Checks if the values of two operands are equal or not, if yes then condition becomes true. (A == B) is not true. != Checks if the values of two operands are equal or not, if values are not equal then condition becomes true. (A != B) is true. &gt; Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true. (A &gt; B) is not true. &lt; Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true. (A &lt; B) is true. &gt;= Checks if the value of left (A &gt;= B) is not true. C++ 38 operand is greater than or equal to the value of right operand, if yes then condition becomes true. &lt;= Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true. (A &lt;= B) is true. Try the following example to understand all the relational operators available in C++. Copy and paste the following C++ program in test.cpp file and compile and run this program. #include using namespace std; main() { int a = 21; int b = 10; int c ; if( a == b ) { cout &lt;&lt; "Line 1 - a is equal to b" &lt;&lt; endl ; } else { cout &lt;&lt; "Line 1 - a is not equal to b" &lt;&lt; endl ; } if ( a &lt; b ) { cout &lt;&lt; "Line 2 - a is less than b" &lt;&lt; endl ; C++ 39 } else { cout &lt;&lt; "Line 2 - a is not less than b" &lt;&lt; endl ; } if ( a &gt; b ) { cout &lt;&lt; "Line 3 - a is greater than b" &lt;&lt; endl ; } else { cout &lt;&lt; "Line 3 - a is not greater than b" &lt;&lt; endl ; } /* Let's change the values of a and b */ a = 5; b = 20; if ( a &lt;= b ) { cout &lt;&lt; "Line 4 - a is either less than \ or equal to b" &lt;&lt; endl ; } if ( b &gt;= a ) { cout &lt;&lt; "Line 5 - b is either greater than \ or equal to b" &lt;&lt; endl ; } return 0; } When the above code is compiled and executed, it produces the following result: Line 1 - a is not equal to b Line 2 - a is not less than b Line 3 - a is greater than b Line 4 - a is either less than or equal to b C++ 40 Line 5 - b is either greater than or equal to b Logical Operators There are following logical operators supported by C++ language. Assume variable A holds 1 and variable B holds 0, then: Operator Description Example &amp;&amp; Called Logical AND operator. If both the operands are non-zero, then condition becomes true. (A &amp;&amp; B) is false. || Called Logical OR Operator. If any of the two operands is nonzero, then condition becomes true. (A || B) is true. ! Called Logical NOT Operator. Use to reverses the logical state of its operand. If a condition is true, then Logical NOT operator will make false. !(A &amp;&amp; B) is true. Try the following example to understand all the logical operators available in C++. Copy and paste the following C++ program in test.cpp file and compile and run this program. #include using namespace std; main() { int a = 5; int b = 20; int c ; C++ 41 if ( a &amp;&amp; b ) { cout &lt;&lt; "Line 1 - Condition is true"&lt;&lt; endl ; } if ( a || b ) { cout &lt;&lt; "Line 2 - Condition is true"&lt;&lt; endl ; } /* Let's change the values of a and b */ a = 0; b = 10; if ( a &amp;&amp; b ) { cout &lt;&lt; "Line 3 - Condition is true"&lt;&lt; endl ; } else { cout &lt;&lt; "Line 4 - Condition is not true"&lt;&lt; endl ; } if ( !(a &amp;&amp; b) ) { cout &lt;&lt; "Line 5 - Condition is true"&lt;&lt; endl ; } return 0; } When the above code is compiled and executed, it produces the following result: Line 1 - Condition is true Line 2 - Condition is true Line 4 - Condition is not true Line 5 - Condition is true Bitwise Operators C++ 42 Bitwise operator works on bits and perform bit-by-bit operation. The truth tables for &amp;, |, and ^ are as follows: p q p &amp; q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 Assume if A = 60; and B = 13; now in binary format they will be as follows: A = 0011 1100 B = 0000 1101 ----------------- A&amp;B = 0000 1100 A|B = 0011 1101 A^B = 0011 0001 ~A = 1100 0011 The Bitwise operators supported by C++ language are listed in the following table. Assume variable A holds 60 and variable B holds 13, then: Operator Description Example &amp; Binary AND Operator copies a bit to the result if it exists in both operands. (A &amp; B) will give 12 which is 0000 1100 | Binary OR Operator copies a bit if it exists in either operand. (A | B) will give 61 which is 0011 1101 ^ Binary XOR Operator copies the bit if it is set in one operand but not both. (A ^ B) will give 49 which is 0011 0001 C++ 43 ~ Binary Ones Complement Operator is unary and has the effect of 'flipping' bits. (~A ) will give -61 which is 1100 0011 in 2's complement form due to a signed binary number. &lt;&lt; Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand. A &lt;&lt; 2 will give 240 which is 1111 0000 &gt;&gt; Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand. A &gt;&gt; 2 will give 15 which is 0000 1111 Try the following example to understand all the bitwise operators available in C++. Copy and paste the following C++ program in test.cpp file and compile and run this program. #include using namespace std; main() { unsigned int a = 60; // 60 = 0011 1100 unsigned int b = 13; // 13 = 0000 1101 int c = 0; c = a &amp; b; // 12 = 0000 1100 cout &lt;&lt; "Line 1 - Value of c is : " &lt;&lt; c &lt;&lt; endl ; c = a | b; // 61 = 0011 1101 cout &lt;&lt; "Line 2 - Value of c is: " &lt;&lt; c &lt;&lt; endl ; c = a ^ b; // 49 = 0011 0001 cout &lt;&lt; "Line 3 - Value of c is: " &lt;&lt; c &lt;&lt; endl ; C++ 44 c = ~a; // -61 = 1100 0011 cout &lt;&lt; "Line 4 - Value of c is: " &lt;&lt; c &lt;&lt; endl ; c = a &lt;&lt; 2; // 240 = 1111 0000 cout &lt;&lt; "Line 5 - Value of c is: " &lt;&lt; c &lt;&lt; endl ; c = a &gt;&gt; 2; // 15 = 0000 1111 cout &lt;&lt; "Line 6 - Value of c is: " &lt;&lt; c &lt;&lt; endl ; return 0; } When the above code is compiled and executed, it produces the following result: Line 1 - Value of c is : 12 Line 2 - Value of c is: 61 Line 3 - Value of c is: 49 Line 4 - Value of c is: -61 Line 5 - Value of c is: 240 Line 6 - Value of c is: 15 Assignment Operators There are following assignment operators supported by C++ language: Operator Description Example = Simple assignment operator, Assigns values from right side operands to left side operand. C = A + B will assign value of A + B into C += Add AND assignment operator, It adds right operand to the left operand and assign the result to left operand. C += A is equivalent to C = C + A C++ 45 -= Subtract AND assignment operator, It subtracts right operand from the left operand and assign the result to left operand. C -= A is equivalent to C = C - A *= Multiply AND assignment operator, It multiplies right operand with the left operand and assign the result to left operand. C *= A is equivalent to C = C * A /= Divide AND assignment operator, It divides left operand with the right operand and assign the result to left operand. C /= A is equivalent to C = C / A %= Modulus AND assignment operator, It takes modulus using two operands and assign the result to left operand. C %= A is equivalent to C = C % A &lt;&lt;= Left shift AND assignment operator. C &lt;&lt;= 2 is same as C = C &lt;&lt; 2 &gt;&gt;= Right shift AND assignment operator. C &gt;&gt;= 2 is same as C = C &gt;&gt; 2 &amp;= Bitwise AND assignment operator. C &amp;= 2 is same as C = C &amp; 2 ^= Bitwise exclusive OR and assignment operator. C ^= 2 is same as C = C ^ 2 |= Bitwise inclusive OR and assignment operator. C |= 2 is same as C = C | 2 Try the following example to understand all the assignment operators available in C++. C++ 46 Copy and paste the following C++ program in test.cpp file and compile and run this program. #include using namespace std; main() { int a = 21; int c ; c = a; cout &lt;&lt; "Line 1 - = Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ; c += a; cout &lt;&lt; "Line 2 - += Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ; c -= a; cout &lt;&lt; "Line 3 - -= Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ; c *= a; cout &lt;&lt; "Line 4 - *= Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ; c /= a; cout &lt;&lt; "Line 5 - /= Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ; c = 200; c %= a; cout &lt;&lt; "Line 6 - %= Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ; c &lt;&lt;= 2; cout &lt;&lt; "Line 7 - &lt;&lt;= Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ; c &gt;&gt;= 2; cout &lt;&lt; "Line 8 - &gt;&gt;= Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ; C++ 47 c &amp;= 2; cout &lt;&lt; "Line 9 - &amp;= Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ; c ^= 2; cout &lt;&lt; "Line 10 - ^= Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ; c |= 2; cout &lt;&lt; "Line 11 - |= Operator, Value of c = : " &lt;&lt;c&lt;&lt; endl ; return 0; } When the above code is compiled and executed, it produces the following result: Line 1 - = Operator, Value of c = : 21 Line 2 - += Operator, Value of c = : 42 Line 3 - -= Operator, Value of c = : 21 Line 4 - *= Operator, Value of c = : 441 Line 5 - /= Operator, Value of c = : 21 Line 6 - %= Operator, Value of c = : 11 Line 7 - &lt;&lt;= Operator, Value of c = : 44 Line 8 - &gt;&gt;= Operator, Value of c = : 11 Line 9 - &amp;= Operator, Value of c = : 2 Line 10 - ^= Operator, Value of c = : 0 Line 11 - |= Operator, Value of c = : 2 Misc Operators The following table lists some other operators that C++ supports. Operator Description sizeof sizeof operator returns the size of a variable. For example, sizeof(a), where ‘a’ is integer, and will return 4. C++ 48 Condition ? X : Y Conditional operator (?). If Condition is true then it returns value of X otherwise returns value of Y. , Comma operator causes a sequence of operations to be performed. The value of the entire comma expression is the value of the last expression of the comma-separated list. . (dot) and -&gt; (arrow) Member operators are used to reference individual members of classes, structures, and unions. Cast Casting operators convert one data type to another. For example, int(2.2000) would return 2. &amp; Pointer operator ‘&amp;’ returns the address of a variable. For example &amp;a; will give actual address of the variable. * Pointer operator * is pointer to a variable. For example *var; will pointer to a variable var. Operators Precedence in C++ Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator: For example x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7. Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first. Category Operator Associativity Postfix () [] -&gt; . ++ - - Left to right Unary + - ! ~ ++ - - (type)* &amp; sizeof Right to left Multiplicative * / % Left to right C++ 49 Additive + - Left to right Shift &lt;&lt; &gt;&gt; Left to right Relational &lt; &lt;= &gt; &gt;= Left to right Equality == != Left to right Bitwise AND &amp; Left to right Bitwise XOR ^ Left to right Bitwise OR | Left to right Logical AND &amp;&amp; Left to right Logical OR || Left to right Conditional ?: Right to left Assignment = += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |= Right to left Comma , Left to right Try the following example to understand operator’s precedence concept available in C++. Copy and paste the following C++ program in test.cpp file and compile and run this program. Check the simple difference with and without parenthesis. This will produce different results because (), /, * and + have different precedence. Higher precedence operators will be evaluated first: #include using namespace std; main() { int a = 20; C++ 50 int b = 10; int c = 15; int d = 5; int e; e = (a + b) * c / d; // ( 30 * 15 ) / 5 cout &lt;&lt; "Value of (a + b) * c / d is :" &lt;&lt; e &lt;&lt; endl ; e = ((a + b) * c) / d; // (30 * 15 ) / 5 cout &lt;&lt; "Value of ((a + b) * c) / d is :" &lt;&lt; e &lt;&lt; endl ; e = (a + b) * (c / d); // (30) * (15/5) cout &lt;&lt; "Value of (a + b) * (c / d) is :" &lt;&lt; e &lt;&lt; endl ; e = a + (b * c) / d; // 20 + (150/5) cout &lt;&lt; "Value of a + (b * c) / d is :" &lt;&lt; e &lt;&lt; endl ; return 0; } When the above code is compiled and executed, it produces the following result: Value of (a + b) * c / d is :90 Value of ((a + b) * c) / d is :90 Value of (a + b) * (c / d) is :90 Value of a + (b * c) / d is :50 C++ 51 There may be a situation, when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on. Programming languages provide various control structures that allow for more complicated execution paths. A loop statement allows us to execute a statement or group of statements multiple times and following is the general from of a loop statement in most of the programming languages: C++ programming language provides the following type of loops to handle looping requirements. Loop Type Description while loop Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body. for loop Execute a sequence of statements multiple times and abbreviates the code that manages the loop variable. 12. LOOP TYPES C++ 52 do...while loop Like a ‘while’ statement, except that it tests the condition at the end of the loop body. nested loops You can use one or more loop inside any another ‘while’, ‘for’ or ‘do..while’ loop. While Loop A while loop statement repeatedly executes a target statement as long as a given condition is true. Syntax The syntax of a while loop in C++ is: while(condition) { statement(s); } Here, statement(s) may be a single statement or a block of statements. The condition may be any expression, and true is any non-zero value. The loop iterates while the condition is true. When the condition becomes false, program control passes to the line immediately following the loop. Flow Diagram C++ 53 Here, key point of the while loop is that the loop might not ever run. When the condition is tested and the result is false, the loop body will be skipped and the first statement after the while loop will be executed. Example #include using namespace std; int main () { // Local variable declaration: int a = 10; // while loop execution while( a &lt; 20 ) { cout &lt;&lt; "value of a: " &lt;&lt; a &lt;&lt; endl; a++; } C++ 54 return 0; } When the above code is compiled and executed, it produces the following result: value of a: 10 value of a: 11 value of a: 12 value of a: 13 value of a: 14 value of a: 15 value of a: 16 value of a: 17 value of a: 18 value of a: 19 for Loop A for loop is a repetition control structure that allows you to efficiently write a loop that needs to execute a specific number of times. Syntax The syntax of a for loop in C++ is: for ( init; condition; increment ) { statement(s); } Here is the flow of control in a for loop: 1. The init step is executed first, and only once. This step allows you to declare and initialize any loop control variables. You are not required to put a statement here, as long as a semicolon appears. 2. Next, the condition is evaluated. If it is true, the body of the loop is executed. If it is false, the body of the loop does not execute and flow of control jumps to the next statement just after the for loop. 3. After the body of the for loop executes, the flow of control jumps back up to the increment statement. This statement allows you to update any C++ 55 loop control variables. This statement can be left blank, as long as a semicolon appears after the condition. 4. The condition is now evaluated again. If it is true, the loop executes and the process repeats itself (body of loop, then increment step, and then again condition). After the condition becomes false, the for loop terminates. Flow Diagram Example #include using namespace std; int main () { // for loop execution for( int a = 10; a &lt; 20; a = a + 1 ) C++ 56 { cout &lt;&lt; "value of a: " &lt;&lt; a &lt;&lt; endl; } return 0; } When the above code is compiled and executed, it produces the following result: value of a: 10 value of a: 11 value of a: 12 value of a: 13 value of a: 14 value of a: 15 value of a: 16 value of a: 17 value of a: 18 value of a: 19 do…while Loop Unlike for and while loops, which test the loop condition at the top of the loop, the do...while loop checks its condition at the bottom of the loop. A do...while loop is similar to a while loop, except that a do...while loop is guaranteed to execute at least one time. Syntax The syntax of a do...while loop in C++ is: do { statement(s); }while( condition ); Notice that the conditional expression appears at the end of the loop, so the statement(s) in the loop execute once before the condition is tested. C++ 57 If the condition is true, the flow of control jumps back up to do, and the statement(s) in the loop execute again. This process repeats until the given condition becomes false. Flow Diagram Example #include using namespace std; int main () { // Local variable declaration: int a = 10; // do loop execution do { cout &lt;&lt; "value of a: " &lt;&lt; a &lt;&lt; endl; a = a + 1; }while( a &lt; 20 ); return 0; C++ 58 } When the above code is compiled and executed, it produces the following result: value of a: 10 value of a: 11 value of a: 12 value of a: 13 value of a: 14 value of a: 15 value of a: 16 value of a: 17 value of a: 18 value of a: 19 nested Loops A loop can be nested inside of another loop. C++ allows at least 256 levels of nesting. Syntax The syntax for a nested for loop statement in C++ is as follows: for ( init; condition; increment ) { for ( init; condition; increment ) { statement(s); } statement(s); // you can put more statements. } The syntax for a nested while loop statement in C++ is as follows: while(condition) { while(condition) { statement(s); C++ 59 } statement(s); // you can put more statements. } The syntax for a nested do...while loop statement in C++ is as follows: do { statement(s); // you can put more statements. do { statement(s); }while( condition ); }while( condition ); Example The following program uses a nested for loop to find the prime numbers from 2 to 100: #include using namespace std; int main () { int i, j; for(i=2; i&lt;= (i/j); j++) if(!(i%j)) break; // if factor found, not prime if(j &gt; (i/j)) cout &lt;&lt; i &lt;&lt; " is prime\n"; } return 0; } This would produce the following result: C++ 60 2 is prime 3 is prime 5 is prime 7 is prime 11 is prime 13 is prime 17 is prime 19 is prime 23 is prime 29 is prime 31 is prime 37 is prime 41 is prime 43 is prime 47 is prime 53 is prime 59 is prime 61 is prime 67 is prime 71 is prime 73 is prime 79 is prime 83 is prime 89 is prime 97 is prime Loop Control Statements Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed. C++ supports the following control statements. Control Statement Description break statement Terminates the loop or switch statement and transfers execution to the statement immediately C++ 61 following the loop or switch. continue statement Causes the loop to skip the remainder of its body and immediately retest its condition prior to reiterating. goto statement Transfers control to the labeled statement. Though it is not advised to use goto statement in your program. Break Statement The break statement has the following two usages in C++: · When the break statement is encountered inside a loop, the loop is immediately terminated and program control resumes at the next statement following the loop. · It can be used to terminate a case in the switch statement (covered in the next chapter). If you are using nested loops (i.e., one loop inside another loop), the break statement will stop the execution of the innermost loop and start executing the next line of code after the block. Syntax The syntax of a break statement in C++ is: break; Flow Diagram C++ 62 Example #include using namespace std; int main () { // Local variable declaration: int a = 10; // do loop execution do { cout &lt;&lt; "value of a: " &lt;&lt; a &lt;&lt; endl; a = a + 1; if( a &gt; 15) { // terminate the loop break; } }while( a &lt; 20 ); C++ 63 return 0; } When the above code is compiled and executed, it produces the following result: value of a: prettyprint notranslate10 value of a: 11 value of a: 12 value of a: 13 value of a: 14 value of a: 15 continue Statement The continue statement works somewhat like the break statement. Instead of forcing termination, however, continue forces the next iteration of the loop to take place, skipping any code in between. For the for loop, continue causes the conditional test and increment portions of the loop to execute. For the while and do...while loops, program control passes to the conditional tests. Syntax The syntax of a continue statement in C++ is: continue; Flow Diagram C++ 64 Example #include using namespace std; int main () { // Local variable declaration: int a = 10; // do loop execution do { if( a == 15) { // skip the iteration. a = a + 1; continue; } cout &lt;&lt; "value of a: " &lt;&lt; a &lt;&lt; endl; a = a + 1; }while( a &lt; 20 ); C++ 65 return 0; } When the above code is compiled and executed, it produces the following result: value of a: 10 value of a: 11 value of a: 12 value of a: 13 value of a: 14 value of a: 16 value of a: 17 value of a: 18 value of a: 19 goto Statement A goto statement provides an unconditional jump from the goto to a labeled statement in the same function. NOTE: Use of goto statement is highly discouraged because it makes difficult to trace the control flow of a program, making the program hard to understand and hard to modify. Any program that uses a goto can be rewritten so that it doesn't need the goto. Syntax The syntax of a goto statement in C++ is: goto label; .. . label: statement; Where label is an identifier that identifies a labeled statement. A labeled statement is any statement that is preceded by an identifier followed by a colon (:). Flow Diagram C++ 66 Example #include using namespace std; int main () { // Local variable declaration: int a = 10; // do loop execution LOOP:do { if( a == 15) { // skip the iteration. a = a + 1; goto LOOP; } cout &lt;&lt; "value of a: " &lt;&lt; a &lt;&lt; endl; a = a + 1; }while( a &lt; 20 ); C++ 67 return 0; } When the above code is compiled and executed, it produces the following result: value of a: 10 value of a: 11 value of a: 12 value of a: 13 value of a: 14 value of a: 16 value of a: 17 value of a: 18 value of a: 19 One good use of goto is to exit from a deeply nested routine. For example, consider the following code fragment: for(...) { for(...) { while(...) { if(...) goto stop; . . . } } } stop: cout &lt;&lt; "Error in program.\n"; Eliminating the goto would force a number of additional tests to be performed. A simplebreak statement would not work here, because it would only cause the program to exit from the innermost loop. The Infinite Loop A loop becomes infinite loop if a condition never becomes false. The for loop is traditionally used for this purpose. Since none of the three expressions that form C++ 68 the ‘for’ loop are required, you can make an endless loop by leaving the conditional expression empty. #include using namespace std; int main () { for( ; ; ) { printf("This loop will run forever.\n"); } return 0; } When the conditional expression is absent, it is assumed to be true. You may have an initialization and increment expression, but C++ programmers more commonly use the ‘for (;;)’ construct to signify an infinite loop. NOTE: You can terminate an infinite loop by pressing Ctrl + C keys. C++ 69 Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false. Following is the general from of a typical decision making structure found in most of the programming languages: C++ programming language provides following types of decision making statements. Statement Description if statement An ‘if’ statement consists of a boolean expression followed by one or more statements. if...else statement An ‘if’ statement can be followed by an optional ‘else’ statement, which executes when the boolean expression is false. switch statement A ‘switch’ statement allows a variable to be tested 13. DECISION-MAKING STATEMENTS C++ 70 for equality against a list of values. nested if statements You can use one ‘if’ or ‘else if’ statement inside another ‘if’ or ‘else if’ statement(s). nested switch statements You can use one ‘switch’ statement inside another ‘switch’ statement(s). If Statement An if statement consists of a boolean expression followed by one or more statements. Syntax The syntax of an if statement in C++ is: if(boolean_expression) { // statement(s) will execute if the boolean expression is true } If the boolean expression evaluates to true, then the block of code inside the if statement will be executed. If boolean expression evaluates to false, then the first set of code after the end of the if statement (after the closing curly brace) will be executed. Flow Diagram C++ 71 Example #include using namespace std; int main () { // local variable declaration: int a = 10; // check the boolean condition if( a &lt; 20 ) { // if condition is true then print the following cout &lt;&lt; "a is less than 20;" &lt;&lt; endl; } cout &lt;&lt; "value of a is : " &lt;&lt; a &lt;&lt; endl; return 0; } C++ 72 When the above code is compiled and executed, it produces the following result: a is less than 20; value of a is : 10 if…else Statement An if statement can be followed by an optional else statement, which executes when the boolean expression is false. Syntax The syntax of an if...else statement in C++ is: if(boolean_expression) { // statement(s) will execute if the boolean expression is true } else { // statement(s) will execute if the boolean expression is false } If the boolean expression evaluates to true, then the if block of code will be executed, otherwise else block of code will be executed. Flow Diagram C++ 73 Example #include using namespace std; int main () { // local variable declaration: int a = 100; // check the boolean condition if( a &lt; 20 ) { // if condition is true then print the following cout &lt;&lt; "a is less than 20;" &lt;&lt; endl; } else { // if condition is false then print the following cout &lt;&lt; "a is not less than 20;" &lt;&lt; endl; } cout &lt;&lt; "value of a is : " &lt;&lt; a &lt;&lt; endl; return 0; } When the above code is compiled and executed, it produces the following result: a is not less than 20; value of a is : 100 if...else if...else Statement An if statement can be followed by an optional else if...else statement, which is very usefull to test various conditions using single if...else if statement. When using if , else if , else statements there are few points to keep in mind. · An if can have zero or one else's and it must come after any else if's. C++ 74 · An if can have zero to many else if's and they must come before the else. · Once an else if succeeds, none of he remaining else if's or else's will be tested. Syntax The syntax of an if...else if...else statement in C++ is: if(boolean_expression 1) { // Executes when the boolean expression 1 is true } else if( boolean_expression 2) { // Executes when the boolean expression 2 is true } else if( boolean_expression 3) { // Executes when the boolean expression 3 is true } else { // executes when the none of the above condition is true. } Example #include using namespace std; int main () { // local variable declaration: int a = 100; // check the boolean condition if( a == 10 ) C++ 75 { // if condition is true then print the following cout &lt;&lt; "Value of a is 10" &lt;&lt; endl; } else if( a == 20 ) { // if else if condition is true cout &lt;&lt; "Value of a is 20" &lt;&lt; endl; } else if( a == 30 ) { // if else if condition is true cout &lt;&lt; "Value of a is 30" &lt;&lt; endl; } else { // if none of the conditions is true cout &lt;&lt; "Value of a is not matching" &lt;&lt; endl; } cout &lt;&lt; "Exact value of a is : " &lt;&lt; a &lt;&lt; endl; return 0; } When the above code is compiled and executed, it produces the following result: Value of a is not matching Exact value of a is : 100 Switch Statement A switch statement allows a variable to be tested for equality against a list of values. Each value is called a case, and the variable being switched on is checked for each case. Syntax The syntax for a switch statement in C++ is as follows: C++ 76 switch(expression){ case constant-expression : statement(s); break; //optional case constant-expression : statement(s); break; //optional // you can have any number of case statements. default : //Optional statement(s); } The following rules apply to a switch statement: · The expression used in a switch statement must have an integral or enumerated type, or be of a class type in which the class has a single conversion function to an integral or enumerated type. · You can have any number of case statements within a switch. Each case is followed by the value to be compared to and a colon. · The constant-expression for a case must be the same data type as the variable in the switch, and it must be a constant or a literal. · When the variable being switched on is equal to a case, the statements following that case will execute until a break statement is reached. · When a break statement is reached, the switch terminates, and the flow of control jumps to the next line following the switch statement. · Not every case needs to contain a break. If no break appears, the flow of control will fall through to subsequent cases until a break is reached. · A switch statement can have an optional default case, which must appear at the end of the switch. The default case can be used for performing a task when none of the cases is true. No break is needed in the default case. Flow Diagram C++ 77 Example #include using namespace std; int main () { // local variable declaration: char grade = 'D'; switch(grade) { case 'A' : cout &lt;&lt; "Excellent!" &lt;&lt; endl; break; case 'B' : case 'C' : cout &lt;&lt; "Well done" &lt;&lt; endl; break; C++ 78 case 'D' : cout &lt;&lt; "You passed" &lt;&lt; endl; break; case 'F' : cout &lt;&lt; "Better try again" &lt;&lt; endl; break; default : cout &lt;&lt; "Invalid grade" &lt;&lt; endl; } cout &lt;&lt; "Your grade is " &lt;&lt; grade &lt;&lt; endl; return 0; } This would produce the following result: You passed Your grade is D Nested if Statement It is always legal to nest if-else statements, which means you can use one if or else if statement inside another if or else if statement(s). Syntax The syntax for a nested if statement is as follows: if( boolean_expression 1) { // Executes when the boolean expression 1 is true if(boolean_expression 2) { // Executes when the boolean expression 2 is true } } You can nest else if...else in the similar way as you have nested if statement. C++ 79 Example #include using namespace std; int main () { // local variable declaration: int a = 100; int b = 200; // check the boolean condition if( a == 100 ) { // if condition is true then check the following if( b == 200 ) { // if condition is true then print the following cout &lt;&lt; "Value of a is 100 and b is 200" &lt;&lt; endl; } } cout &lt;&lt; "Exact value of a is : " &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "Exact value of b is : " &lt;&lt; b &lt;&lt; endl; return 0; } When the above code is compiled and executed, it produces the following result: Value of a is 100 and b is 200 Exact value of a is : 100 Exact value of b is : 200 Nested switch Statements It is possible to have a switch as part of the statement sequence of an outer switch. Even if the case constants of the inner and outer switch contain common values, no conflicts will arise. C++ 80 C++ specifies that at least 256 levels of nesting be allowed for switch statements. Syntax The syntax for a nested switch statement is as follows: switch(ch1) { case 'A': cout &lt;&lt; "This A is part of outer switch"; switch(ch2) { case 'A': cout &lt;&lt; "This A is part of inner switch"; break; case 'B': // ... } break; case 'B': // ... } Example #include using namespace std; int main () { // local variable declaration: int a = 100; int b = 200; switch(a) { case 100: cout &lt;&lt; "This is part of outer switch" &lt;&lt; endl; switch(b) { case 200: cout &lt;&lt; "This is part of inner switch" &lt;&lt; endl; C++ 81 } } cout &lt;&lt; "Exact value of a is : " &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "Exact value of b is : " &lt;&lt; b &lt;&lt; endl; return 0; } This would produce the following result: This is part of outer switch This is part of inner switch Exact value of a is : 100 Exact value of b is : 200 The ? : Operator We have covered conditional operator “? :” in previous chapter which can be used to replace if...else statements. It has the following general form: Exp1 ? Exp2 : Exp3; Exp1, Exp2, and Exp3 are expressions. Notice the use and placement of the colon. The value of a ‘?’ expression is determined like this: Exp1 is evaluated. If it is true, then Exp2 is evaluated and becomes the value of the entire ‘?’ expression. If Exp1 is false, then Exp3 is evaluated and its value becomes the value of the expression. C++ 82 A function is a group of statements that together perform a task. Every C++ program has at least one function, which is main(), and all the most trivial programs can define additional functions. You can divide up your code into separate functions. How you divide up your code among different functions is up to you, but logically the division usually is such that each function performs a specific task. A function declaration tells the compiler about a function's name, return type, and parameters. A function definition provides the actual body of the function. The C++ standard library provides numerous built-in functions that your program can call. For example, function strcat() to concatenate two strings, function memcpy() to copy one memory location to another location, and many more functions. A function is known with various names like a method or a sub-routine or a procedure etc. Defining a Function The general form of a C++ function definition is as follows: return_type function_name( parameter list ) { body of the function } A C++ function definition consists of a function header and a function body. Here are all the parts of a function: · Return Type: A function may return a value. The return_type is the data type of the value the function returns. Some functions perform the desired operations without returning a value. In this case, the return_type is the keyword void. · Function Name: This is the actual name of the function. The function name and the parameter list together constitute the function signature. · Parameters: A parameter is like a placeholder. When a function is invoked, you pass a value to the parameter. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of the parameters of a function. Parameters are optional; that is, a function may contain no parameters. 14. FUNCTIONS C++ 83 · Function Body: The function body contains a collection of statements that define what the function does. Example: Following is the source code for a function called max(). This function takes two parameters num1 and num2 and returns the maximum between the two: // function returning the max between two numbers int max(int num1, int num2) { // local variable declaration int result; if (num1 &gt; num2) result = num1; else result = num2; return result; } Function Declarations A function declaration tells the compiler about a function name and how to call the function. The actual body of the function can be defined separately. A function declaration has the following parts: return_type function_name( parameter list ); For the above defined function max(), following is the function declaration: int max(int num1, int num2); Parameter names are not important in function declaration only their type is required, so following is also valid declaration: int max(int, int); Function declaration is required when you define a function in one source file and you call that function in another file. In such case, you should declare the function at the top of the file calling the function. C++ 84 Calling a Function While creating a C++ function, you give a definition of what the function has to do. To use a function, you will have to call or invoke that function. When a program calls a function, program control is transferred to the called function. A called function performs defined task and when it’s return statement is executed or when its function-ending closing brace is reached, it returns program control back to the main program. To call a function, you simply need to pass the required parameters along with function name, and if function returns a value, then you can store returned value. For example: #include using namespace std; // function declaration int max(int num1, int num2); int main () { // local variable declaration: int a = 100; int b = 200; int ret; // calling a function to get max value. ret = max(a, b); cout &lt;&lt; "Max value is : " &lt;&lt; ret &lt;&lt; endl; return 0; } // function returning the max between two numbers int max(int num1, int num2) { // local variable declaration C++ 85 int result; if (num1 &gt; num2) result = num1; else result = num2; return result; } I kept max() function along with main() function and compiled the source code. While running final executable, it would produce the following result: Max value is : 200 Function Arguments If a function is to use arguments, it must declare variables that accept the values of the arguments. These variables are called the formal parameters of the function. The formal parameters behave like other local variables inside the function and are created upon entry into the function and destroyed upon exit. While calling a function, there are two ways that arguments can be passed to a function: Call Type Description Call by value This method copies the actual value of an argument into the formal parameter of the function. In this case, changes made to the parameter inside the function have no effect on the argument. Call by pointer This method copies the address of an argument into the formal parameter. Inside the function, the address is used to access the actual argument used in the call. This means that changes made to the parameter affect the argument. Call by reference This method copies the reference of an argument into the formal parameter. Inside the function, the reference is used to access the actual argument used C++ 86 in the call. This means that changes made to the parameter affect the argument. Call by Value The call by value method of passing arguments to a function copies the actual value of an argument into the formal parameter of the function. In this case, changes made to the parameter inside the function have no effect on the argument. By default, C++ uses call by value to pass arguments. In general, this means that code within a function cannot alter the arguments used to call the function. Consider the function swap() definition as follows. // function definition to swap the values. void swap(int x, int y) { int temp; temp = x; /* save the value of x */ x = y; /* put y into x */ y = temp; /* put x into y */ return; } Now, let us call the function swap() by passing actual values as in the following example: #include using namespace std; // function declaration void swap(int x, int y); int main () { // local variable declaration: int a = 100; C++ 87 int b = 200; cout &lt;&lt; "Before swap, value of a :" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "Before swap, value of b :" &lt;&lt; b &lt;&lt; endl; // calling a function to swap the values. swap(a, b); cout &lt;&lt; "After swap, value of a :" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "After swap, value of b :" &lt;&lt; b &lt;&lt; endl; return 0; } When the above code is put together in a file, compiled and executed, it produces the following result: Before swap, value of a :100 Before swap, value of b :200 After swap, value of a :100 After swap, value of b :200 Which shows that there is no change in the values though they had been changed inside the function. Call by Pointer The call by pointer method of passing arguments to a function copies the address of an argument into the formal parameter. Inside the function, the address is used to access the actual argument used in the call. This means that changes made to the parameter affect the passed argument. To pass the value by pointer, argument pointers are passed to the functions just like any other value. So accordingly you need to declare the function parameters as pointer types as in the following function swap(), which exchanges the values of the two integer variables pointed to by its arguments. // function definition to swap the values. void swap(int *x, int *y) { int temp; C++ 88 temp = *x; /* save the value at address x */ *x = *y; /* put y into x */ *y = temp; /* put x into y */ return; } To check the more detail about C++ pointers, kindly check C++ Pointers chapter. For now, let us call the function swap() by passing values by pointer as in the following example: #include using namespace std; // function declaration void swap(int *x, int *y); int main () { // local variable declaration: int a = 100; int b = 200; cout &lt;&lt; "Before swap, value of a :" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "Before swap, value of b :" &lt;&lt; b &lt;&lt; endl; /* calling a function to swap the values. * &amp;a indicates pointer to a ie. address of variable a and * &amp;b indicates pointer to b ie. address of variable b. */ swap(&amp;a, &amp;b); cout &lt;&lt; "After swap, value of a :" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "After swap, value of b :" &lt;&lt; b &lt;&lt; endl; C++ 89 return 0; } When the above code is put together in a file, compiled and executed, it produces the following result: Before swap, value of a :100 Before swap, value of b :200 After swap, value of a :200 After swap, value of b :100 Call by Reference The call by reference method of passing arguments to a function copies the reference of an argument into the formal parameter. Inside the function, the reference is used to access the actual argument used in the call. This means that changes made to the parameter affect the passed argument. To pass the value by reference, argument reference is passed to the functions just like any other value. So accordingly you need to declare the function parameters as reference types as in the following function swap(), which exchanges the values of the two integer variables pointed to by its arguments. // function definition to swap the values. void swap(int &amp;x, int &amp;y) { int temp; temp = x; /* save the value at address x */ x = y; /* put y into x */ y = temp; /* put x into y */ return; } For now, let us call the function swap() by passing values by reference as in the following example: #include using namespace std; // function declaration void swap(int &amp;x, int &amp;y); C++ 90 int main () { // local variable declaration: int a = 100; int b = 200; cout &lt;&lt; "Before swap, value of a :" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "Before swap, value of b :" &lt;&lt; b &lt;&lt; endl; /* calling a function to swap the values using variable reference.*/ swap(a, b); cout &lt;&lt; "After swap, value of a :" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "After swap, value of b :" &lt;&lt; b &lt;&lt; endl; return 0; } When the above code is put together in a file, compiled and executed, it produces the following result: Before swap, value of a :100 Before swap, value of b :200 After swap, value of a :200 After swap, value of b :100 By default, C++ uses call by value to pass arguments. In general, this means that code within a function cannot alter the arguments used to call the function and above mentioned example while calling max() function used the same method. Default Values for Parameters When you define a function, you can specify a default value for each of the last parameters. This value will be used if the corresponding argument is left blank when calling to the function. C++ 91 This is done by using the assignment operator and assigning values for the arguments in the function definition. If a value for that parameter is not passed when the function is called, the default given value is used, but if a value is specified, this default value is ignored and the passed value is used instead. Consider the following example: #include using namespace std; int sum(int a, int b=20) { int result; result = a + b; return (result); } int main () { // local variable declaration: int a = 100; int b = 200; int result; // calling a function to add the values. result = sum(a, b); cout &lt;&lt; "Total value is :" &lt;&lt; result &lt;&lt; endl; // calling a function again as follows. result = sum(a); cout &lt;&lt; "Total value is :" &lt;&lt; result &lt;&lt; endl; return 0; } When the above code is compiled and executed, it produces the following result: C++ 92 Total value is :300 Total value is :120 C++ 93 Normally, when we work with Numbers, we use primitive data types such as int, short, long, float and double, etc. The number data types, their possible values and number ranges have been explained while discussing C++ Data Types. Defining Numbers in C++ You have already defined numbers in various examples given in previous chapters. Here is another consolidated example to define various types of numbers in C++: #include using namespace std; int main () { // number definition: short s; int i; long l; float f; double d; // number assignments; s = 10; i = 1000; l = 1000000; f = 230.47; d = 30949.374; // number printing; cout &lt;&lt; "short s :" &lt;&lt; s &lt;&lt; endl; cout &lt;&lt; "int i :" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "long l :" &lt;&lt; l &lt;&lt; endl; cout &lt;&lt; "float f :" &lt;&lt; f &lt;&lt; endl; 15. NUMBERS C++ 94 cout &lt;&lt; "double d :" &lt;&lt; d &lt;&lt; endl; return 0; } When the above code is compiled and executed, it produces the following result: short s :10 int i :1000 long l :1000000 float f :230.47 double d :30949.4 Math Operations in C++ In addition to the various functions you can create, C++ also includes some useful functions you can use. These functions are available in standard C and C++ libraries and called built-in functions. These are functions that can be included in your program and then use. C++ has a rich set of mathematical operations, which can be performed on various numbers. Following table lists down some useful built-in mathematical functions available in C++. To utilize these functions you need to include the math header file . S.N. Function &amp; Purpose 1 double cos(double); This function takes an angle (as a double) and returns the cosine. 2 double sin(double); This function takes an angle (as a double) and returns the sine. 3 double tan(double); This function takes an angle (as a double) and returns the tangent. 4 double log(double); This function takes a number and returns the natural log of that number. C++ 95 5 double pow(double, double); The first is a number you wish to raise and the second is the power you wish to raise it t 6 double hypot(double, double); If you pass this function the length of two sides of a right triangle, it will return you the length of the hypotenuse. 7 double sqrt(double); You pass this function a number and it gives you the square root. 8 int abs(int); This function returns the absolute value of an integer that is passed to it. 9 double fabs(double); This function returns the absolute value of any decimal number passed to it. 10 double floor(double); Finds the integer which is less than or equal to the argument passed to it. Following is a simple example to show few of the mathematical operations: #include #include using namespace std; int main () { // number definition: short s = 10; int i = -1000; long l = 100000; float f = 230.47; C++ 96 double d = 200.374; // mathematical operations; cout &lt;&lt; "sin(d) :" &lt;&lt; sin(d) &lt;&lt; endl; cout &lt;&lt; "abs(i) :" &lt;&lt; abs(i) &lt;&lt; endl; cout &lt;&lt; "floor(d) :" &lt;&lt; floor(d) &lt;&lt; endl; cout &lt;&lt; "sqrt(f) :" &lt;&lt; sqrt(f) &lt;&lt; endl; cout &lt;&lt; "pow( d, 2) :" &lt;&lt; pow(d, 2) &lt;&lt; endl; return 0; } When the above code is compiled and executed, it produces the following result: sign(d) :-0.634939 abs(i) :1000 floor(d) :200 sqrt(f) :15.1812 pow( d, 2 ) :40149.7 Random Numbers in C++ There are many cases where you will wish to generate a random number. There are actually two functions you will need to know about random number generation. The first is rand(), this function will only return a pseudo random number. The way to fix this is to first call the srand() function. Following is a simple example to generate few random numbers. This example makes use of time() function to get the number of seconds on your system time, to randomly seed the rand() function: #include #include #include using namespace std; int main () { int i,j; C++ 97 // set the seed srand( (unsigned)time( NULL ) ); /* generate 10 random numbers. */ for( i = 0; i &lt; 10; i++ ) { // generate actual random number j= rand(); cout &lt;&lt;" Random Number : " &lt;&lt; j &lt;&lt; endl; } return 0; } When the above code is compiled and executed, it produces the following result: Random Number : 1748144778 Random Number : 630873888 Random Number : 2134540646 Random Number : 219404170 Random Number : 902129458 Random Number : 920445370 Random Number : 1319072661 Random Number : 257938873 Random Number : 1256201101 Random Number : 580322989 C++ 98 C++ provides a data structure, the array, which stores a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type. Instead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables. A specific element in an array is accessed by an index. All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element. Declaring Arrays To declare an array in C++, the programmer specifies the type of the elements and the number of elements required by an array as follows: type arrayName [ arraySize ]; This is called a single-dimension array. The arraySize must be an integer constant greater than zero and type can be any valid C++ data type. For example, to declare a 10-element array called balance of type double, use this statement: double balance[10]; Initializing Arrays You can initialize C++ array elements either one by one or using a single statement as follows: double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0}; The number of values between braces { } cannot be larger than the number of elements that we declare for the array between square brackets [ ]. Following is an example to assign a single element of the array: If you omit the size of the array, an array just big enough to hold the initialization is created. Therefore, if you write: double balance[] = {1000.0, 2.0, 3.4, 17.0, 50.0}; You will create exactly the same array as you did in the previous example. 16. ARRAYS C++ 99 balance[4] = 50.0; The above statement assigns element number 5th in the array a value of 50.0. Array with 4th index will be 5th, i.e., last element because all arrays have 0 as the index of their first element which is also called base index. Following is the pictorial representation of the same array we discussed above: Accessing Array Elements An element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example: double salary = balance[9]; The above statement will take 10th element from the array and assign the value to salary variable. Following is an example, which will use all the abovementioned three concepts viz. declaration, assignment and accessing arrays: #include using namespace std; #include using std::setw; int main () { int n[ 10 ]; // n is an array of 10 integers // initialize elements of array n to 0 for ( int i = 0; i &lt; 10; i++ ) { n[ i ] = i + 100; // set element at location i to i + 100 } cout &lt;&lt; "Element" &lt;&lt; setw( 13 ) &lt;&lt; "Value" &lt;&lt; endl; // output each array element's value C++ 100 for ( int j = 0; j &lt; 10; j++ ) { cout &lt;&lt; setw( 7 )&lt;&lt; j &lt;&lt; setw( 13 ) &lt;&lt; n[ j ] &lt;&lt; endl; } return 0; } This program makes use of setw() function to format the output. When the above code is compiled and executed, it produces the following result: Element Value 0 100 1 101 2 102 3 103 4 104 5 105 6 106 7 107 8 108 9 109 Arrays in C++ Arrays are important to C++ and should need lots of more detail. There are following few important concepts, which should be clear to a C++ programmer: Concept Description Multi-dimensional arrays C++ supports multidimensional arrays. The simplest form of the multidimensional array is the two-dimensional array. Pointer to an array You can generate a pointer to the first element of an array by simply specifying the array name, without any index. Passing arrays to functions You can pass to the function a pointer to an C++ 101 array by specifying the array's name without an index. Return array from functions C++ allows a function to return an array. Multi-dimensional Arrays C++ allows multidimensional arrays. Here is the general form of a multidimensional array declaration: type name[size1][size2]...[sizeN]; For example, the following declaration creates a three dimensional 5 . 10 . 4 integer array: int threedim[5][10][4]; Two-Dimensional Arrays The simplest form of the multidimensional array is the two-dimensional array. A two-dimensional array is, in essence, a list of one-dimensional arrays. To declare a two-dimensional integer array of size x,y, you would write something as follows: type arrayName [ x ][ y ]; Where type can be any valid C++ data type and arrayName will be a valid C++ identifier. A two-dimensional array can be think as a table, which will have x number of rows and y number of columns. A 2-dimensional array a, which contains three rows and four columns can be shown as below: Thus, every element in array a is identified by an element name of the form a[ i ][ j ], where a is the name of the array, and i and j are the subscripts that uniquely identify each element in a. Initializing Two-Dimensional Arrays C++ 102 Multidimensioned arrays may be initialized by specifying bracketed values for each row. Following is an array with 3 rows and each row have 4 columns. int a[3][4] = { {0, 1, 2, 3} , /* initializers for row indexed by 0 */ {4, 5, 6, 7} , /* initializers for row indexed by 1 */ {8, 9, 10, 11} /* initializers for row indexed by 2 */ }; The nested braces, which indicate the intended row, are optional. The following initialization is equivalent to previous example: int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11}; Accessing Two-Dimensional Array Elements An element in 2-dimensional array is accessed by using the subscripts, i.e., row index and column index of the array. For example: int val = a[2][3]; The above statement will take 4th element from the 3rd row of the array. You can verify it in the above digram. #include using namespace std; int main () { // an array with 5 rows and 2 columns. int a[5][2] = { {0,0}, {1,2}, {2,4}, {3,6},{4,8}}; // output each array element's value for ( int i = 0; i &lt; 5; i++ ) for ( int j = 0; j &lt; 2; j++ ) { cout &lt;&lt; "a[" &lt;&lt; i &lt;&lt; "][" &lt;&lt; j &lt;&lt; "]: "; cout &lt;&lt; a[i][j]&lt;&lt; endl; } C++ 103 return 0; } When the above code is compiled and executed, it produces the following result: a[0][0]: 0 a[0][1]: 0 a[1][0]: 1 a[1][1]: 2 a[2][0]: 2 a[2][1]: 4 a[3][0]: 3 a[3][1]: 6 a[4][0]: 4 a[4][1]: 8 As explained above, you can have arrays with any number of dimensions, although it is likely that most of the arrays you create will be of one or two dimensions. Pointer to an Array It is most likely that you would not understand this chapter until you go through the chapter related C++ Pointers. So assuming you have bit understanding on pointers in C++, let us start: An array name is a constant pointer to the first element of the array. Therefore, in the declaration: double balance[50]; balance is a pointer to &amp;balance[0], which is the address of the first element of the array balance. Thus, the following program fragment assigns p the address of the first element ofbalance: double *p; double balance[10]; p = balance; It is legal to use array names as constant pointers, and vice versa. Therefore, *(balance + 4) is a legitimate way of accessing the data at balance[4]. C++ 104 Once you store the address of first element in p, you can access array elements using *p, *(p+1), *(p+2) and so on. Below is the example to show all the concepts discussed above: #include using namespace std; int main () { // an array with 5 elements. double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0}; double *p; p = balance; // output each array element's value cout &lt;&lt; "Array values using pointer " &lt;&lt; endl; for ( int i = 0; i &lt; 5; i++ ) { cout &lt;&lt; "*(p + " &lt;&lt; i &lt;&lt; ") : "; cout &lt;&lt; *(p + i) &lt;&lt; endl; } cout &lt;&lt; "Array values using balance as address " &lt;&lt; endl; for ( int i = 0; i &lt; 5; i++ ) { cout &lt;&lt; "*(balance + " &lt;&lt; i &lt;&lt; ") : "; cout &lt;&lt; *(balance + i) &lt;&lt; endl; } return 0; } When the above code is compiled and executed, it produces the following result: Array values using pointer *(p + 0) : 1000 C++ 105 *(p + 1) : 2 *(p + 2) : 3.4 *(p + 3) : 17 *(p + 4) : 50 Array values using balance as address *(balance + 0) : 1000 *(balance + 1) : 2 *(balance + 2) : 3.4 *(balance + 3) : 17 *(balance + 4) : 50 In the above example, p is a pointer to double which means it can store address of a variable of double type. Once we have address in p, then *p will give us value available at the address stored in p, as we have shown in the above example. Passing Arrays to Functions C++ does not allow to pass an entire array as an argument to a function. However, You can pass a pointer to an array by specifying the array's name without an index. If you want to pass a single-dimension array as an argument in a function, you would have to declare function formal parameter in one of following three ways and all three declaration methods produce similar results because each tells the compiler that an integer pointer is going to be received. Way-1 Formal parameters as a pointer as follows: void myFunction(int *param) { . . . } Way-2 Formal parameters as a sized array as follows: void myFunction(int param[10]) C++ 106 { . . . } Way-3 Formal parameters as an unsized array as follows: void myFunction(int param[]) { . . . } Now, consider the following function, which will take an array as an argument along with another argument and based on the passed arguments, it will return average of the numbers passed through the array as follows: double getAverage(int arr[], int size) { int i, sum = 0; double avg; for (i = 0; i &lt; size; ++i) { sum += arr[i]; } avg = double(sum) / size; return avg; } Now, let us call the above function as follows: #include C++ 107 using namespace std; // function declaration: double getAverage(int arr[], int size); int main () { // an int array with 5 elements. int balance[5] = {1000, 2, 3, 17, 50}; double avg; // pass pointer to the array as an argument. avg = getAverage( balance, 5 ) ; // output the returned value cout &lt;&lt; "Average value is: " &lt;&lt; avg &lt;&lt; endl; return 0; } When the above code is compiled together and executed, it produces the following result: Average value is: 214.4 As you can see, the length of the array doesn't matter as far as the function is concerned because C++ performs no bounds checking for the formal parameters. Return Array from Functions C++ does not allow to return an entire array as an argument to a function. However, you can return a pointer to an array by specifying the array's name without an index. If you want to return a single-dimension array from a function, you would have to declare a function returning a pointer as in the following example: int * myFunction() { . C++ 108 . . } Second point to remember is that C++ does not advocate to return the address of a local variable to outside of the function so you would have to define the local variable as staticvariable. Now, consider the following function, which will generate 10 random numbers and return them using an array and call this function as follows: #include #include using namespace std; // function to generate and retrun random numbers. int * getRandom( ) { static int r[10]; // set the seed srand( (unsigned)time( NULL ) ); for (int i = 0; i &lt; 10; ++i) { r[i] = rand(); cout &lt;&lt; r[i] &lt;&lt; endl; } return r; } // main function to call above defined function. int main () { // a pointer to an int. int *p; C++ 109 p = getRandom(); for ( int i = 0; i &lt; 10; i++ ) { cout &lt;&lt; "*(p + " &lt;&lt; i &lt;&lt; ") : "; cout &lt;&lt; *(p + i) &lt;&lt; endl; } return 0; } When the above code is compiled together and executed, it produces result something as follows: 624723190 1468735695 807113585 976495677 613357504 1377296355 1530315259 1778906708 1820354158 667126415 *(p + 0) : 624723190 *(p + 1) : 1468735695 *(p + 2) : 807113585 *(p + 3) : 976495677 *(p + 4) : 613357504 *(p + 5) : 1377296355 *(p + 6) : 1530315259 *(p + 7) : 1778906708 *(p + 8) : 1820354158 *(p + 9) : 667126415 C++ 110 C++ 111 C++ provides following two types of string representations: · The C-style character string. · The string class type introduced with Standard C++. The C-Style Character String The C-style character string originated within the C language and continues to be supported within C++. This string is actually a one-dimensional array of characters which is terminated by a null character '\0'. Thus a null-terminated string contains the characters that comprise the string followed by a null. The following declaration and initialization create a string consisting of the word "Hello". To hold the null character at the end of the array, the size of the character array containing the string is one more than the number of characters in the word "Hello." char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'}; If you follow the rule of array initialization, then you can write the above statement as follows: char greeting[] = "Hello"; Following is the memory presentation of above defined string in C/C++: Actually, you do not place the null character at the end of a string constant. The C++ compiler automatically places the '\0' at the end of the string when it initializes the array. Let us try to print above-mentioned string: #include using namespace std; 17. STRINGS C++ 112 int main () { char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'}; cout &lt;&lt; "Greeting message: "; cout &lt;&lt; greeting &lt;&lt; endl; return 0; } When the above code is compiled and executed, it produces the following result: Greeting message: Hello C++ supports a wide range of functions that manipulate null-terminated strings: S.N. Function &amp; Purpose 1 strcpy(s1, s2); Copies string s2 into string s1. 2 strcat(s1, s2); Concatenates string s2 onto the end of string s1. 3 strlen(s1); Returns the length of string s1. 4 strcmp(s1, s2); Returns 0 if s1 and s2 are the same; less than 0 if s1s2. 5 strchr(s1, ch); Returns a pointer to the first occurrence of character ch in string s1. 6 strstr(s1, s2); C++ 113 Returns a pointer to the first occurrence of string s2 in string s1. Following example makes use of few of the above-mentioned functions: #include #include using namespace std; int main () { char str1[10] = "Hello"; char str2[10] = "World"; char str3[10]; int len ; // copy str1 into str3 strcpy( str3, str1); cout &lt;&lt; "strcpy( str3, str1) : " &lt;&lt; str3 &lt;&lt; endl; // concatenates str1 and str2 strcat( str1, str2); cout &lt;&lt; "strcat( str1, str2): " &lt;&lt; str1 &lt;&lt; endl; // total lenghth of str1 after concatenation len = strlen(str1); cout &lt;&lt; "strlen(str1) : " &lt;&lt; len &lt;&lt; endl; return 0; } When the above code is compiled and executed, it produces result something as follows: strcpy( str3, str1) : Hello C++ 114 strcat( str1, str2): HelloWorld strlen(str1) : 10 The String Class in C++ The standard C++ library provides a string class type that supports all the operations mentioned above, additionally much more functionality. Let us check the following example: #include #include using namespace std; int main () { string str1 = "Hello"; string str2 = "World"; string str3; int len ; // copy str1 into str3 str3 = str1; cout &lt;&lt; "str3 : " &lt;&lt; str3 &lt;&lt; endl; // concatenates str1 and str2 str3 = str1 + str2; cout &lt;&lt; "str1 + str2 : " &lt;&lt; str3 &lt;&lt; endl; // total length of str3 after concatenation len = str3.size(); cout &lt;&lt; "str3.size() : " &lt;&lt; len &lt;&lt; endl; return 0; } When the above code is compiled and executed, it produces result something as follows: C++ 115 str3 : Hello str1 + str2 : HelloWorld str3.size() : 10 C++ 116 C++ pointers are easy and fun to learn. Some C++ tasks are performed more easily with pointers, and other C++ tasks, such as dynamic memory allocation, cannot be performed without them. As you know every variable is a memory location and every memory location has its address defined which can be accessed using ampersand (&amp;) operator which denotes an address in memory. Consider the following which will print the address of the variables defined: #include using namespace std; int main () { int var1; char var2[10]; cout &lt;&lt; "Address of var1 variable: "; cout &lt;&lt; &amp;var1 &lt;&lt; endl; cout &lt;&lt; "Address of var2 variable: "; cout &lt;&lt; &amp;var2 &lt;&lt; endl; return 0; } When the above code is compiled and executed, it produces the following result: Address of var1 variable: 0xbfebd5c0 Address of var2 variable: 0xbfebd5b6 What are Pointers? A pointer is a variable whose value is the address of another variable. Like any variable or constant, you must declare a pointer before you can work with it. The general form of a pointer variable declaration is: 18. POINTERS C++ 117 type *var-name; Here, type is the pointer's base type; it must be a valid C++ type and varname is the name of the pointer variable. The asterisk you used to declare a pointer is the same asterisk that you use for multiplication. However, in this statement the asterisk is being used to designate a variable as a pointer. Following are the valid pointer declaration: int *ip; // pointer to an integer double *dp; // pointer to a double float *fp; // pointer to a float char *ch // pointer to character The actual data type of the value of all pointers, whether integer, float, character, or otherwise, is the same, a long hexadecimal number that represents a memory address. The only difference between pointers of different data types is the data type of the variable or constant that the pointer points to. Using Pointers in C++ There are few important operations, which we will do with the pointers very frequently. (a) We define a pointer variable. (b) Assign the address of a variable to a pointer. (c) Finally access the value at the address available in the pointer variable. This is done by using unary operator * that returns the value of the variable located at the address specified by its operand. Following example makes use of these operations: #include using namespace std; int main () { int var = 20; // actual variable declaration. int *ip; // pointer variable ip = &amp;var; // store address of var in pointer variable cout &lt;&lt; "Value of var variable: "; cout &lt;&lt; var &lt;&lt; endl; C++ 118 // print the address stored in ip pointer variable cout &lt;&lt; "Address stored in ip variable: "; cout &lt;&lt; ip &lt;&lt; endl; // access the value at the address available in pointer cout &lt;&lt; "Value of *ip variable: "; cout &lt;&lt; *ip &lt;&lt; endl; return 0; } When the above code is compiled and executed, it produces result something as follows: Value of var variable: 20 Address stored in ip variable: 0xbfc601ac Value of *ip variable: 20 Pointers in C++ Pointers have many but easy concepts and they are very important to C++ programming. There are following few important pointer concepts which should be clear to a C++ programmer: Concept Description C++ Null Pointers C++ supports null pointer, which is a constant with a value of zero defined in several standard libraries. C++ pointer arithmetic There are four arithmetic operators that can be used on pointers: ++, --, +, - C++ pointers vs arrays There is a close relationship between pointers and arrays. C++ array of pointers You can define arrays to hold a number of pointers. C++ pointer to pointer C++ allows you to have pointer on a pointer C++ 119 and so on. Passing pointers to functions Passing an argument by reference or by address both enable the passed argument to be changed in the calling function by the called function. Return pointer from functions C++ allows a function to return a pointer to local variable, static variable and dynamically allocated memory as well. Null Pointers It is always a good practice to assign the pointer NULL to a pointer variable in case you do not have exact address to be assigned. This is done at the time of variable declaration. A pointer that is assigned NULL is called a null pointer. The NULL pointer is a constant with a value of zero defined in several standard libraries, including iostream. Consider the following program: #include using namespace std; int main () { int *ptr = NULL; cout &lt;&lt; "The value of ptr is " &lt;&lt; ptr ; return 0; } When the above code is compiled and executed, it produces the following result: The value of ptr is 0 On most of the operating systems, programs are not permitted to access memory at address 0 because that memory is reserved by the operating system. However, the memory address 0 has special significance; it signals that the pointer is not intended to point to an accessible memory location. But by C++ 120 convention, if a pointer contains the null (zero) value, it is assumed to point to nothing. To check for a null pointer you can use an if statement as follows: if(ptr) // succeeds if p is not null if(!ptr) // succeeds if p is null Thus, if all unused pointers are given the null value and you avoid the use of a null pointer, you can avoid the accidental misuse of an uninitialized pointer. Many times, uninitialized variables hold some junk values and it becomes difficult to debug the program. Pointer Arithmetic As you understood pointer is an address which is a numeric value; therefore, you can perform arithmetic operations on a pointer just as you can a numeric value. There are four arithmetic operators that can be used on pointers: ++, --, +, and - To understand pointer arithmetic, let us consider that ptr is an integer pointer which points to the address 1000. Assuming 32-bit integers, let us perform the following arithmatic operation on the pointer: ptr++ the ptr will point to the location 1004 because each time ptr is incremented, it will point to the next integer. This operation will move the pointer to next memory location without impacting actual value at the memory location. If ptr points to a character whose address is 1000, then above operation will point to the location 1001 because next character will be available at 1001. Incrementing a Pointer We prefer using a pointer in our program instead of an array because the variable pointer can be incremented, unlike the array name which cannot be incremented because it is a constant pointer. The following program increments the variable pointer to access each succeeding element of the array: #include using namespace std; const int MAX = 3; int main () { int var[MAX] = {10, 100, 200}; C++ 121 int *ptr; // let us have array address in pointer. ptr = var; for (int i = 0; i &lt; MAX; i++) { cout &lt;&lt; "Address of var[" &lt;&lt; i &lt;&lt; "] = "; cout &lt;&lt; ptr &lt;&lt; endl; cout &lt;&lt; "Value of var[" &lt;&lt; i &lt;&lt; "] = "; cout &lt;&lt; *ptr &lt;&lt; endl; // point to the next location ptr++; } return 0; } When the above code is compiled and executed, it produces result something as follows: Address of var[0] = 0xbfa088b0 Value of var[0] = 10 Address of var[1] = 0xbfa088b4 Value of var[1] = 100 Address of var[2] = 0xbfa088b8 Value of var[2] = 200 Decrementing a Pointer The same considerations apply to decrementing a pointer, which decreases its value by the number of bytes of its data type as shown below: #include using namespace std; const int MAX = 3; C++ 122 int main () { int var[MAX] = {10, 100, 200}; int *ptr; // let us have address of the last element in pointer. ptr = &amp;var[MAX-1]; for (int i = MAX; i &gt; 0; i--) { cout &lt;&lt; "Address of var[" &lt;&lt; i &lt;&lt; "] = "; cout &lt;&lt; ptr &lt;&lt; endl; cout &lt;&lt; "Value of var[" &lt;&lt; i &lt;&lt; "] = "; cout &lt;&lt; *ptr &lt;&lt; endl; // point to the previous location ptr--; } return 0; } When the above code is compiled and executed, it produces result something as follows: Address of var[3] = 0xbfdb70f8 Value of var[3] = 200 Address of var[2] = 0xbfdb70f4 Value of var[2] = 100 Address of var[1] = 0xbfdb70f0 Value of var[1] = 10 Pointer Comparisons Pointers may be compared by using relational operators, such as ==, . If p1 and p2 point to variables that are related to each other, such as elements of the same array, then p1 and p2 can be meaningfully compared. C++ 123 The following program modifies the previous example one by incrementing the variable pointer so long as the address to which it points is either less than or equal to the address of the last element of the array, which is &amp;var[MAX - 1]: #include using namespace std; const int MAX = 3; int main () { int var[MAX] = {10, 100, 200}; int *ptr; // let us have address of the first element in pointer. ptr = var; int i = 0; while ( ptr &lt;= &amp;var[MAX - 1] ) { cout &lt;&lt; "Address of var[" &lt;&lt; i &lt;&lt; "] = "; cout &lt;&lt; ptr &lt;&lt; endl; cout &lt;&lt; "Value of var[" &lt;&lt; i &lt;&lt; "] = "; cout &lt;&lt; *ptr &lt;&lt; endl; // point to the previous location ptr++; i++; } return 0; } When the above code is compiled and executed, it produces result something as follows: Address of var[0] = 0xbfce42d0 Value of var[0] = 10 C++ 124 Address of var[1] = 0xbfce42d4 Value of var[1] = 100 Address of var[2] = 0xbfce42d8 Value of var[2] = 200 Pointers vs Arrays Pointers and arrays are strongly related. In fact, pointers and arrays are interchangeable in many cases. For example, a pointer that points to the beginning of an array can access that array by using either pointer arithmetic or array-style indexing. Consider the following program: #include using namespace std; const int MAX = 3; int main () { int var[MAX] = {10, 100, 200}; int *ptr; // let us have array address in pointer. ptr = var; for (int i = 0; i &lt; MAX; i++) { cout &lt;&lt; "Address of var[" &lt;&lt; i &lt;&lt; "] = "; cout &lt;&lt; ptr &lt;&lt; endl; cout &lt;&lt; "Value of var[" &lt;&lt; i &lt;&lt; "] = "; cout &lt;&lt; *ptr &lt;&lt; endl; // point to the next location ptr++; } return 0; } C++ 125 When the above code is compiled and executed, it produces result something as follows: Address of var[0] = 0xbfa088b0 Value of var[0] = 10 Address of var[1] = 0xbfa088b4 Value of var[1] = 100 Address of var[2] = 0xbfa088b8 Value of var[2] = 200 However, pointers and arrays are not completely interchangeable. For example, consider the following program: #include using namespace std; const int MAX = 3; int main () { int var[MAX] = {10, 100, 200}; for (int i = 0; i &lt; MAX; i++) { *var = i; // This is a correct syntax var++; // This is incorrect. } return 0; } It is perfectly acceptable to apply the pointer operator * to var but it is illegal to modify var value. The reason for this is that var is a constant that points to the beginning of an array and can not be used as l-value. Because an array name generates a pointer constant, it can still be used in pointer-style expressions, as long as it is not modified. For example, the following is a valid statement that assigns var[2] the value 500: *(var + 2) = 500; C++ 126 Above statement is valid and will compile successfully because var is not changed. Array of Pointers Before we understand the concept of array of pointers, let us consider the following example, which makes use of an array of 3 integers: #include using namespace std; const int MAX = 3; int main () { int var[MAX] = {10, 100, 200}; for (int i = 0; i &lt; MAX; i++) { cout &lt;&lt; "Value of var[" &lt;&lt; i &lt;&lt; "] = "; cout &lt;&lt; var[i] &lt;&lt; endl; } return 0; } When the above code is compiled and executed, it produces the following result: Value of var[0] = 10 Value of var[1] = 100 Value of var[2] = 200 There may be a situation, when we want to maintain an array, which can store pointers to an int or char or any other data type available. Following is the declaration of an array of pointers to an integer: int *ptr[MAX]; This declares ptr as an array of MAX integer pointers. Thus, each element in ptr, now holds a pointer to an int value. Following example makes use of three integers which will be stored in an array of pointers as follows: #include C++ 127 using namespace std; const int MAX = 3; int main () { int var[MAX] = {10, 100, 200}; int *ptr[MAX]; for (int i = 0; i &lt; MAX; i++) { ptr[i] = &amp;var[i]; // assign the address of integer. } for (int i = 0; i &lt; MAX; i++) { cout &lt;&lt; "Value of var[" &lt;&lt; i &lt;&lt; "] = "; cout &lt;&lt; *ptr[i] &lt;&lt; endl; } return 0; } When the above code is compiled and executed, it produces the following result: Value of var[0] = 10 Value of var[1] = 100 Value of var[2] = 200 You can also use an array of pointers to character to store a list of strings as follows: #include using namespace std; const int MAX = 4; int main () { C++ 128 char *names[MAX] = { "Zara Ali", "Hina Ali", "Nuha Ali", "Sara Ali", }; for (int i = 0; i &lt; MAX; i++) { cout &lt;&lt; "Value of names[" &lt;&lt; i &lt;&lt; "] = "; cout &lt;&lt; names[i] &lt;&lt; endl; } return 0; } When the above code is compiled and executed, it produces the following result: Value of names[0] = Zara Ali Value of names[1] = Hina Ali Value of names[2] = Nuha Ali Value of names[3] = Sara Ali Pointer to a Pointer A pointer to a pointer is a form of multiple indirection or a chain of pointers. Normally, a pointer contains the address of a variable. When we define a pointer to a pointer, the first pointer contains the address of the second pointer, which points to the location that contains the actual value as shown below. A variable that is a pointer to a pointer must be declared as such. This is done by placing an additional asterisk in front of its name. For example, following is the declaration to declare a pointer to a pointer of type int: int **var; C++ 129 When a target value is indirectly pointed to by a pointer to a pointer, accessing that value requires that the asterisk operator be applied twice, as is shown below in the example: #include using namespace std; int main () { int var; int *ptr; int **pptr; var = 3000; // take the address of var ptr = &amp;var; // take the address of ptr using address of operator &amp; pptr = &amp;ptr; // take the value using pptr cout &lt;&lt; "Value of var :" &lt;&lt; var &lt;&lt; endl; cout &lt;&lt; "Value available at *ptr :" &lt;&lt; *ptr &lt;&lt; endl; cout &lt;&lt; "Value available at **pptr :" &lt;&lt; **pptr &lt;&lt; endl; return 0; } When the above code is compiled and executed, it produces the following result: Value of var :3000 Value available at *ptr :3000 Value available at **pptr :3000 C++ 130 Passing Pointers to Functions C++ allows you to pass a pointer to a function. To do so, simply declare the function parameter as a pointer type. Following a simple example where we pass an unsigned long pointer to a function and change the value inside the function which reflects back in the calling function: #include #include using namespace std; void getSeconds(unsigned long *par); int main () { unsigned long sec; getSeconds( &amp;sec ); // print the actual value cout &lt;&lt; "Number of seconds :" &lt;&lt; sec &lt;&lt; endl; return 0; } void getSeconds(unsigned long *par) { // get the current number of seconds *par = time( NULL ); return; } When the above code is compiled and executed, it produces the following result: Number of seconds :1294450468 C++ 131 The function which can accept a pointer, can also accept an array as shown in the following example: #include using namespace std; // function declaration: double getAverage(int *arr, int size); int main () { // an int array with 5 elements. int balance[5] = {1000, 2, 3, 17, 50}; double avg; // pass pointer to the array as an argument. avg = getAverage( balance, 5 ) ; // output the returned value cout &lt;&lt; "Average value is: " &lt;&lt; avg &lt;&lt; endl; return 0; } double getAverage(int *arr, int size) { int i, sum = 0; double avg; for (i = 0; i &lt; size; ++i) { sum += arr[i]; } avg = double(sum) / size; C++ 132 return avg; } When the above code is compiled together and executed, it produces the following result: Average value is: 214.4 Return Pointer from Functions As we have seen in last chapter how C++ allows to return an array from a function, similar way C++ allows you to return a pointer from a function. To do so, you would have to declare a function returning a pointer as in the following example: int * myFunction() { . . . } Second point to remember is that, it is not good idea to return the address of a local variable to outside of the function, so you would have to define the local variable as staticvariable. Now, consider the following function, which will generate 10 random numbers and return them using an array name which represents a pointer i.e., address of first array element. #include #include using namespace std; // function to generate and retrun random numbers. int * getRandom( ) { static int r[10]; C++ 133 // set the seed srand( (unsigned)time( NULL ) ); for (int i = 0; i &lt; 10; ++i) { r[i] = rand(); cout &lt;&lt; r[i] &lt;&lt; endl; } return r; } // main function to call above defined function. int main () { // a pointer to an int. int *p; p = getRandom(); for ( int i = 0; i &lt; 10; i++ ) { cout &lt;&lt; "*(p + " &lt;&lt; i &lt;&lt; ") : "; cout &lt;&lt; *(p + i) &lt;&lt; endl; } return 0; } When the above code is compiled together and executed, it produces result something as follows: 624723190 1468735695 807113585 976495677 C++ 134 613357504 1377296355 1530315259 1778906708 1820354158 667126415 *(p + 0) : 624723190 *(p + 1) : 1468735695 *(p + 2) : 807113585 *(p + 3) : 976495677 *(p + 4) : 613357504 *(p + 5) : 1377296355 *(p + 6) : 1530315259 *(p + 7) : 1778906708 *(p + 8) : 1820354158 *(p + 9) : 667126415 C++ 135 A reference variable is an alias, that is, another name for an already existing variable. Once a reference is initialized with a variable, either the variable name or the reference name may be used to refer to the variable. References vs Pointers References are often confused with pointers but three major differences between references and pointers are: · You cannot have NULL references. You must always be able to assume that a reference is connected to a legitimate piece of storage. · Once a reference is initialized to an object, it cannot be changed to refer to another object. Pointers can be pointed to another object at any time. · A reference must be initialized when it is created. Pointers can be initialized at any time. Creating References in C++ Think of a variable name as a label attached to the variable's location in memory. You can then think of a reference as a second label attached to that memory location. Therefore, you can access the contents of the variable through either the original variable name or the reference. For example, suppose we have the following example: int i = 17; We can declare reference variables for i as follows. int&amp; r = i; Read the &amp; in these declarations as reference. Thus, read the first declaration as "r is an integer reference initialized to i" and read the second declaration as "s is a double reference initialized to d." Following example makes use of references on int and double: #include using namespace std; int main () { 19. REFERENCES C++ 136 // declare simple variables int i; double d; // declare reference variables int&amp; r = i; double&amp; s = d; i = 5; cout &lt;&lt; "Value of i : " &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "Value of i reference : " &lt;&lt; r &lt;&lt; endl; d = 11.7; cout &lt;&lt; "Value of d : " &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; "Value of d reference : " &lt;&lt; s &lt;&lt; endl; return 0; } When the above code is compiled together and executed, it produces the following result: Value of i : 5 Value of i reference : 5 Value of d : 11.7 Value of d reference : 11.7 References are usually used for function argument lists and function return values. So following are two important subjects related to C++ references which should be clear to a C++ programmer: Concept Description References as parameters C++ supports passing references as function parameter more safely than parameters. Reference as return value You can return reference from a C++ function C++ 137 like any other data type. References as Parameters We have discussed how we implement call by reference concept using pointers. Here is another example of call by reference which makes use of C++ reference: #include using namespace std; // function declaration void swap(int&amp; x, int&amp; y); int main () { // local variable declaration: int a = 100; int b = 200; cout &lt;&lt; "Before swap, value of a :" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "Before swap, value of b :" &lt;&lt; b &lt;&lt; endl; /* calling a function to swap the values.*/ swap(a, b); cout &lt;&lt; "After swap, value of a :" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "After swap, value of b :" &lt;&lt; b &lt;&lt; endl; return 0; } // function definition to swap the values. void swap(int&amp; x, int&amp; y) { C++ 138 int temp; temp = x; /* save the value at address x */ x = y; /* put y into x */ y = temp; /* put x into y */ return; } When the above code is compiled and executed, it produces the following result: Before swap, value of a :100 Before swap, value of b :200 After swap, value of a :200 After swap, value of b :100 Reference as Return Value A C++ program can be made easier to read and maintain by using references rather than pointers. A C++ function can return a reference in a similar way as it returns a pointer. When a function returns a reference, it returns an implicit pointer to its return value. This way, a function can be used on the left side of an assignment statement. For example, consider this simple program: #include #include using namespace std; double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0}; double&amp; setValues( int i ) { return vals[i]; // return a reference to the ith element } // main function to call above defined function. int main () C++ 139 { cout &lt;&lt; "Value before change" &lt;&lt; endl; for ( int i = 0; i &lt; 5; i++ ) { cout &lt;&lt; "vals[" &lt;&lt; i &lt;&lt; "] = "; cout &lt;&lt; vals[i] &lt;&lt; endl; } setValues(1) = 20.23; // change 2nd element setValues(3) = 70.8; // change 4th element cout &lt;&lt; "Value after change" &lt;&lt; endl; for ( int i = 0; i &lt; 5; i++ ) { cout &lt;&lt; "vals[" &lt;&lt; i &lt;&lt; "] = "; cout &lt;&lt; vals[i] &lt;&lt; endl; } return 0; } When the above code is compiled together and executed, it produces the following result: Value before change vals[0] = 10.1 vals[1] = 12.6 vals[2] = 33.1 vals[3] = 24.1 vals[4] = 50 Value after change vals[0] = 10.1 vals[1] = 20.23 vals[2] = 33.1 vals[3] = 70.8 C++ 140 vals[4] = 50 When returning a reference, be careful that the object being referred to does not go out of scope. So it is not legal to return a reference to local var. But you can always return a reference on a static variable. int&amp; func() { int q; //! return q; // Compile time error static int x; return x; // Safe, x lives outside this scope } C++ 141 The C++ standard library does not provide a proper date type. C++ inherits the structs and functions for date and time manipulation from C. To access date and time related functions and structures, you would need to include header file in your C++ program. There are four time-related types: clock_t, time_t, size_t, and tm. The types - clock_t, size_t and time_t are capable of representing the system time and date as some sort of integer. The structure type tm holds the date and time in the form of a C structure having the following elements: struct tm { int tm_sec; // seconds of minutes from 0 to 61 int tm_min; // minutes of hour from 0 to 59 int tm_hour; // hours of day from 0 to 24 int tm_mday; // day of month from 1 to 31 int tm_mon; // month of year from 0 to 11 int tm_year; // year since 1900 int tm_wday; // days since sunday int tm_yday; // days since January 1st int tm_isdst; // hours of daylight savings time } Following are the important functions, which we use while working with date and time in C or C++. All these functions are part of standard C and C++ library and you can check their detail using reference to C++ standard library given below. SN Function &amp; Purpose 1 time_t time(time_t *time); This returns the current calendar time of the system in number of seconds elapsed since January 1, 1970. If the system has no time, .1 is returned. 2 char *ctime(const time_t *time); This returns a pointer to a string of the form day month year 20. DATE AND TIME C++ 142 hours:minutes:seconds year\n\0. 3 struct tm *localtime(const time_t *time); This returns a pointer to the tm structure representing local time. 4 clock_t clock(void); This returns a value that approximates the amount of time the calling program has been running. A value of .1 is returned if the time is not available. 5 char * asctime ( const struct tm * time ); This returns a pointer to a string that contains the information stored in the structure pointed to by time converted into the form: day month date hours:minutes:seconds year\n\0 6 struct tm *gmtime(const time_t *time); This returns a pointer to the time in the form of a tm structure. The time is represented in Coordinated Universal Time (UTC), which is essentially Greenwich Mean Time (GMT). 7 time_t mktime(struct tm *time); This returns the calendar-time equivalent of the time found in the structure pointed to by time. 8 double difftime ( time_t time2, time_t time1 ); This function calculates the difference in seconds between time1 and time2. 9 size_t strftime(); This function can be used to format date and time in a specific format. Current Date and Time Suppose you want to retrieve the current system date and time, either as a local time or as a Coordinated Universal Time (UTC). Following is the example to achieve the same: #include #include C++ 143 using namespace std; int main( ) { // current date/time based on current system time_t now = time(0); // convert now to string form char* dt = ctime(&amp;now); cout &lt;&lt; "The local date and time is: " &lt;&lt; dt &lt;&lt; endl; // convert now to tm struct for UTC tm *gmtm = gmtime(&amp;now); dt = asctime(gmtm); cout &lt;&lt; "The UTC date and time is:"&lt;&lt; dt &lt;&lt; endl; } When the above code is compiled and executed, it produces the following result: The local date and time is: Sat Jan 8 20:07:41 2011 The UTC date and time is:Sun Jan 9 03:07:41 2011 Format Time using struct tm The tm structure is very important while working with date and time in either C or C++. This structure holds the date and time in the form of a C structure as mentioned above. Most of the time related functions makes use of tm structure. Following is an example which makes use of various date and time related functions and tm structure: While using structure in this chapter, I'm making an assumption that you have basic understanding on C structure and how to access structure members using arrow -&gt; operator. #include #include C++ 144 using namespace std; int main( ) { // current date/time based on current system time_t now = time(0); cout &lt;&lt; "Number of sec since January 1,1970:" &lt;&lt; now &lt;&lt; endl; tm *ltm = localtime(&amp;now); // print various components of tm structure. cout &lt;&lt; "Year: "&lt;&lt; 1900 + ltm-&gt;tm_year &lt;&lt; endl; cout &lt;&lt; "Month: "&lt;&lt; 1 + ltm-&gt;tm_mon&lt;&lt; endl; cout &lt;&lt; "Day: "&lt;&lt; ltm-&gt;tm_mday &lt;&lt; endl; cout &lt;&lt; "Time: "&lt;&lt; 1 + ltm-&gt;tm_hour &lt;&lt; ":"; cout &lt;&lt; 1 + ltm-&gt;tm_min &lt;&lt; ":"; cout &lt;&lt; 1 + ltm-&gt;tm_sec &lt;&lt; endl; } When the above code is compiled and executed, it produces the following result: Number of sec since January 1, 1970:1294548238 Year: 2011 Month: 1 Day: 8 Time: 22: 44:59 C++ 145 The C++ standard libraries provide an extensive set of input/output capabilities which we will see in subsequent chapters. This chapter will discuss very basic and most common I/O operations required for C++ programming. C++ I/O occurs in streams, which are sequences of bytes. If bytes flow from a device like a keyboard, a disk drive, or a network connection etc. to main memory, this is called input operation and if bytes flow from main memory to a device like a display screen, a printer, a disk drive, or a network connection, etc., this is called output operation. I/O Library Header Files There are following header files important to C++ programs: Header File Function and Description This file defines the cin, cout, cerr and clog objects, which correspond to the standard input stream, the standard output stream, the un-buffered standard error stream and the buffered standard error stream, respectively. This file declares services useful for performing formatted I/O with so-called parameterized stream manipulators, such as setw and setprecision. This file declares services for user-controlled file processing. We will discuss about it in detail in File and Stream related chapter. The Standard Output Stream (cout) The predefined object cout is an instance of ostream class. The cout object is said to be "connected to" the standard output device, which usually is the display screen. The cout is used in conjunction with the stream insertion operator, which is written as &lt;&lt; which are two less than signs as shown in the following example. #include 21. BASIC INPUT/OUTPUT C++ 146 using namespace std; int main( ) { char str[] = "Hello C++"; cout &lt;&lt; "Value of str is : " &lt;&lt; str &lt;&lt; endl; } When the above code is compiled and executed, it produces the following result: Value of str is : Hello C++ The C++ compiler also determines the data type of variable to be output and selects the appropriate stream insertion operator to display the value. The &lt;&lt; operator is overloaded to output data items of built-in types integer, float, double, strings and pointer values. The insertion operator &lt;&lt; may be used more than once in a single statement as shown above and endl is used to add a new-line at the end of the line. The Standard Input Stream (cin) The predefined object cin is an instance of istream class. The cin object is said to be attached to the standard input device, which usually is the keyboard. The cin is used in conjunction with the stream extraction operator, which is written as &gt;&gt; which are two greater than signs as shown in the following example. #include using namespace std; int main( ) { char name[50]; cout &lt;&lt; "Please enter your name: "; cin &gt;&gt; name; cout &lt;&lt; "Your name is: " &lt;&lt; name &lt;&lt; endl; C++ 147 } When the above code is compiled and executed, it will prompt you to enter a name. You enter a value and then hit enter to see the following result: Please enter your name: cplusplus Your name is: cplusplus The C++ compiler also determines the data type of the entered value and selects the appropriate stream extraction operator to extract the value and store it in the given variables. The stream extraction operator &gt;&gt; may be used more than once in a single statement. To request more than one datum you can use the following: cin &gt;&gt; name &gt;&gt; age; This will be equivalent to the following two statements: cin &gt;&gt; name; cin &gt;&gt; age; The Standard Error Stream (cerr) The predefined object cerr is an instance of ostream class. The cerr object is said to be attached to the standard error device, which is also a display screen but the object cerr is un-buffered and each stream insertion to cerr causes its output to appear immediately. The cerr is also used in conjunction with the stream insertion operator as shown in the following example. #include using namespace std; int main( ) { char str[] = "Unable to read...."; cerr &lt;&lt; "Error message : " &lt;&lt; str &lt;&lt; endl; } When the above code is compiled and executed, it produces the following result: C++ 148 Error message : Unable to read.... The Standard Log Stream (clog) The predefined object clog is an instance of ostream class. The clog object is said to be attached to the standard error device, which is also a display screen but the object clog is buffered. This means that each insertion to clog could cause its output to be held in a buffer until the buffer is filled or until the buffer is flushed. The clog is also used in conjunction with the stream insertion operator as shown in the following example. #include using namespace std; int main( ) { char str[] = "Unable to read...."; clog &lt;&lt; "Error message : " &lt;&lt; str &lt;&lt; endl; } When the above code is compiled and executed, it produces the following result: Error message : Unable to read.... You would not be able to see any difference in cout, cerr and clog with these small examples, but while writing and executing big programs the difference becomes obvious. So it is good practice to display error messages using cerr stream and while displaying other log messages then clog should be used. C++ 149 C/C++ arrays allow you to define variables that combine several data items of the same kind, but structure is another user defined data type which allows you to combine data items of different kinds. Structures are used to represent a record, suppose you want to keep track of your books in a library. You might want to track the following attributes about each book: · Title · Author · Subject · Book ID Defining a Structure To define a structure, you must use the struct statement. The struct statement defines a new data type, with more than one member, for your program. The format of the struct statement is this: struct [structure tag] { member definition; member definition; ... member definition; } [one or more structure variables]; The structure tag is optional and each member definition is a normal variable definition, such as int i; or float f; or any other valid variable definition. At the end of the structure's definition, before the final semicolon, you can specify one or more structure variables but it is optional. Here is the way you would declare the Book structure: struct Books { char title[50]; char author[50]; char subject[100]; 22. DATA STRUCTURES C++ 150 int book_id; }book; Accessing Structure Members To access any member of a structure, we use the member access operator (.). The member access operator is coded as a period between the structure variable name and the structure member that we wish to access. You would use struct keyword to define variables of structure type. Following is the example to explain usage of structure: #include #include using namespace std; struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; int main( ) { struct Books Book1; // Declare Book1 of type Book struct Books Book2; // Declare Book2 of type Book // book 1 specification strcpy( Book1.title, "Learn C++ Programming"); strcpy( Book1.author, "Chand Miyan"); strcpy( Book1.subject, "C++ Programming"); Book1.book_id = 6495407; // book 2 specification strcpy( Book2.title, "Telecom Billing"); C++ 151 strcpy( Book2.author, "Yakit Singha"); strcpy( Book2.subject, "Telecom"); Book2.book_id = 6495700; // Print Book1 info cout &lt;&lt; "Book 1 title : " &lt;&lt; Book1.title &lt;&lt;&lt; "Book 1 author : " &lt;&lt; Book1.author &lt;&lt;&lt; "Book 1 subject : " &lt;&lt; Book1.subject &lt;&lt;&lt; "Book 1 id : " &lt;&lt; Book1.book_id &lt;&lt;&lt; "Book 2 title : " &lt;&lt; Book2.title &lt;&lt;&lt; "Book 2 author : " &lt;&lt; Book2.author &lt;&lt;&lt; "Book 2 subject : " &lt;&lt; Book2.subject &lt;&lt;&lt; "Book 2 id : " &lt;&lt; Book2.book_id &lt; #include C++ 152 using namespace std; void printBook( struct Books book ); struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; int main( ) { struct Books Book1; // Declare Book1 of type Book struct Books Book2; // Declare Book2 of type Book // book 1 specification strcpy( Book1.title, "Learn C++ Programming"); strcpy( Book1.author, "Chand Miyan"); strcpy( Book1.subject, "C++ Programming"); Book1.book_id = 6495407; // book 2 specification strcpy( Book2.title, "Telecom Billing"); strcpy( Book2.author, "Yakit Singha"); strcpy( Book2.subject, "Telecom"); Book2.book_id = 6495700; // Print Book1 info printBook( Book1 ); // Print Book2 info printBook( Book2 ); C++ 153 return 0; } void printBook( struct Books book ) { cout &lt;&lt; "Book title : " &lt;&lt; book.title &lt;&lt;&lt; "Book author : " &lt;&lt; book.author &lt;&lt;&lt; "Book subject : " &lt;&lt; book.subject &lt;&lt;&lt; "Book id : " &lt;&lt; book.book_id &lt; using namespace std; class Box { public: double length; // Length of a box double breadth; // Breadth of a box double height; // Height of a box }; int main( ) { Box Box1; // Declare Box1 of type Box Box Box2; // Declare Box2 of type Box double volume = 0.0; // Store the volume of a box here // box 1 specification Box1.height = 5.0; Box1.length = 6.0; Box1.breadth = 7.0; // box 2 specification Box2.height = 10.0; Box2.length = 12.0; Box2.breadth = 13.0; // volume of box 1 volume = Box1.height * Box1.length * Box1.breadth; C++ 159 cout &lt;&lt; "Volume of Box1 : " &lt;&lt; volume &lt;&lt;&lt; "Volume of Box2 : " &lt;&lt; volume &lt; using namespace std; class Box C++ 162 { public: double length; // Length of a box double breadth; // Breadth of a box double height; // Height of a box // Member functions declaration double getVolume(void); void setLength( double len ); void setBreadth( double bre ); void setHeight( double hei ); }; // Member functions definitions double Box::getVolume(void) { return length * breadth * height; } void Box::setLength( double len ) { length = len; } void Box::setBreadth( double bre ) { breadth = bre; } void Box::setHeight( double hei ) { height = hei; } C++ 163 // Main function for the program int main( ) { Box Box1; // Declare Box1 of type Box Box Box2; // Declare Box2 of type Box double volume = 0.0; // Store the volume of a box here // box 1 specification Box1.setLength(6.0); Box1.setBreadth(7.0); Box1.setHeight(5.0); // box 2 specification Box2.setLength(12.0); Box2.setBreadth(13.0); Box2.setHeight(10.0); // volume of box 1 volume = Box1.getVolume(); cout &lt;&lt; "Volume of Box1 : " &lt;&lt; volume &lt;&lt;&lt; "Volume of Box2 : " &lt;&lt; volume &lt; using namespace std; class Line { public: double length; C++ 165 void setLength( double len ); double getLength( void ); }; // Member functions definitions double Line::getLength(void) { return length ; } void Line::setLength( double len ) { length = len; } // Main function for the program int main( ) { Line line; // set line length line.setLength(6.0); cout &lt;&lt; "Length of line : " &lt;&lt; line.getLength() &lt;&lt;&lt; "Length of line : " &lt;&lt; line.length &lt; using namespace std; class Box { public: double length; void setWidth( double wid ); double getWidth( void ); private: double width; }; // Member functions definitions double Box::getWidth(void) C++ 167 { return width ; } void Box::setWidth( double wid ) { width = wid; } // Main function for the program int main( ) { Box box; // set box length without member function box.length = 10.0; // OK: because length is public cout &lt;&lt; "Length of box : " &lt;&lt; box.length &lt;&lt;&lt; "Width of box : " &lt;&lt; box.getWidth() &lt; using namespace std; class Box { protected: double width; }; class SmallBox:Box // SmallBox is the derived class. { public: void setSmallWidth( double wid ); double getSmallWidth( void ); }; // Member functions of child class double SmallBox::getSmallWidth(void) { return width ; } void SmallBox::setSmallWidth( double wid ) { width = wid; } // Main function for the program int main( ) { C++ 169 SmallBox box; // set box width using member function box.setSmallWidth(5.0); cout &lt;&lt; "Width of box : "&lt;&lt; box.getSmallWidth() &lt;&lt; endl; return 0; } When the above code is compiled and executed, it produces the following result: Width of box : 5 Constructor &amp; Destructor A class constructor is a special member function of a class that is executed whenever we create new objects of that class. A constructor will have exact same name as the class and it does not have any return type at all, not even void. Constructors can be very useful for setting initial values for certain member variables. Following example explains the concept of constructor: #include using namespace std; class Line { public: void setLength( double len ); double getLength( void ); Line(); // This is the constructor private: double length; }; // Member functions definitions including constructor C++ 170 Line::Line(void) { cout &lt;&lt; "Object is being created" &lt;&lt; endl; } void Line::setLength( double len ) { length = len; } double Line::getLength( void ) { return length; } // Main function for the program int main( ) { Line line; // set line length line.setLength(6.0); cout &lt;&lt; "Length of line : " &lt;&lt; line.getLength() &lt; using namespace std; class Line { public: void setLength( double len ); double getLength( void ); Line(double len); // This is the constructor private: double length; }; // Member functions definitions including constructor Line::Line( double len) { cout &lt;&lt; "Object is being created, length = " &lt;&lt; len &lt;&lt; endl; length = len; } void Line::setLength( double len ) { length = len; } double Line::getLength( void ) { return length; } // Main function for the program int main( ) { C++ 172 Line line(10.0); // get initially set length. cout &lt;&lt; "Length of line : " &lt;&lt; line.getLength() &lt;&lt;&lt; "Length of line : " &lt;&lt; line.getLength() &lt;&lt;&lt; "Object is being created, length = " &lt;&lt; len &lt;&lt; endl; } Above syntax is equal to the following syntax: Line::Line( double len) { cout &lt;&lt; "Object is being created, length = " &lt;&lt; len &lt;&lt; endl; length = len; } If for a class C, you have multiple fields X, Y, Z, etc., to be initialized, then use can use same syntax and separate the fields by comma as follows: C::C( double a, double b, double c): X(a), Y(b), Z(c) { C++ 173 .... } The Class Destructor A destructor is a special member function of a class that is executed whenever an object of it's class goes out of scope or whenever the delete expression is applied to a pointer to the object of that class. A destructor will have exact same name as the class prefixed with a tilde (~) and it can neither return a value nor can it take any parameters. Destructor can be very useful for releasing resources before coming out of the program like closing files, releasing memories etc. Following example explains the concept of destructor: #include using namespace std; class Line { public: void setLength( double len ); double getLength( void ); Line(); // This is the constructor declaration ~Line(); // This is the destructor: declaration private: double length; }; // Member functions definitions including constructor Line::Line(void) { cout &lt;&lt; "Object is being created" &lt;&lt; endl; } Line::~Line(void) { C++ 174 cout &lt;&lt; "Object is being deleted" &lt;&lt; endl; } void Line::setLength( double len ) { length = len; } double Line::getLength( void ) { return length; } // Main function for the program int main( ) { Line line; // set line length line.setLength(6.0); cout &lt;&lt; "Length of line : " &lt;&lt; line.getLength() &lt; using namespace std; class Line { public: int getLength( void ); Line( int len ); // simple constructor Line( const Line &amp;obj); // copy constructor ~Line(); // destructor private: int *ptr; }; // Member functions definitions including constructor Line::Line(int len) { C++ 176 cout &lt;&lt; "Normal constructor allocating ptr" &lt;&lt; endl; // allocate memory for the pointer; ptr = new int; *ptr = len; } Line::Line(const Line &amp;obj) { cout &lt;&lt; "Copy constructor allocating ptr." &lt;&lt; endl; ptr = new int; *ptr = *obj.ptr; // copy the value } Line::~Line(void) { cout &lt;&lt; "Freeing memory!" &lt;&lt; endl; delete ptr; } int Line::getLength( void ) { return *ptr; } void display(Line obj) { cout &lt;&lt; "Length of line : " &lt;&lt; obj.getLength() &lt; using namespace std; class Line { public: int getLength( void ); Line( int len ); // simple constructor Line( const Line &amp;obj); // copy constructor ~Line(); // destructor private: int *ptr; }; // Member functions definitions including constructor Line::Line(int len) { cout &lt;&lt; "Normal constructor allocating ptr" &lt;&lt; endl; // allocate memory for the pointer; ptr = new int; C++ 178 *ptr = len; } Line::Line(const Line &amp;obj) { cout &lt;&lt; "Copy constructor allocating ptr." &lt;&lt; endl; ptr = new int; *ptr = *obj.ptr; // copy the value } Line::~Line(void) { cout &lt;&lt; "Freeing memory!" &lt;&lt; endl; delete ptr; } int Line::getLength( void ) { return *ptr; } void display(Line obj) { cout &lt;&lt; "Length of line : " &lt;&lt; obj.getLength() &lt; using namespace std; class Box { public: static int objectCount; // Constructor definition Box(double l=2.0, double b=2.0, double h=2.0) { cout &lt;&lt;"Constructor called." &lt;&lt; endl; length = l; breadth = b; height = h; // Increase every time object is created objectCount++; } double Volume() { return length * breadth * height; } private: double length; // Length of a box double breadth; // Breadth of a box double height; // Height of a box }; // Initialize static member of class Box int Box::objectCount = 0; int main(void) C++ 187 { Box Box1(3.3, 1.2, 1.5); // Declare box1 Box Box2(8.5, 6.0, 2.0); // Declare box2 // Print total number of objects. cout &lt;&lt; "Total objects: " &lt;&lt; Box::objectCount &lt;&lt; endl; return 0; } When the above code is compiled and executed, it produces the following result: Constructor called. Constructor called. Total objects: 2 Static Function Members By declaring a function member as static, you make it independent of any particular object of the class. A static member function can be called even if no objects of the class exist and the static functions are accessed using only the class name and the scope resolution operator ::. A static member function can only access static data member, other static member functions and any other functions from outside the class. Static member functions have a class scope and they do not have access to the this pointer of the class. You could use a static member function to determine whether some objects of the class have been created or not. Let us try the following example to understand the concept of static function members: #include using namespace std; class Box { public: static int objectCount; // Constructor definition C++ 188 Box(double l=2.0, double b=2.0, double h=2.0) { cout &lt;&lt;"Constructor called." &lt;&lt; endl; length = l; breadth = b; height = h; // Increase every time object is created objectCount++; } double Volume() { return length * breadth * height; } static int getCount() { return objectCount; } private: double length; // Length of a box double breadth; // Breadth of a box double height; // Height of a box }; // Initialize static member of class Box int Box::objectCount = 0; int main(void) { // Print total number of objects before creating object. cout &lt;&lt; "Inital Stage Count: " &lt;&lt; Box::getCount() &lt;&lt; endl; Box Box1(3.3, 1.2, 1.5); // Declare box1 Box Box2(8.5, 6.0, 2.0); // Declare box2 C++ 189 // Print total number of objects after creating object. cout &lt;&lt; "Final Stage Count: " &lt;&lt; Box::getCount() &lt;&lt; endl; return 0; } When the above code is compiled and executed, it produces the following result: Inital Stage Count: 0 Constructor called. Constructor called. Final Stage Count: 2 C++ 190 One of the most important concepts in object-oriented programming is that of inheritance. Inheritance allows us to define a class in terms of another class, which makes it easier to create and maintain an application. This also provides an opportunity to reuse the code functionality and fast implementation time. When creating a class, instead of writing completely new data members and member functions, the programmer can designate that the new class should inherit the members of an existing class. This existing class is called the base class, and the new class is referred to as the derived class. The idea of inheritance implements the is a relationship. For example, mammal IS-A animal, dog IS-A mammal hence dog IS-A animal as well and so on. Base &amp; Derived Classes A class can be derived from more than one classes, which means it can inherit data and functions from multiple base classes. To define a derived class, we use a class derivation list to specify the base class(es). A class derivation list names one or more base classes and has the form: class derived-class: access-specifier base-class Where access-specifier is one of public, protected, or private, and base-class is the name of a previously defined class. If the access-specifier is not used, then it is private by default. Consider a base class Shape and its derived class Rectangle as follows: #include using namespace std; // Base class class Shape { public: void setWidth(int w) { width = w; } 24. INHERITANCE C++ 191 void setHeight(int h) { height = h; } protected: int width; int height; }; // Derived class class Rectangle: public Shape { public: int getArea() { return (width * height); } }; int main(void) { Rectangle Rect; Rect.setWidth(5); Rect.setHeight(7); // Print the area of the object. cout &lt;&lt; "Total area: " &lt;&lt; Rect.getArea() &lt;&lt; endl; return 0; } When the above code is compiled and executed, it produces the following result: C++ 192 Total area: 35 Access Control and Inheritance A derived class can access all the non-private members of its base class. Thus base-class members that should not be accessible to the member functions of derived classes should be declared private in the base class. We can summarize the different access types according to - who can access them, in the following way: Access public protected private Same class yes yes yes Derived classes yes yes no Outside classes yes no no A derived class inherits all base class methods with the following exceptions: · Constructors, destructors and copy constructors of the base class. · Overloaded operators of the base class. · The friend functions of the base class. Type of Inheritance When deriving a class from a base class, the base class may be inherited through public, protected or private inheritance. The type of inheritance is specified by the access-specifier as explained above. We hardly use protected or private inheritance, but public inheritance is commonly used. While using different type of inheritance, following rules are applied: · Public Inheritance: When deriving a class from a public base class, public members of the base class become public members of the derived class and protected members of the base class become protected members of the derived class. A base class's private members are never accessible directly from a derived class, but can be accessed through calls to the public and protected members of the base class. · Protected Inheritance: When deriving from a protected base class, public and protected members of the base class become protected members of the derived class. C++ 193 · Private Inheritance: When deriving from a private base class, public and protected members of the base class become private members of the derived class. Multiple Inheritance A C++ class can inherit members from more than one class and here is the extended syntax: class derived-class: access baseA, access baseB.... Where access is one of public, protected, or private and would be given for every base class and they will be separated by comma as shown above. Let us try the following example: #include using namespace std; // Base class Shape class Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // Base class PaintCost class PaintCost { C++ 194 public: int getCost(int area) { return area * 70; } }; // Derived class class Rectangle: public Shape, public PaintCost { public: int getArea() { return (width * height); } }; int main(void) { Rectangle Rect; int area; Rect.setWidth(5); Rect.setHeight(7); area = Rect.getArea(); // Print the area of the object. cout &lt;&lt; "Total area: " &lt;&lt; Rect.getArea() &lt;&lt; endl; // Print the total cost of painting cout &lt;&lt; "Total paint cost: $" &lt;&lt; Rect.getCost(area) &lt;&lt; endl; return 0; C++ 195 } When the above code is compiled and executed, it produces the following result: Total area: 35 Total paint cost: $2450 C++ 196 C++ allows you to specify more than one definition for a function name or an operator in the same scope, which is called function overloading and operator overloading respectively. An overloaded declaration is a declaration that is declared with the same name as a previously declared declaration in the same scope, except that both declarations have different arguments and obviously different definition (implementation). When you call an overloaded function or operator, the compiler determines the most appropriate definition to use, by comparing the argument types you have used to call the function or operator with the parameter types specified in the definitions. The process of selecting the most appropriate overloaded function or operator is called overload resolution. Function Overloading in C++ You can have multiple definitions for the same function name in the same scope. The definition of the function must differ from each other by the types and/or the number of arguments in the argument list. You cannot overload function declarations that differ only by return type. Following is the example where same function print() is being used to print different data types: #include using namespace std; class printData { public: void print(int i) { cout &lt;&lt; "Printing int: " &lt;&lt; i &lt;&lt; endl; } void print(double f) { cout &lt;&lt; "Printing float: " &lt;&lt; f &lt;&lt; endl; } 25. OVERLOADING (OPERATOR &amp; FUNCTION) C++ 197 void print(char* c) { cout &lt;&lt; "Printing character: " &lt;&lt; c &lt;&lt; endl; } }; int main(void) { printData pd; // Call print to print integer pd.print(5); // Call print to print float pd.print(500.263); // Call print to print character pd.print("Hello C++"); return 0; } When the above code is compiled and executed, it produces the following result: Printing int: 5 Printing float: 500.263 Printing character: Hello C++ Operators Overloading in C++ You can redefine or overload most of the built-in operators available in C++. Thus, a programmer can use operators with user-defined types as well. Overloaded operators are functions with special names the keyword operator followed by the symbol for the operator being defined. Like any other function, an overloaded operator has a return type and a parameter list. Box operator+(const Box&amp;); Declares the addition operator that can be used to add two Box objects and returns final Box object. Most overloaded operators may be defined as ordinary non-member functions or as class member functions. In case we define above function as non-member function of a class then we would have to pass two arguments for each operand as follows: C++ 198 Box operator+(const Box&amp;, const Box&amp;); Following is the example to show the concept of operator over loading using a member function. Here an object is passed as an argument whose properties will be accessed using this object, the object which will call this operator can be accessed using this operator as explained below: #include using namespace std; class Box { public: double getVolume(void) { return length * breadth * height; } void setLength( double len ) { length = len; } void setBreadth( double bre ) { breadth = bre; } void setHeight( double hei ) { height = hei; } // Overload + operator to add two Box objects. Box operator+(const Box&amp; b) { Box box; C++ 199 box.length = this-&gt;length + b.length; box.breadth = this-&gt;breadth + b.breadth; box.height = this-&gt;height + b.height; return box; } private: double length; // Length of a box double breadth; // Breadth of a box double height; // Height of a box }; // Main function for the program int main( ) { Box Box1; // Declare Box1 of type Box Box Box2; // Declare Box2 of type Box Box Box3; // Declare Box3 of type Box double volume = 0.0; // Store the volume of a box here // box 1 specification Box1.setLength(6.0); Box1.setBreadth(7.0); Box1.setHeight(5.0); // box 2 specification Box2.setLength(12.0); Box2.setBreadth(13.0); Box2.setHeight(10.0); // volume of box 1 volume = Box1.getVolume(); cout &lt;&lt; "Volume of Box1 : " &lt;&lt; volume &lt;&lt;&lt; "Volume of Box2 : " &lt;&lt; volume &lt;&lt;&lt; "Volume of Box3 : " &lt;&lt; volume &lt;&lt; &gt; &lt;= &gt;= ++ -- &lt;&lt; &gt;&gt; == != &amp;&amp; || += -= /= %= ^= &amp;= |= *= &lt;&lt;= &gt;&gt;= [] () -&gt; -&gt;* new new [] delete delete [] Following is the list of operators, which cannot be overloaded: C++ 201 :: .* . ?: Operator Overloading Examples Here are various operator overloading examples to help you in understanding the concept. S.N. Operators and Example 1 Unary operators overloading 2 Binary operators overloading 3 Relational operators overloading 4 Input/Output operators overloading 5 ++ and -- operators overloading 6 Assignment operators overloading 7 Function call () operator overloading 8 Subscripting [] operator overloading 9 Class member access operator -&gt; overloading Unary Operators Overloading The unary operators operate on a single operand and following are the examples of Unary operators: · The increment (++) and decrement (--) operators. · The unary minus (-) operator. · The logical not (!) operator. The unary operators operate on the object for which they were called and normally, this operator appears on the left side of the object, as in !obj, -obj, and ++obj but sometime they can be used as postfix as well like obj++ or obj--. Following example explain how minus (-) operator can be overloaded for prefix as well as postfix usage. C++ 202 #include using namespace std; class Distance { private: int feet; // 0 to infinite int inches; // 0 to 12 public: // required constructors Distance(){ feet = 0; inches = 0; } Distance(int f, int i){ feet = f; inches = i; } // method to display distance void displayDistance() { cout &lt;&lt; "F: " &lt;&lt; feet &lt;&lt; " I:" &lt;&lt; inches &lt; using namespace std; class Time { private: int hours; // 0 to 23 int minutes; // 0 to 59 public: // required constructors Time(){ hours = 0; minutes = 0; } C++ 204 Time(int h, int m){ hours = h; minutes = m; } // method to display time void displayTime() { cout &lt;&lt; "H: " &lt;&lt; hours &lt;&lt; " M:" &lt;&lt; minutes &lt;= 60) { ++hours; minutes -= 60; } return Time(hours, minutes); } // overloaded postfix ++ operator Time operator++( int ) { // save the orignal value Time T(hours, minutes); // increment this object ++minutes; if(minutes &gt;= 60) { ++hours; minutes -= 60; } // return old original value return T; C++ 205 } }; int main() { Time T1(11, 59), T2(10,40); ++T1; // increment T1 T1.displayTime(); // display T1 ++T1; // increment T1 again T1.displayTime(); // display T1 T2++; // increment T2 T2.displayTime(); // display T2 T2++; // increment T2 again T2.displayTime(); // display T2 return 0; } When the above code is compiled and executed, it produces the following result: H: 12 M:0 H: 12 M:1 H: 10 M:41 H: 10 M:42 Binary Operators Overloading The unary operators take two arguments and following are the examples of Binary operators. You use binary operators very frequently like addition (+) operator, subtraction (-) operator and division (/) operator. Following example explains how addition (+) operator can be overloaded. Similar way, you can overload subtraction (-) and division (/) operators. #include using namespace std; C++ 206 class Box { double length; // Length of a box double breadth; // Breadth of a box double height; // Height of a box public: double getVolume(void) { return length * breadth * height; } void setLength( double len ) { length = len; } void setBreadth( double bre ) { breadth = bre; } void setHeight( double hei ) { height = hei; } // Overload + operator to add two Box objects. Box operator+(const Box&amp; b) { Box box; box.length = this-&gt;length + b.length; box.breadth = this-&gt;breadth + b.breadth; box.height = this-&gt;height + b.height; return box; C++ 207 } }; // Main function for the program int main( ) { Box Box1; // Declare Box1 of type Box Box Box2; // Declare Box2 of type Box Box Box3; // Declare Box3 of type Box double volume = 0.0; // Store the volume of a box here // box 1 specification Box1.setLength(6.0); Box1.setBreadth(7.0); Box1.setHeight(5.0); // box 2 specification Box2.setLength(12.0); Box2.setBreadth(13.0); Box2.setHeight(10.0); // volume of box 1 volume = Box1.getVolume(); cout &lt;&lt; "Volume of Box1 : " &lt;&lt; volume &lt;&lt;&lt; "Volume of Box2 : " &lt;&lt; volume &lt;&lt;&lt; "Volume of Box3 : " &lt;&lt; volume &lt;, &lt;=, &gt;=, ==, etc.) which can be used to compare C++ built-in data types. You can overload any of these operators, which can be used to compare the objects of a class. Following example explains how a &lt; operator can be overloaded and similar way you can overload other relational operators. #include using namespace std; class Distance { private: int feet; // 0 to infinite int inches; // 0 to 12 public: // required constructors Distance(){ feet = 0; inches = 0; } Distance(int f, int i){ feet = f; inches = i; } // method to display distance C++ 209 void displayDistance() { cout &lt;&lt; "F: " &lt;&lt; feet &lt;&lt; " I:" &lt;&lt; inches &lt;&lt; operator bool operator &lt; d.feet) { return true; } if(feet == d.feet &amp;&amp; inches &lt; d.inches) { return true; } return false; } }; int main() { Distance D1(11, 10), D2(5, 11); if( D1 &lt; D2 ) { cout &lt;&lt; "D1 is less than D2 " &lt;&lt; endl; } else C++ 210 { cout &lt;&lt; "D2 is less than D1 " &lt;&lt; endl; } return 0; } When the above code is compiled and executed, it produces the following result: D2 is less than D1 Input/Output Operators Overloading C++ is able to input and output the built-in data types using the stream extraction operator &gt;&gt; and the stream insertion operator &lt;&gt; and insertion operator &lt; using namespace std; class Distance { private: int feet; // 0 to infinite int inches; // 0 to 12 public: // required constructors Distance(){ feet = 0; inches = 0; } Distance(int f, int i){ feet = f; inches = i; C++ 211 } friend ostream &amp;operator&lt;&lt;&lt; "F : " &lt;&lt; D.feet &lt;&lt; " I : " &lt;&lt; D.inches; return output; } friend istream &amp;operator&gt;&gt;( istream &amp;input, Distance &amp;D ) { input &gt;&gt; D.feet &gt;&gt; D.inches; return input; } }; int main() { Distance D1(11, 10), D2(5, 11), D3; cout &lt;&lt; "Enter the value of object : " &lt;&lt; endl; cin &gt;&gt; D3; cout &lt;&lt; "First Distance : " &lt;&lt; D1 &lt;&lt; endl; cout &lt;&lt; "Second Distance :" &lt;&lt; D2 &lt;&lt; endl; cout &lt;&lt; "Third Distance :" &lt;&lt; D3 &lt;&lt; endl; return 0; } When the above code is compiled and executed, it produces the following result: $./a.out Enter the value of object : 70 10 First Distance : F : 11 I : 10 C++ 212 Second Distance :F : 5 I : 11 Third Distance :F : 70 I : 10 ++ and - - Operators Overloading The increment (++) and decrement (--) operators are two important unary operators available in C++. Following example explain how increment (++) operator can be overloaded for prefix as well as postfix usage. Similar way, you can overload operator (--). #include using namespace std; class Time { private: int hours; // 0 to 23 int minutes; // 0 to 59 public: // required constructors Time(){ hours = 0; minutes = 0; } Time(int h, int m){ hours = h; minutes = m; } // method to display time void displayTime() { cout &lt;&lt; "H: " &lt;&lt; hours &lt;&lt; " M:" &lt;&lt; minutes &lt;= 60) { ++hours; minutes -= 60; } return Time(hours, minutes); } // overloaded postfix ++ operator Time operator++( int ) { // save the orignal value Time T(hours, minutes); // increment this object ++minutes; if(minutes &gt;= 60) { ++hours; minutes -= 60; } // return old original value return T; } }; int main() { Time T1(11, 59), T2(10,40); ++T1; // increment T1 T1.displayTime(); // display T1 ++T1; // increment T1 again T1.displayTime(); // display T1 T2++; // increment T2 C++ 214 T2.displayTime(); // display T2 T2++; // increment T2 again T2.displayTime(); // display T2 return 0; } When the above code is compiled and executed, it produces the following result: H: 12 M:0 H: 12 M:1 H: 10 M:41 H: 10 M:42 Assignment Operators Overloading You can overload the assignment operator (=) just as you can other operators and it can be used to create an object just like the copy constructor. Following example explains how an assignment operator can be overloaded. #include using namespace std; class Distance { private: int feet; // 0 to infinite int inches; // 0 to 12 public: // required constructors Distance(){ feet = 0; inches = 0; } Distance(int f, int i){ feet = f; inches = i; } C++ 215 void operator=(const Distance &amp;D ) { feet = D.feet; inches = D.inches; } // method to display distance void displayDistance() { cout &lt;&lt; "F: " &lt;&lt; feet &lt;&lt; " I:" &lt;&lt; inches &lt;&lt; endl; } }; int main() { Distance D1(11, 10), D2(5, 11); cout &lt;&lt; "First Distance : "; D1.displayDistance(); cout &lt;&lt; "Second Distance :"; D2.displayDistance(); // use assignment operator D1 = D2; cout &lt;&lt; "First Distance :"; D1.displayDistance(); return 0; } When the above code is compiled and executed, it produces the following result: First Distance : F: 11 I:10 Second Distance :F: 5 I:11 First Distance :F: 5 I:11 Function Call () Operator Overloading C++ 216 The function call operator () can be overloaded for objects of class type. When you overload ( ), you are not creating a new way to call a function. Rather, you are creating an operator function that can be passed an arbitrary number of parameters. Following example explains how a function call operator () can be overloaded. #include using namespace std; class Distance { private: int feet; // 0 to infinite int inches; // 0 to 12 public: // required constructors Distance(){ feet = 0; inches = 0; } Distance(int f, int i){ feet = f; inches = i; } // overload function call Distance operator()(int a, int b, int c) { Distance D; // just put random calculation D.feet = a + c + 10; D.inches = b + c + 100 ; return D; } // method to display distance void displayDistance() { C++ 217 cout &lt;&lt; "F: " &lt;&lt; feet &lt;&lt; " I:" &lt;&lt; inches &lt;&lt; endl; } }; int main() { Distance D1(11, 10), D2; cout &lt;&lt; "First Distance : "; D1.displayDistance(); D2 = D1(10, 10, 10); // invoke operator() cout &lt;&lt; "Second Distance :"; D2.displayDistance(); return 0; } When the above code is compiled and executed, it produces the following result: First Distance : F: 11 I:10 Second Distance :F: 30 I:120 Subscripting [ ] Operator Overloading The subscript operator [] is normally used to access array elements. This operator can be overloaded to enhance the existing functionality of C++ arrays. Following example explains how a subscript operator [] can be overloaded. #include using namespace std; const int SIZE = 10; class safearay { private: C++ 218 int arr[SIZE]; public: safearay() { register int i; for(i = 0; i &lt; SIZE; i++) { arr[i] = i; } } int &amp;operator[](int i) { if( i &gt; SIZE ) { cout &lt;&lt; "Index out of bounds" &lt;&lt;&lt; "Value of A[2] : " &lt;&lt; A[2] &lt;&lt;&lt; "Value of A[5] : " &lt;&lt; A[5]&lt;&lt;&lt; "Value of A[12] : " &lt;&lt; A[12]&lt; Overloading The class member access operator (-&gt;) can be overloaded but it is bit trickier. It is defined to give a class type a "pointer-like" behavior. The operator -&gt; must be a member function. If used, its return type must be a pointer or an object of a class to which you can apply. The operator-&gt; is used often in conjunction with the pointer-dereference operator * to implement "smart pointers." These pointers are objects that behave like normal pointers except they perform other tasks when you access an object through them, such as automatic object deletion either when the pointer is destroyed, or the pointer is used to point to another object. The dereferencing operator-&gt; can be defined as a unary postfix operator. That is, given a class: class Ptr{ //... X * operator-&gt;(); }; Objects of class Ptr can be used to access members of class X in a very similar manner to the way pointers are used. For example: void f(Ptr p ) { p-&gt;m = 10 ; // (p.operator-&gt;())-&gt;m = 10 } The statement p-&gt;m is interpreted as (p.operator-&gt;())-&gt;m. Using the same concept, following example explains how a class access operator -&gt; can be overloaded. #include #include using namespace std; // Consider an actual class. class Obj { C++ 220 static int i, j; public: void f() const { cout &lt;&lt; i++ &lt;&lt; endl; } void g() const { cout &lt;&lt; j++ &lt;&lt; endl; } }; // Static member definitions: int Obj::i = 10; int Obj::j = 12; // Implement a container for the above class class ObjContainer { vector a; public: void add(Obj* obj) { a.push_back(obj); // call vector's standard method. } friend class SmartPointer; }; // implement smart pointer to access member of Obj class. class SmartPointer { ObjContainer oc; int index; public: SmartPointer(ObjContainer&amp; objc) { oc = objc; index = 0; } // Return value indicates end of list: bool operator++() // Prefix version { C++ 221 if(index &gt;= oc.a.size()) return false; if(oc.a[++index] == 0) return false; return true; } bool operator++(int) // Postfix version { return operator++(); } // overload operator-&gt; Obj* operator-&gt;() const { if(!oc.a[index]) { cout &lt;&lt; "Zero value"; return (Obj*)0; } return oc.a[index]; } }; int main() { const int sz = 10; Obj o[sz]; ObjContainer oc; for(int i = 0; i &lt; sz; i++) { oc.add(&amp;o[i]); } SmartPointer sp(oc); // Create an iterator do { sp-&gt;f(); // smart pointer call sp-&gt;g(); } while(sp++); return 0; C++ 222 } When the above code is compiled and executed, it produces the following result: 10 12 11 13 12 14 13 15 14 16 15 17 16 18 17 19 18 20 19 21 C++ 223 The word polymorphism means having many forms. Typically, polymorphism occurs when there is a hierarchy of classes and they are related by inheritance. C++ polymorphism means that a call to a member function will cause a different function to be executed depending on the type of object that invokes the function. Consider the following example where a base class has been derived by other two classes: #include using namespace std; class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } int area() { cout &lt;&lt; "Parent class area :" &lt;&lt;&lt; "Rectangle class area :" &lt;&lt;&lt; "Triangle class area :" &lt;area(); // store the address of Triangle shape = &amp;tri; // call triangle area. shape-&gt;area(); return 0; } C++ 225 When the above code is compiled and executed, it produces the following result: Parent class area Parent class area The reason for the incorrect output is that the call of the function area() is being set once by the compiler as the version defined in the base class. This is called static resolution of the function call, or static linkage - the function call is fixed before the program is executed. This is also sometimes called early binding because the area() function is set during the compilation of the program. But now, let's make a slight modification in our program and precede the declaration of area() in the Shape class with the keyword virtual so that it looks like this: class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } virtual int area() { cout &lt;&lt; "Parent class area :" &lt; using namespace std; int main( ) { cout &lt;&lt; "Hello C++" &lt; using namespace std; class Adder{ public: // constructor Adder(int i = 0) C++ 229 { total = i; } // interface to outside world void addNum(int number) { total += number; } // interface to outside world int getTotal() { return total; }; private: // hidden data from outside world int total; }; int main( ) { Adder a; a.addNum(10); a.addNum(20); a.addNum(30); cout &lt;&lt; "Total " &lt;&lt; a.getTotal() &lt; 29. INTERFACES C++ 235 using namespace std; // Base class class Shape { public: // pure virtual function providing interface framework. virtual int getArea() = 0; void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // Derived classes class Rectangle: public Shape { public: int getArea() { return (width * height); } }; class Triangle: public Shape { public: C++ 236 int getArea() { return (width * height)/2; } }; int main(void) { Rectangle Rect; Triangle Tri; Rect.setWidth(5); Rect.setHeight(7); // Print the area of the object. cout &lt;&lt; "Total Rectangle area: " &lt;&lt; Rect.getArea() &lt;&lt; endl; Tri.setWidth(5); Tri.setHeight(7); // Print the area of the object. cout &lt;&lt; "Total Triangle area: " &lt;&lt; Tri.getArea() &lt;&lt; endl; return 0; } When the above code is compiled and executed, it produces the following result: Total Rectangle area: 35 Total Triangle area: 17 You can see how an abstract class defined an interface in terms of getArea() and two other classes implemented same function but with different algorithm to calculate the area specific to the shape. Designing Strategy An object-oriented system might use an abstract base class to provide a common and standardized interface appropriate for all the external applications. Then, through inheritance from that abstract base class, derived classes are formed that operate similarly. C++ 237 The capabilities (i.e., the public functions) offered by the external applications are provided as pure virtual functions in the abstract base class. The implementations of these pure virtual functions are provided in the derived classes that correspond to the specific types of the application. This architecture also allows new applications to be added to a system easily, even after the system has been defined. C++ 238 So far, we have been using the iostream standard library, which provides cin and cout methods for reading from standard input and writing to standard output respectively. This tutorial will teach you how to read and write from a file. This requires another standard C++ library called fstream, which defines three new data types: Data Type Description ofstream This data type represents the output file stream and is used to create files and to write information to files. ifstream This data type represents the input file stream and is used to read information from files. fstream This data type represents the file stream generally, and has the capabilities of both ofstream and ifstream which means it can create files, write information to files, and read information from files. To perform file processing in C++, header files and must be included in your C++ source file. Opening a File A file must be opened before you can read from it or write to it. Either ofstream or fstream object may be used to open a file for writing. And ifstream object is used to open a file for reading purpose only. Following is the standard syntax for open() function, which is a member of fstream, ifstream, and ofstream objects. void open(const char *filename, ios::openmode mode); Here, the first argument specifies the name and location of the file to be opened and the second argument of the open() member function defines the mode in which the file should be opened. Mode Flag Description 30. FILES AND STREAMS C++ 239 ios::app Append mode. All output to that file to be appended to the end. ios::ate Open a file for output and move the read/write control to the end of the file. ios::in Open a file for reading. ios::out Open a file for writing. ios::trunc If the file already exists, its contents will be truncated before opening the file. You can combine two or more of these values by ORing them together. For example if you want to open a file in write mode and want to truncate it in case that already exists, following will be the syntax: ofstream outfile; outfile.open("file.dat", ios::out | ios::trunc ); Similar way, you can open a file for reading and writing purpose as follows: fstream afile; afile.open("file.dat", ios::out | ios::in ); Closing a File When a C++ program terminates it automatically flushes all the streams, release all the allocated memory and close all the opened files. But it is always a good practice that a programmer should close all the opened files before program termination. Following is the standard syntax for close() function, which is a member of fstream, ifstream, and ofstream objects. void close(); Writing to a File While doing C++ programming, you write information to a file from your program using the stream insertion operator (&lt;&gt;) just as you use that operator to input information from the keyboard. The only difference is that you use an ifstream or fstream object instead of the cin object. Read &amp; Write Example Following is the C++ program which opens a file in reading and writing mode. After writing information entered by the user to a file named afile.dat, the program reads information from the file and outputs it onto the screen: #include #include using namespace std; int main () { char data[100]; // open a file in write mode. ofstream outfile; outfile.open("afile.dat"); cout &lt;&lt; "Writing to the file" &lt;&lt; endl; cout &lt;&lt; "Enter your name: "; cin.getline(data, 100); // write inputted data into the file. outfile &lt;&lt; data &lt;&lt; endl; cout &lt;&lt; "Enter your age: "; cin &gt;&gt; data; cin.ignore(); // again write inputted data into the file. outfile &lt;&lt; data &lt;&lt; endl; C++ 241 // close the opened file. outfile.close(); // open a file in read mode. ifstream infile; infile.open("afile.dat"); cout &lt;&lt; "Reading from the file" &lt;&lt; endl; infile &gt;&gt; data; // write the data at the screen. cout &lt;&lt; data &lt;&lt; endl; // again read the data from the file and display it. infile &gt;&gt; data; cout &lt;&lt; data &lt;&lt; endl; // close the opened file. infile.close(); return 0; } When the above code is compiled and executed, it produces the following sample input and output: $./a.out Writing to the file Enter your name: Zara Enter your age: 9 Reading from the file Zara 9 Above examples make use of additional functions from cin object, like getline() function to read the line from outside, and ignore() function to ignore the extra characters left by previous read statement. C++ 242 File Position Pointers Both istream and ostream provide member functions for repositioning the fileposition pointer. These member functions are seekg ("seek get") for istream and seekp ("seek put") for ostream. The argument to seekg and seekp normally is a long integer. A second argument can be specified to indicate the seek direction. The seek direction can be ios::beg (the default) for positioning relative to the beginning of a stream, ios::cur for positioning relative to the current position in a stream or ios::end for positioning relative to the end of a stream. The file-position pointer is an integer value that specifies the location in the file as a number of bytes from the file's starting location. Some examples of positioning the "get" file-position pointer are: // position to the nth byte of fileObject (assumes ios::beg) fileObject.seekg( n ); // position n bytes forward in fileObject fileObject.seekg( n, ios::cur ); // position n bytes back from end of fileObject fileObject.seekg( n, ios::end ); // position at end of fileObject fileObject.seekg( 0, ios::end ); C++ 243 An exception is a problem that arises during the execution of a program. A C++ exception is a response to an exceptional circumstance that arises while a program is running, such as an attempt to divide by zero. Exceptions provide a way to transfer control from one part of a program to another. C++ exception handling is built upon three keywords: try, catch, and throw. · throw: A program throws an exception when a problem shows up. This is done using a throw keyword. · catch: A program catches an exception with an exception handler at the place in a program where you want to handle the problem. The catch keyword indicates the catching of an exception. · try: A try block identifies a block of code for which particular exceptions will be activated. It is followed by one or more catch blocks. Assuming a block will raise an exception, a method catches an exception using a combination of the try and catch keywords. A try/catch block is placed around the code that might generate an exception. Code within a try/catch block is referred to as protected code, and the syntax for using try/catch is as follows: try { // protected code }catch( ExceptionName e1 ) { // catch block }catch( ExceptionName e2 ) { // catch block }catch( ExceptionName eN ) { // catch block } You can list down multiple catch statements to catch different type of exceptions in case your try block raises more than one exception in different situations. 31. EXCEPTION HANDLING C++ 244 Throwing Exceptions Exceptions can be thrown anywhere within a code block using throw statement. The operand of the throw statement determines a type for the exception and can be any expression and the type of the result of the expression determines the type of exception thrown. Following is an example of throwing an exception when dividing by zero condition occurs: double division(int a, int b) { if( b == 0 ) { throw "Division by zero condition!"; } return (a/b); } Catching Exceptions The catch block following the try block catches any exception. You can specify what type of exception you want to catch and this is determined by the exception declaration that appears in parentheses following the keyword catch. try { // protected code }catch( ExceptionName e ) { // code to handle ExceptionName exception } Above code will catch an exception of ExceptionName type. If you want to specify that a catch block should handle any type of exception that is thrown in a try block, you must put an ellipsis, ..., between the parentheses enclosing the exception declaration as follows: try { // protected code }catch(...) C++ 245 { // code to handle any exception } The following is an example, which throws a division by zero exception and we catch it in catch block. #include using namespace std; double division(int a, int b) { if( b == 0 ) { throw "Division by zero condition!"; } return (a/b); } int main () { int x = 50; int y = 0; double z = 0; try { z = division(x, y); cout &lt;&lt; z &lt;&lt; endl; }catch (const char* msg) { cerr &lt;&lt; msg &lt;&lt; endl; } return 0; } C++ 246 Because we are raising an exception of type const char*, so while catching this exception, we have to use const char* in catch block. If we compile and run above code, this would produce the following result: Division by zero condition! C++ Standard Exceptions C++ provides a list of standard exceptions defined in which we can use in our programs. These are arranged in a parent-child class hierarchy shown below: Here is the small description of each exception mentioned in the above hierarchy: Exception Description std::exception An exception and parent class of all the standard C++ exceptions. C++ 247 std::bad_alloc This can be thrown by new. std::bad_cast This can be thrown by dynamic_cast. std::bad_exception This is useful device to handle unexpected exceptions in a C++ program. std::bad_typeid This can be thrown by typeid. std::logic_error An exception that theoretically can be detected by reading the code. std::domain_error This is an exception thrown when a mathematically invalid domain is used. std::invalid_argument This is thrown due to invalid arguments. std::length_error This is thrown when a too big std::string is created. std::out_of_range This can be thrown by the ‘at’ method, for example a std::vector and std::bitset&lt;&gt;::operator[](). std::runtime_error An exception that theoretically cannot be detected by reading the code. std::overflow_error This is thrown if a mathematical overflow occurs. std::range_error This is occurred when you try to store a value which is out of range. std::underflow_error This is thrown if a mathematical underflow occurs. Define New Exceptions You can define your own exceptions by inheriting and overriding exception class functionality. Following is the example, which shows how you can use std::exception class to implement your own exception in standard way: #include #include using namespace std; C++ 248 struct MyException : public exception { const char * what () const throw () { return "C++ Exception"; } }; int main() { try { throw MyException(); } catch(MyException&amp; e) { std::cout &lt;&lt; "MyException caught" &lt;&lt; std::endl; std::cout &lt;&lt; e.what() &lt;&lt; std::endl; } catch(std::exception&amp; e) { //Other errors } } This would produce the following result: MyException caught C++ Exception Here, what() is a public method provided by exception class and it has been overridden by all the child exception classes. This returns the cause of an exception. C++ 249 A good understanding of how dynamic memory really works in C++ is essential to becoming a good C++ programmer. Memory in your C++ program is divided into two parts: · The stack: All variables declared inside the function will take up memory from the stack. · The heap: This is unused memory of the program and can be used to allocate the memory dynamically when program runs. Many times, you are not aware in advance how much memory you will need to store particular information in a defined variable and the size of required memory can be determined at run time. You can allocate memory at run time within the heap for the variable of a given type using a special operator in C++ which returns the address of the space allocated. This operator is called new operator. If you are not in need of dynamically allocated memory anymore, you can use delete operator, which de-allocates memory previously allocated by new operator. The new and delete Operators There is following generic syntax to use new operator to allocate memory dynamically for any data-type. new data-type; Here, data-type could be any built-in data type including an array or any user defined data types include class or structure. Let us start with built-in data types. For example we can define a pointer to type double and then request that the memory be allocated at execution time. We can do this using the new operator with the following statements: double* pvalue = NULL; // Pointer initialized with null pvalue = new double; // Request memory for the variable The memory may not have been allocated successfully, if the free store had been used up. So it is good practice to check if new operator is returning NULL pointer and take appropriate action as below: 32. DYNAMIC MEMORY C++ 250 double* pvalue = NULL; if( !(pvalue = new double )) { cout &lt;&lt; "Error: out of memory." &lt;&lt;&lt;"Variable x = " &lt;&lt; x &lt;&lt; endl; #endif This causes the cerr statement to be compiled in the program if the symbolic constant DEBUG has been defined before directive #ifdef DEBUG. You can use #if 0 statement to comment out a portion of the program as follows: #if 0 code prevented from compiling #endif Let us try the following example: #include using namespace std; #define DEBUG #define MIN(a,b) (((a)&lt;&lt;"Trace: Inside main function" &lt;&lt; endl; #endif C++ 266 #if 0 /* This is commented part */ cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl; #endif cout &lt;&lt;"The minimum is " &lt;&lt; MIN(i, j) &lt;&lt; endl; #ifdef DEBUG cerr &lt;&lt;"Trace: Coming out of main function" &lt;&lt; endl; #endif return 0; } If we compile and run above code, this would produce the following result: Trace: Inside main function The minimum is 30 Trace: Coming out of main function The # and # # Operators The # and ## preprocessor operators are available in C++ and ANSI/ISO C. The # operator causes a replacement-text token to be converted to a string surrounded by quotes. Consider the following macro definition: #include using namespace std; #define MKSTR( x ) #x int main () { cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl; return 0; C++ 267 } If we compile and run above code, this would produce the following result: HELLO C++ Let us see how it worked. It is simple to understand that the C++ preprocessor turns the line: cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl; Above line will be turned into the following line: cout &lt;&lt; "HELLO C++" &lt;&lt; endl; The ## operator is used to concatenate two tokens. Here is an example: #define CONCAT( x, y ) x ## y When CONCAT appears in the program, its arguments are concatenated and used to replace the macro. For example, CONCAT(HELLO, C++) is replaced by "HELLO C++" in the program as follows. #include using namespace std; #define concat(a, b) a ## b int main() { int xy = 100; cout &lt;&lt; concat(x, y); return 0; } If we compile and run above code, this would produce the following result: 100 Let us see how it worked. It is simple to understand that the C++ preprocessor transforms: cout &lt;&lt; concat(x, y); C++ 268 Above line will be transformed into the following line: cout &lt;&lt; xy; Predefined C++ Macros C++ provides a number of predefined macros mentioned below: Macro Description __LINE__ This contains the current line number of the program when it is being compiled. __FILE__ This contains the current file name of the program when it is being compiled. __DATE__ This contains a string of the form month/day/year that is the date of the translation of the source file into object code. __TIME__ This contains a string of the form hour:minute:second that is the time at which the program was compiled. Let us see an example for all the above macros: #include using namespace std; int main () { cout &lt;&lt; "Value of __LINE__ : " &lt;&lt; __LINE__ &lt;&lt; endl; cout &lt;&lt; "Value of __FILE__ : " &lt;&lt; __FILE__ &lt;&lt; endl; cout &lt;&lt; "Value of __DATE__ : " &lt;&lt; __DATE__ &lt;&lt; endl; cout &lt;&lt; "Value of __TIME__ : " &lt;&lt; __TIME__ &lt;&lt; endl; return 0; } If we compile and run above code, this would produce the following result: C++ 269 Value of __LINE__ : 6 Value of __FILE__ : test.cpp Value of __DATE__ : Feb 28 2011 Value of __TIME__ : 18:52:48 C++ 270 Signals are the interrupts delivered to a process by the operating system which can terminate a program prematurely. You can generate interrupts by pressing Ctrl+C on a UNIX, LINUX, Mac OS X or Windows system. There are signals which cannot be caught by the program but there is a following list of signals which you can catch in your program and can take appropriate actions based on the signal. These signals are defined in C++ header file . Signal Description SIGABRT Abnormal termination of the program, such as a call to abort. SIGFPE An erroneous arithmetic operation, such as a divide by zero or an operation resulting in overflow. SIGILL Detection of an illegal instruction. SIGINT Receipt of an interactive attention signal. SIGSEGV An invalid access to storage. SIGTERM A termination request sent to the program. The signal() Function C++ signal-handling library provides function signal to trap unexpected events. Following is the syntax of the signal() function: void (*signal (int sig, void (*func)(int)))(int); Keeping it simple, this function receives two arguments: first argument as an integer, which represents signal number and second argument as a pointer to the signal-handling function. Let us write a simple C++ program where we will catch SIGINT signal using signal() function. Whatever signal you want to catch in your program, you must register that signal using signal function and associate it with a signal handler. Examine the following example: #include 36. SIGNAL HANDLING C++ 271 #include using namespace std; void signalHandler( int signum ) { cout &lt;&lt; "Interrupt signal (" &lt;&lt; signum &lt;&lt; ") received.\n"; // cleanup and close up stuff here // terminate program exit(signum); } int main () { // register signal SIGINT and signal handler signal(SIGINT, signalHandler); while(1){ cout &lt;&lt; "Going to sleep...." &lt;&lt; endl; sleep(1); } return 0; } When the above code is compiled and executed, it produces the following result: Going to sleep.... Going to sleep.... Going to sleep.... Now, press Ctrl+C to interrupt the program and you will see that your program will catch the signal and would come out by printing something as follows: C++ 272 Going to sleep.... Going to sleep.... Going to sleep.... Interrupt signal (2) received. The raise() Function You can generate signals by function raise(), which takes an integer signal number as an argument and has the following syntax. int raise (signal sig); Here, sig is the signal number to send any of the signals: SIGINT, SIGABRT, SIGFPE, SIGILL, SIGSEGV, SIGTERM, SIGHUP. Following is the example where we raise a signal internally using raise() function as follows: #include #include using namespace std; void signalHandler( int signum ) { cout &lt;&lt; "Interrupt signal (" &lt;&lt; signum &lt;&lt; ") received.\n"; // cleanup and close up stuff here // terminate program exit(signum); } int main () { int i = 0; // register signal SIGINT and signal handler signal(SIGINT, signalHandler); C++ 273 while(++i){ cout &lt;&lt; "Going to sleep...." &lt;&lt; endl; if( i == 3 ){ raise( SIGINT); } sleep(1); } return 0; } When the above code is compiled and executed, it produces the following result and would come out automatically: Going to sleep.... Going to sleep.... Going to sleep.... Interrupt signal (2) received. C++ 274 Multithreading is a specialized form of multitasking and a multitasking is the feature that allows your computer to run two or more programs concurrently. In general, there are two types of multitasking: process-based and thread-based. Process-based multitasking handles the concurrent execution of programs. Thread-based multitasking deals with the concurrent execution of pieces of the same program. A multithreaded program contains two or more parts that can run concurrently. Each part of such a program is called a thread, and each thread defines a separate path of execution. C++ does not contain any built-in support for multithreaded applications. Instead, it relies entirely upon the operating system to provide this feature. This tutorial assumes that you are working on Linux OS and we are going to write multi-threaded C++ program using POSIX. POSIX Threads, or Pthreads provides API which are available on many Unix-like POSIX systems such as FreeBSD, NetBSD, GNU/Linux, Mac OS X and Solaris. Creating Threads The following routine is used to create a POSIX thread: #include pthread_create (thread, attr, start_routine, arg) Here, pthread_create creates a new thread and makes it executable. This routine can be called any number of times from anywhere within your code. Here is the description of the parameters: Parameter Description thread An opaque, unique identifier for the new thread returned by the subroutine. attr An opaque attribute object that may be used to set thread attributes. You can specify a thread attributes object, or NULL for the default values. start_routine The C++ routine that the thread will execute once it is created. 37. MULTITHREADING C++ 275 arg A single argument that may be passed to start_routine. It must be passed by reference as a pointer cast of type void. NULL may be used if no argument is to be passed. The maximum number of threads that may be created by a process is implementation dependent. Once created, threads are peers, and may create other threads. There is no implied hierarchy or dependency between threads. Terminating Threads There is following routine which we use to terminate a POSIX thread: #include pthread_exit (status) Here pthread_exit is used to explicitly exit a thread. Typically, the pthread_exit() routine is called after a thread has completed its work and is no longer required to exist. If main() finishes before the threads it has created, and exits with pthread_exit(), the other threads will continue to execute. Otherwise, they will be automatically terminated when main() finishes. Example: This simple example code creates 5 threads with the pthread_create() routine. Each thread prints a "Hello World!" message, and then terminates with a call to pthread_exit(). #include #include #include using namespace std; #define NUM_THREADS 5 void *PrintHello(void *threadid) { long tid; tid = (long)threadid; cout &lt;&lt; "Hello World! Thread ID, " &lt;&lt; tid &lt;&lt; endl; C++ 276 pthread_exit(NULL); } int main () { pthread_t threads[NUM_THREADS]; int rc; int i; for( i=0; i &lt; NUM_THREADS; i++ ){ cout &lt;&lt; "main() : creating thread, " &lt;&lt; i &lt;&lt; endl; rc = pthread_create(&amp;threads[i], NULL, PrintHello, (void *)i); if (rc){ cout &lt;&lt; "Error:unable to create thread," &lt;&lt; rc &lt;&lt; endl; exit(-1); } } pthread_exit(NULL); } Compile the following program using -lpthread library as follows: $gcc test.cpp -lpthread Now, execute your program which gives the following output: main() : creating thread, 0 main() : creating thread, 1 main() : creating thread, 2 main() : creating thread, 3 main() : creating thread, 4 Hello World! Thread ID, 0 Hello World! Thread ID, 1 Hello World! Thread ID, 2 Hello World! Thread ID, 3 Hello World! Thread ID, 4 C++ 277 Passing Arguments to Threads This example shows how to pass multiple arguments via a structure. You can pass any data type in a thread callback because it points to void as explained in the following example: #include #include #include using namespace std; #define NUM_THREADS 5 struct thread_data{ int thread_id; char *message; }; void *PrintHello(void *threadarg) { struct thread_data *my_data; my_data = (struct thread_data *) threadarg; cout &lt;&lt; "Thread ID : " &lt;&lt; my_data-&gt;thread_id ; cout &lt;&lt; " Message : " &lt;&lt; my_data-&gt;message &lt;&lt; endl; pthread_exit(NULL); } int main () { pthread_t threads[NUM_THREADS]; struct thread_data td[NUM_THREADS]; int rc; C++ 278 int i; for( i=0; i &lt; NUM_THREADS; i++ ){ cout &lt;&lt;"main() : creating thread, " &lt;&lt; i &lt;&lt; endl; td[i].thread_id = i; td[i].message = "This is message"; rc = pthread_create(&amp;threads[i], NULL, PrintHello, (void *)&amp;td[i]); if (rc){ cout &lt;&lt; "Error:unable to create thread," &lt;&lt; rc &lt;&lt; endl; exit(-1); } } pthread_exit(NULL); } When the above code is compiled and executed, it produces the following result: main() : creating thread, 0 main() : creating thread, 1 main() : creating thread, 2 main() : creating thread, 3 main() : creating thread, 4 Thread ID : 3 Message : This is message Thread ID : 2 Message : This is message Thread ID : 0 Message : This is message Thread ID : 1 Message : This is message Thread ID : 4 Message : This is message Joining and Detaching Threads There are following two routines which we can use to join or detach threads: pthread_join (threadid, status) pthread_detach (threadid) C++ 279 The pthread_join() subroutine blocks the calling thread until the specified ‘threadid’ thread terminates. When a thread is created, one of its attributes defines whether it is joinable or detached. Only threads that are created as joinable can be joined. If a thread is created as detached, it can never be joined. This example demonstrates how to wait for thread completions by using the Pthread join routine. #include #include #include #include using namespace std; #define NUM_THREADS 5 void *wait(void *t) { int i; long tid; tid = (long)t; sleep(1); cout &lt;&lt; "Sleeping in thread " &lt;&lt; endl; cout &lt;&lt; "Thread with id : " &lt;&lt; tid &lt;&lt; " ...exiting " &lt;&lt; endl; pthread_exit(NULL); } int main () { int rc; int i; pthread_t threads[NUM_THREADS]; pthread_attr_t attr; void *status; C++ 280 // Initialize and set thread joinable pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); for( i=0; i &lt; NUM_THREADS; i++ ){ cout &lt;&lt; "main() : creating thread, " &lt;&lt; i &lt;&lt; endl; rc = pthread_create(&amp;threads[i], NULL, wait, (void *)i ); if (rc){ cout &lt;&lt; "Error:unable to create thread," &lt;&lt; rc &lt;&lt; endl; exit(-1); } } // free attribute and wait for the other threads pthread_attr_destroy(&amp;attr); for( i=0; i &lt; NUM_THREADS; i++ ){ rc = pthread_join(threads[i], &amp;status); if (rc){ cout &lt;&lt; "Error:unable to join," &lt;&lt; rc &lt;&lt; endl; exit(-1); } cout &lt;&lt; "Main: completed thread id :" &lt;&lt; i ; cout &lt;&lt; " exiting with status :" &lt;&lt; status &lt;&lt; endl; } cout &lt;&lt; "Main: program exiting." &lt;&lt; endl; pthread_exit(NULL); } When the above code is compiled and executed, it produces the following result: main() : creating thread, 0 main() : creating thread, 1 main() : creating thread, 2 C++ 281 main() : creating thread, 3 main() : creating thread, 4 Sleeping in thread Thread with id : 0 .... exiting Sleeping in thread Thread with id : 1 .... exiting Sleeping in thread Thread with id : 2 .... exiting Sleeping in thread Thread with id : 3 .... exiting Sleeping in thread Thread with id : 4 .... exiting Main: completed thread id :0 exiting with status :0 Main: completed thread id :1 exiting with status :0 Main: completed thread id :2 exiting with status :0 Main: completed thread id :3 exiting with status :0 Main: completed thread id :4 exiting with status :0 Main: program exiting. C++ 282 What is CGI? The Common Gateway Interface, or CGI, is a set of standards that define how information is exchanged between the web server and a custom script. The CGI specs are currently maintained by the NCSA and NCSA defines CGI is as follows: The Common Gateway Interface, or CGI, is a standard for external gateway programs to interface with information servers such as HTTP servers. The current version is CGI/1.1 and CGI/1.2 is under progress. Web Browsing To understand the concept of CGI, let's see what happens when we click a hyperlink to browse a particular web page or URL. · Your browser contacts the HTTP web server and demand for the URL i.e. filename. · Web Server will parse the URL and will look for the filename. If it finds the requested file then web server sends that file back to the browser otherwise sends an error message indicating that you have requested a wrong file. · Web browser takes response from web server and displays either the received file or error message based on the received response. However, it is possible to set up the HTTP server in such a way that whenever a file in a certain directory is requested, that file is not sent back; instead it is executed as a program, and produced output from the program is sent back to your browser to display. The Common Gateway Interface (CGI) is a standard protocol for enabling applications (called CGI programs or CGI scripts) to interact with Web servers and with clients. These CGI programs can be a written in Python, PERL, Shell, C or C++ etc. CGI Architecture Diagram The following simple program shows a simple architecture of CGI: 38. WEB PROGRAMMING C++ 283 Web Server Configuration Before you proceed with CGI Programming, make sure that your Web Server supports CGI and it is configured to handle CGI Programs. All the CGI Programs to be executed by the HTTP server are kept in a pre-configured directory. This directory is called CGI directory and by convention it is named as /var/www/cgibin. By convention CGI files will have extension as .cgi, though they are C++ executable. By default, Apache Web Server is configured to run CGI programs in /var/www/cgi-bin. If you want to specify any other directory to run your CGI scripts, you can modify the following section in the httpd.conf file: AllowOverride None Options ExecCGI Order allow,deny Allow from all C++ 284 Options All Here, I assume that you have Web Server up and running successfully and you are able to run any other CGI program like Perl or Shell etc. First CGI Program Consider the following C++ Program content: #include using namespace std; int main () { cout &lt;&lt; "Content-type:text/html\r\n\r\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "
\n"; cout &lt;&lt; "
Hello World! This is my first CGI program
\n"; cout &lt;&lt; "
\n"; cout &lt;&lt; "
\n"; return 0; } Compile above code and name the executable as cplusplus.cgi. This file is being kept in /var/www/cgi-bin directory and it has following content. Before running your CGI program make sure you have change mode of file using chmod 755 cplusplus.cgi UNIX command to make file executable. Now if you click cplusplus.cgi then this produces the following output: My First CGI program The above C++ program is a simple program which is writing its output on STDOUT file i.e. screen. There is one important and extra feature available which is first line printing Content-type:text/html\r\n\r\n. This line is sent back to the browser and specify the content type to be displayed on the browser screen. C++ 285 Now you must have understood the basic concept of CGI and you can write many complicated CGI programs using Python. A C++ CGI program can interact with any other external system, such as RDBMS, to exchange information. HTTP Header The line Content-type:text/html\r\n\r\n is a part of HTTP header, which is sent to the browser to understand the content. All the HTTP header will be in the following form: HTTP Field Name: Field Content For Example Content-type: text/html\r\n\r\n There are few other important HTTP headers, which you will use frequently in your CGI Programming. Header Description Content-type: A MIME string defining the format of the file being returned. Example is Content-type:text/html. Expires: Date The date the information becomes invalid. This should be used by the browser to decide when a page needs to be refreshed. A valid date string should be in the format 01 Jan 1998 12:00:00 GMT. Location: URL The URL that should be returned instead of the URL requested. You can use this field to redirect a request to any file. Last-modified: Date The date of last modification of the resource. Content-length: N The length, in bytes, of the data being returned. The browser uses this value to report the estimated download time for a file. Set-Cookie: String Set the cookie passed through the string. CGI Environment Variables All the CGI program will have access to the following environment variables. These variables play an important role while writing any CGI program. C++ 286 Variable Name Description CONTENT_TYPE The data type of the content, used when the client is sending attached content to the server. For example file upload etc. CONTENT_LENGTH The length of the query information that is available only for POST requests. HTTP_COOKIE Returns the set cookies in the form of key &amp; value pair. HTTP_USER_AGENT The User-Agent request-header field contains information about the user agent originating the request. It is a name of the web browser. PATH_INFO The path for the CGI script. QUERY_STRING The URL-encoded information that is sent with GET method request. REMOTE_ADDR The IP address of the remote host making the request. This can be useful for logging or for authentication purpose. REMOTE_HOST The fully qualified name of the host making the request. If this information is not available then REMOTE_ADDR can be used to get IR address. REQUEST_METHOD The method used to make the request. The most common methods are GET and POST. SCRIPT_FILENAME The full path to the CGI script. SCRIPT_NAME The name of the CGI script. SERVER_NAME The server's hostname or IP Address. SERVER_SOFTWARE The name and version of the software the server is running. C++ 287 Here is small CGI program to list out all the CGI variables. #include #include using namespace std; const string ENV[ 24 ] = { "COMSPEC", "DOCUMENT_ROOT", "GATEWAY_INTERFACE", "HTTP_ACCEPT", "HTTP_ACCEPT_ENCODING", "HTTP_ACCEPT_LANGUAGE", "HTTP_CONNECTION", "HTTP_HOST", "HTTP_USER_AGENT", "PATH", "QUERY_STRING", "REMOTE_ADDR", "REMOTE_PORT", "REQUEST_METHOD", "REQUEST_URI", "SCRIPT_FILENAME", "SCRIPT_NAME", "SERVER_ADDR", "SERVER_ADMIN", "SERVER_NAME","SERVER_PORT","SERVER_PROTOCOL", "SERVER_SIGNATURE","SERVER_SOFTWARE" }; int main () { cout &lt;&lt; "Content-type:text/html\r\n\r\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "
\n"; cout &lt;&lt; "
"; for ( int i = 0; i &lt; 24; i++ ) { cout &lt;&lt; " " &lt;&lt; ENV[ i ] &lt;&lt; "	"; // attempt to retrieve value of environment variable char *value = getenv( ENV[ i ].c_str() ); C++ 288 if ( value != 0 ){ cout &lt;&lt; value; }else{ cout &lt;&lt; "Environment variable does not exist."; } cout &lt;&lt; " \n"; } cout &lt;&lt; "	
&lt;&lt; "
\n"; cout &lt;&lt; "
\n"; return 0; } The output is as follows: COMSPEC Environment variable does not exist. DOCUMENT_ROOT /var/www/tutorialspoint GATEWAY_INTERFACE CGI/1.1 HTTP_ACCEPT text/html, application/xhtml+xml, */* HTTP_ACCEPT_ENCODING gzip, deflate HTTP_ACCEPT_LANGUAGE en-US HTTP_CONNECTION Keep-Alive HTTP_HOST www.tutorialspoint.com HTTP_USER_AGENT Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko PATH /sbin:/usr/sbin:/bin:/usr/bin QUERY_STRING REMOTE_ADDR 183.82.104.71 REMOTE_PORT 50902 REQUEST_METHOD GET REQUEST_URI /cgi-bin/cpp_env.cgi SCRIPT_FILENAME /var/www/cgi-bin/cpp_env.cgi SCRIPT_NAME /cgi-bin/cpp_env.cgi SERVER_ADDR 66.135.33.172 C++ 289 SERVER_ADMIN webmaster@tutorialspoint.com SERVER_NAME www.tutorialspoint.com SERVER_PORT 80 SERVER_PROTOCOL HTTP/1.1 SERVER_SIGNATURE SERVER_SOFTWARE Apache &lt; C++ CGI Library For real examples, you would need to do many operations by your CGI program. There is a CGI library written for C++ program which you can download from ftp://ftp.gnu.org/gnu/cgicc/ and follow the steps to install the library: $tar xzf cgicc-X.X.X.tar.gz $cd cgicc-X.X.X/ $./configure --prefix=/usr $make $make install You can check related documentation available at ‘C++ CGI Lib Documentation’. GET and POST Methods You must have come across many situations when you need to pass some information from your browser to web server and ultimately to your CGI Program. Most frequently browser uses two methods to pass this information to web server. These methods are GET Method and POST Method. Passing Information Using GET Method The GET method sends the encoded user information appended to the page request. The page and the encoded information are separated by the ‘?’ character as follows: http://www.test.com/cgi-bin/cpp.cgi?key1=value1&amp;key2=value2 The GET method is the default method to pass information from browser to web server and it produces a long string that appears in your browser's Location:box. Never use the GET method if you have password or other sensitive information to pass to the server. The GET method has size limitation and you can pass up to 1024 characters in a request string. When using GET method, information is passed using QUERY_STRING http header and will be accessible in your CGI Program through QUERY_STRING environment variable. C++ 290 You can pass information by simply concatenating key and value pairs along with any URL or you can use HTML 
Top of Form
tags to pass information using GET method. Simple URL Example: Get Method Here is a simple URL which will pass two values to hello_get.py program using GET method. /cgi-bin/cpp_get.cgi?first_name=ZARA&amp;last_name=ALI Below is a program to generate cpp_get.cgi CGI program to handle input given by web browser. We are going to use C++ CGI library which makes it very easy to access passed information: #include #include #include #include #include #include #include #include #include using namespace std; using namespace cgicc; int main () { Cgicc formData; cout &lt;&lt; "Content-type:text/html\r\n\r\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "
\n"; C++ 291 form_iterator fi = formData.getElement("first_name"); if( !fi-&gt;isEmpty() &amp;&amp; fi != (*formData).end()) { cout &lt;&lt; "First name: " &lt;&lt; **fi &lt;&lt; endl; }else{ cout &lt;&lt; "No text entered for first name" &lt;&lt; endl; } cout &lt;&lt; "
\n"; fi = formData.getElement("last_name"); if( !fi-&gt;isEmpty() &amp;&amp;fi != (*formData).end()) { cout &lt;&lt; "Last name: " &lt;&lt; **fi &lt;&lt; endl; }else{ cout &lt;&lt; "No text entered for last name" &lt;&lt; endl; } cout &lt;&lt; "
\n"; cout &lt;&lt; "
\n"; cout &lt;&lt; "
\n"; return 0; } Now, compile the above program as follows: $g++ -o cpp_get.cgi cpp_get.cpp -lcgicc Generate cpp_get.cgi and put it in your CGI directory and try to access using following link: /cgi-bin/cpp_get.cgi?first_name=ZARA&amp;last_name=ALI This would generate following result: First name: ZARA Last name: ALI Simple FORM Example: GET Method Here is a simple example which passes two values using HTML FORM and submit button. We are going to use same CGI script cpp_get.cgi to handle this input. 
Top of Form
C++ 292 First Name: 
Last Name: 
Bottom of Form
Here is the actual output of the above form. You enter First and Last Name and then click submit button to see the result. First Name: Last Name: Submit Passing Information Using POST Method A generally more reliable method of passing information to a CGI program is the POST method. This packages the information in exactly the same way as GET methods, but instead of sending it as a text string after a ‘?’ in the URL it sends it as a separate message. This message comes into the CGI script in the form of the standard input. The same cpp_get.cgi program will handle POST method as well. Let us take same example as above, which passes two values using HTML FORM and submit button but this time with POST method as follows: 
Top of Form
First Name: 
Last Name: 
Bottom of Form
Here is the actual output of the above form. You enter First and Last Name and then click submit button to see the result. First Name: Last Name: Submit Passing Checkbox Data to CGI Program Checkboxes are used when more than one option is required to be selected. C++ 293 Here is example HTML code for a form with two checkboxes: 
Top of Form
Maths Physics 
Bottom of Form
The result of this code is the following form: Maths Physics Select Subject Below is C++ program, which will generate cpp_checkbox.cgi script to handle input given by web browser through checkbox button. #include #include #include #include #include #include #include #include #include using namespace std; using namespace cgicc; int main () { Cgicc formData; bool maths_flag, physics_flag; cout &lt;&lt; "Content-type:text/html\r\n\r\n"; cout &lt;&lt; "\n"; C++ 294 cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "
\n"; maths_flag = formData.queryCheckbox("maths"); if( maths_flag ) { cout &lt;&lt; "Maths Flag: ON " &lt;&lt; endl; }else{ cout &lt;&lt; "Maths Flag: OFF " &lt;&lt; endl; } cout &lt;&lt; "
\n"; physics_flag = formData.queryCheckbox("physics"); if( physics_flag ) { cout &lt;&lt; "Physics Flag: ON " &lt;&lt; endl; }else{ cout &lt;&lt; "Physics Flag: OFF " &lt;&lt; endl; } cout &lt;&lt; "
\n"; cout &lt;&lt; "
\n"; cout &lt;&lt; "
\n"; return 0; } Passing Radio Button Data to CGI Program Radio Buttons are used when only one option is required to be selected. Here is example HTML code for a form with two radio button: 
Top of Form
Maths C++ 295 Physics 
Bottom of Form
The result of this code is the following form: Maths Physics Select Subject Below is C++ program, which will generate cpp_radiobutton.cgi script to handle input given by web browser through radio buttons. #include #include #include #include #include #include #include #include #include using namespace std; using namespace cgicc; int main () { Cgicc formData; cout &lt;&lt; "Content-type:text/html\r\n\r\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "
\n"; form_iterator fi = formData.getElement("subject"); C++ 296 if( !fi-&gt;isEmpty() &amp;&amp; fi != (*formData).end()) { cout &lt;&lt; "Radio box selected: " &lt;&lt; **fi &lt;&lt; endl; } cout &lt;&lt; "
\n"; cout &lt;&lt; "
\n"; cout &lt;&lt; "
\n"; return 0; } Passing Text Area Data to CGI Program TEXTAREA element is used when multiline text has to be passed to the CGI Program. Here is example HTML code for a form with a TEXTAREA box: 
Top of Form
Type your text here... 
Bottom of Form
The result of this code is the following form: Submit Below is C++ program, which will generate cpp_textarea.cgi script to handle input given by web browser through text area. #include #include #include #include C++ 297 #include #include #include #include #include using namespace std; using namespace cgicc; int main () { Cgicc formData; cout &lt;&lt; "Content-type:text/html\r\n\r\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "
\n"; form_iterator fi = formData.getElement("textcontent"); if( !fi-&gt;isEmpty() &amp;&amp; fi != (*formData).end()) { cout &lt;&lt; "Text Content: " &lt;&lt; **fi &lt;&lt; endl; }else{ cout &lt;&lt; "No text entered" &lt;&lt; endl; } cout &lt;&lt; "
\n"; cout &lt;&lt; "
\n"; cout &lt;&lt; "
\n"; return 0; } C++ 298 Passing Dropdown Box Data to CGI Program Dropdown Box is used when we have many options available but only one or two will be selected. Here is example HTML code for a form with one dropdown box: 
Top of Form
Maths Physics 
Bottom of Form
The result of this code is the following form: Maths Submit Below is C++ program, which will generate cpp_dropdown.cgi script to handle input given by web browser through drop down box. #include #include #include #include #include #include #include #include #include using namespace std; using namespace cgicc; int main () { Cgicc formData; C++ 299 cout &lt;&lt; "Content-type:text/html\r\n\r\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "
\n"; form_iterator fi = formData.getElement("dropdown"); if( !fi-&gt;isEmpty() &amp;&amp; fi != (*formData).end()) { cout &lt;&lt; "Value Selected: " &lt;&lt; **fi &lt;&lt; endl; } cout &lt;&lt; "
\n"; cout &lt;&lt; "
\n"; cout &lt;&lt; "
\n"; return 0; } Using Cookies in CGI HTTP protocol is a stateless protocol. But for a commercial website it is required to maintain session information among different pages. For example one user registration ends after completing many pages. But how to maintain user's session information across all the web pages. In many situations, using cookies is the most efficient method of remembering and tracking preferences, purchases, commissions, and other information required for better visitor experience or site statistics. How It Works Your server sends some data to the visitor's browser in the form of a cookie. The browser may accept the cookie. If it does, it is stored as a plain text record on the visitor's hard drive. Now, when the visitor arrives at another page on your site, the cookie is available for retrieval. Once retrieved, your server knows/remembers what was stored. Cookies are a plain text data record of 5 variable-length fields: · Expires: This showsthe date the cookie will expire. If this is blank, the cookie will expire when the visitor quits the browser. C++ 300 · Domain: This is the domain name of your site. · Path: This is the path to the directory or web page that sets the cookie. This may be blank if you want to retrieve the cookie from any directory or page. · Secure: If this field contains the word "secure" then the cookie may only be retrieved with a secure server. If this field is blank, no such restriction exists. · Name=Value: Cookies are set and retrieved in the form of key and value pairs. Setting up Cookies It is very easy to send cookies to browser. These cookies will be sent along with HTTP Header before the Content-type filed. Assuming you want to set UserID and Password as cookies. So cookies setting will be done as follows: #include using namespace std; int main () { cout &lt;&lt; "Set-Cookie:UserID=XYZ;\r\n"; cout &lt;&lt; "Set-Cookie:Password=XYZ123;\r\n"; cout &lt;&lt; "Set-Cookie:Domain=www.tutorialspoint.com;\r\n"; cout &lt;&lt; "Set-Cookie:Path=/perl;\n"; cout &lt;&lt; "Content-type:text/html\r\n\r\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "
\n"; cout &lt;&lt; "Setting cookies" &lt;&lt; endl; cout &lt;&lt; "
\n"; cout &lt;&lt; "
\n"; C++ 301 cout &lt;&lt; "
\n"; return 0; } From this example, you must have understood how to set cookies. We use SetCookie HTTP header to set cookies. Here, it is optional to set cookies attributes like Expires, Domain, and Path. It is notable that cookies are set before sending magic line "Contenttype:text/html\r\n\r\n. Compile above program to produce setcookies.cgi, and try to set cookies using following link. It will set four cookies at your computer: /cgi-bin/setcookies.cgi Retrieving Cookies It is easy to retrieve all the set cookies. Cookies are stored in CGI environment variable HTTP_COOKIE and they will have following form. key1=value1;key2=value2;key3=value3.... Here is an example of how to retrieve cookies. #include #include #include #include #include #include #include #include #include using namespace std; using namespace cgicc; int main () { C++ 302 Cgicc cgi; const_cookie_iterator cci; cout &lt;&lt; "Content-type:text/html\r\n\r\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "
\n"; cout &lt;&lt; "
"; // get environment variables const CgiEnvironment&amp; env = cgi.getEnvironment(); for( cci = env.getCookieList().begin(); cci != env.getCookieList().end(); ++cci ) { cout &lt;&lt; " " &lt;&lt; cci-&gt;getName() &lt;&lt; "	"; cout &lt;&lt; cci-&gt;getValue(); cout &lt;&lt; " \n"; } cout &lt;&lt; "	
&lt;&lt; "
\n"; cout &lt;&lt; "
\n"; cout &lt;&lt; "
\n"; return 0; } Now, compile above program to produce getcookies.cgi, and try to get a list of all the cookies available at your computer: /cgi-bin/getcookies.cgi C++ 303 This will produce a list of all the four cookies set in previous section and all other cookies set in your computer: UserID XYZ Password XYZ123 Domain www.tutorialspoint.com Path /perl File Upload Example To upload a file the HTML form must have the enctype attribute set to multipart/form-data. The input tag with the file type will create a "Browse" button. 
Top of Form
File: 
Bottom of Form
The result of this code is the following form: File: Upload Note: Above example has been disabled intentionally to stop people uploading files on our server. But you can try above code with your server. Here is the script cpp_uploadfile.cpp to handle file upload: #include #include #include #include #include C++ 304 #include #include #include #include using namespace std; using namespace cgicc; int main () { Cgicc cgi; cout &lt;&lt; "Content-type:text/html\r\n\r\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "\n"; cout &lt;&lt; "
\n"; // get list of files to be uploaded const_file_iterator file = cgi.getFile("userfile"); if(file != cgi.getFiles().end()) { // send data type at cout. cout &lt;&lt; HTTPContentHeader(file-&gt;getDataType()); // write content at cout. file-&gt;writeToStream(cout); } cout &lt;&lt; "\n"; cout &lt;&lt; "
\n"; cout &lt;&lt; "
\n"; return 0; } C++ 305 The above example is for writing content at cout stream but you can open your file stream and save the content of uploaded file in a file at desired location. Hope you have enjoyed this tutorial. If yes, please send us your feedback. C++ 306 Hope you have already understood the concept of C++ Template which we have discussed earlier. The C++ STL (Standard Template Library) is a powerful set of C++ template classes to provide general-purpose classes and functions with templates that implement many popular and commonly used algorithms and data structures like vectors, lists, queues, and stacks. At the core of the C++ Standard Template Library are following three wellstructured components: Component Description Containers Containers are used to manage collections of objects of a certain kind. There are several different types of containers like deque, list, vector, map etc. Algorithms Algorithms act on containers. They provide the means by which you will perform initialization, sorting, searching, and transforming of the contents of containers. Iterators Iterators are used to step through the elements of collections of objects. These collections may be containers or subsets of containers. We will discuss about all the three C++ STL components in next chapter while discussing C++ Standard Library. For now, keep in mind that all the three components have a rich set of pre-defined functions which help us in doing complicated tasks in very easy fashion. Let us take the following program that demonstrates the vector container (a C++ Standard Template) which is similar to an array with an exception that it automatically handles its own storage requirements in case it grows: #include #include using namespace std; int main() { 39. STL TUTORIAL C++ 307 // create a vector to store int vector vec; int i; // display the original size of vec cout &lt;&lt; "vector size = " &lt;&lt; vec.size() &lt;&lt; endl; // push 5 values into the vector for(i = 0; i &lt; 5; i++){ vec.push_back(i); } // display extended size of vec cout &lt;&lt; "extended vector size = " &lt;&lt; vec.size() &lt;&lt; endl; // access 5 values from the vector for(i = 0; i &lt; 5; i++){ cout &lt;&lt; "value of vec [" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; vec[i] &lt;&lt; endl; } // use iterator to access the values vector::iterator v = vec.begin(); while( v != vec.end()) { cout &lt;&lt; "value of v = " &lt;&lt; *v &lt;&lt; endl; v++; } return 0; } When the above code is compiled and executed, it produces the following result: vector size = 0 extended vector size = 5 value of vec [0] = 0 C++ 308 value of vec [1] = 1 value of vec [2] = 2 value of vec [3] = 3 value of vec [4] = 4 value of v = 0 value of v = 1 value of v = 2 value of v = 3 value of v = 4 Here are following points to be noted related to various functions we used in the above example: · The push_back( ) member function inserts value at the end of the vector, expanding its size as needed. · The size( ) function displays the size of the vector. · The function begin( ) returns an iterator to the start of the vector. · The function end( ) returns an iterator to the end of the vector. C++ 309 The C++ Standard Library can be categorized into two parts: · The Standard Function Library: This library consists of generalpurpose, stand-alone functions that are not part of any class. The function library is inherited from C. · The Object Oriented Class Library: This is a collection of classes and associated functions. Standard C++ Library incorporates all the Standard C libraries also, with small additions and changes to support type safety. The Standard Function Library The standard function library is divided into the following categories: · I/O, · String and character handling, · Mathematical, · Time, date, and localization, · Dynamic allocation, · Miscellaneous, · Wide-character functions The Object Oriented Class Library Standard C++ Object Oriented Library defines an extensive set of classes that provide support for a number of common activities, including I/O, strings, and numeric processing. This library includes the following: · The Standard C++ I/O Classes · The String Class · The Numeric Classes · The STL Container Classes · The STL Algorithms · The STL Function Objects · The STL Iterators · The STL Allocators 40. STANDARD LIBRARY C++ 310 · The Localization library · Exception Handling Classes · Miscellaneous Support Library
</value>
  </data>
</root>